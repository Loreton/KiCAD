# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if False:
   def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pcbnew', [dirname(__file__)])
        except ImportError:
            import _pcbnew
            return _pcbnew
        if fp is not None:
            try:
                _mod = imp.load_module('_pcbnew', fp, pathname, description)
            finally:
                fp.close()
            return _mod
        _pcbnew = swig_import_helper()
        del swig_import_helper
else:
    import _pcbnew
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
         if type(value).__name__ == 'SwigPyObject':
             self.__dict__[name] = value
             return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
     if (name == "thisown"): return self.this.own()
     method = class_type.__swig_getmethods__.get(name,None)
     if method: return method(self)
     raise AttributeError(name)

def _swig_repr(self):
     try: strthis = "proxy of " + self.this.__repr__()
     except: strthis = ""
     return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
     _object = object
     _newclass = 1
except AttributeError:
     class _object : pass
     _newclass = 0

'''
class SwigPyIterator(_object):
     """Proxy of C++ swig::SwigPyIterator class"""
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
     __swig_getmethods__ = {}
     __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
     __repr__ = _swig_repr
     __swig_destroy__ = _pcbnew.delete_SwigPyIterator
     __del__ = lambda self : None;
    def value(self):
         """value(SwigPyIterator self) -> PyObject *"""
         return _pcbnew.SwigPyIterator_value(self)

    def incr(self, n=1):
         """
         incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
         incr(SwigPyIterator self) -> SwigPyIterator
         """
         return _pcbnew.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
         """
         decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator
         decr(SwigPyIterator self) -> SwigPyIterator
         """
         return _pcbnew.SwigPyIterator_decr(self, n)

    def distance(self, *args):
         """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
         return _pcbnew.SwigPyIterator_distance(self, *args)

    def equal(self, *args):
         """equal(SwigPyIterator self, SwigPyIterator x) -> bool"""
         return _pcbnew.SwigPyIterator_equal(self, *args)

    def copy(self):
         """copy(SwigPyIterator self) -> SwigPyIterator"""
         return _pcbnew.SwigPyIterator_copy(self)

    def next(self):
         """next(SwigPyIterator self) -> PyObject *"""
         return _pcbnew.SwigPyIterator_next(self)

    def __next__(self):
         """__next__(SwigPyIterator self) -> PyObject *"""
         return _pcbnew.SwigPyIterator___next__(self)

    def previous(self):
         """previous(SwigPyIterator self) -> PyObject *"""
         return _pcbnew.SwigPyIterator_previous(self)

    def advance(self, *args):
         """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
         return _pcbnew.SwigPyIterator_advance(self, *args)

    def __eq__(self, *args):
         """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
         return _pcbnew.SwigPyIterator___eq__(self, *args)

    def __ne__(self, *args):
         """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
         return _pcbnew.SwigPyIterator___ne__(self, *args)

    def __iadd__(self, *args):
         """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
         return _pcbnew.SwigPyIterator___iadd__(self, *args)

    def __isub__(self, *args):
         """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
         return _pcbnew.SwigPyIterator___isub__(self, *args)

    def __add__(self, *args):
         """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
         return _pcbnew.SwigPyIterator___add__(self, *args)

    def __sub__(self, *args):
         """
         __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
         __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
         """
         return _pcbnew.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _pcbnew.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


def wxSetDefaultPyEncoding(*args):
   """wxSetDefaultPyEncoding(char const * encoding)"""
   return _pcbnew.wxSetDefaultPyEncoding(*args)

def wxGetDefaultPyEncoding():
   """wxGetDefaultPyEncoding() -> char const *"""
   return _pcbnew.wxGetDefaultPyEncoding()
class wxRect(_object):
     """Proxy of C++ wxRect class"""
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, wxRect, name, value)
     __swig_getmethods__ = {}
     __getattr__ = lambda self, name: _swig_getattr(self, wxRect, name)
     __repr__ = _swig_repr
    def __init__(self, *args):
         """
         __init__(wxRect self) -> wxRect
         __init__(wxRect self, int xx, int yy, int ww, int hh) -> wxRect
         __init__(wxRect self, wxPoint topLeft, wxPoint bottomRight) -> wxRect
         __init__(wxRect self, wxPoint pt, wxSize size) -> wxRect
         __init__(wxRect self, wxSize size) -> wxRect
         """
         this = _pcbnew.new_wxRect(*args)
         try: self.this.append(this)
         except: self.this = this
    def GetX(self):
         """GetX(wxRect self) -> int"""
         return _pcbnew.wxRect_GetX(self)

    def SetX(self, *args):
         """SetX(wxRect self, int xx)"""
         return _pcbnew.wxRect_SetX(self, *args)

    def GetY(self):
         """GetY(wxRect self) -> int"""
         return _pcbnew.wxRect_GetY(self)

    def SetY(self, *args):
         """SetY(wxRect self, int yy)"""
         return _pcbnew.wxRect_SetY(self, *args)

    def GetWidth(self):
         """GetWidth(wxRect self) -> int"""
         return _pcbnew.wxRect_GetWidth(self)

    def SetWidth(self, *args):
         """SetWidth(wxRect self, int w)"""
         return _pcbnew.wxRect_SetWidth(self, *args)

    def GetHeight(self):
         """GetHeight(wxRect self) -> int"""
         return _pcbnew.wxRect_GetHeight(self)

    def SetHeight(self, *args):
         """SetHeight(wxRect self, int h)"""
         return _pcbnew.wxRect_SetHeight(self, *args)

    def GetPosition(self):
         """GetPosition(wxRect self) -> wxPoint"""
         return _pcbnew.wxRect_GetPosition(self)

    def SetPosition(self, *args):
         """SetPosition(wxRect self, wxPoint p)"""
         return _pcbnew.wxRect_SetPosition(self, *args)

     __swig_setmethods__["x"] = _pcbnew.wxRect_x_set
     __swig_getmethods__["x"] = _pcbnew.wxRect_x_get
     if _newclass:x = _swig_property(_pcbnew.wxRect_x_get, _pcbnew.wxRect_x_set)
     __swig_setmethods__["y"] = _pcbnew.wxRect_y_set
     __swig_getmethods__["y"] = _pcbnew.wxRect_y_get
     if _newclass:y = _swig_property(_pcbnew.wxRect_y_get, _pcbnew.wxRect_y_set)
     __swig_setmethods__["width"] = _pcbnew.wxRect_width_set
     __swig_getmethods__["width"] = _pcbnew.wxRect_width_get
     if _newclass:width = _swig_property(_pcbnew.wxRect_width_get, _pcbnew.wxRect_width_set)
     __swig_setmethods__["height"] = _pcbnew.wxRect_height_set
     __swig_getmethods__["height"] = _pcbnew.wxRect_height_get
     if _newclass:height = _swig_property(_pcbnew.wxRect_height_get, _pcbnew.wxRect_height_set)
    def Get(self):
         """Get(wxRect self) -> PyObject *"""
         return _pcbnew.wxRect_Get(self)

    def __eq__(self,other):
         return self.x==other.x and self.y==other.y and self.width==other.width and self.height==other.height
    def __str__(self):                   return str(self.Get())
    def __repr__(self):                  return 'wxRect'+str(self.Get())
    def __len__(self):                   return len(self.Get())
    def __getitem__(self, index):        return self.Get()[index]
    def __setitem__(self, index, val):
         if  index == 0:     self.SetX(val)
         elif    index == 1:     self.SetY(val)
         elif    index == 2:     self.SetWidth(val)
         elif    index == 3:     self.SetHeight(val)
         else:           raise IndexError
    def __nonzero__(self):               return self.Get() != (0,0,0,0)
     __safe_for_unpickling__ = True

     __swig_destroy__ = _pcbnew.delete_wxRect
     __del__ = lambda self : None;
wxRect_swigregister = _pcbnew.wxRect_swigregister
wxRect_swigregister(wxRect)

class wxSize(_object):
    """Proxy of C++ wxSize class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, wxSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, wxSize, name)
    __repr__ = _swig_repr
    __swig_setmethods__["x"] = _pcbnew.wxSize_x_set
    __swig_getmethods__["x"] = _pcbnew.wxSize_x_get
    if _newclass:x = _swig_property(_pcbnew.wxSize_x_get, _pcbnew.wxSize_x_set)
    __swig_setmethods__["y"] = _pcbnew.wxSize_y_set
    __swig_getmethods__["y"] = _pcbnew.wxSize_y_get
    if _newclass:y = _swig_property(_pcbnew.wxSize_y_get, _pcbnew.wxSize_y_set)
    def __init__(self, *args):
         """
         __init__(wxSize self, int xx, int yy) -> wxSize
         __init__(wxSize self, double xx, double yy) -> wxSize
         """
         this = _pcbnew.new_wxSize(*args)
         try: self.this.append(this)
         except: self.this = this
    def Get(self):
         """Get(wxSize self) -> PyObject *"""
         return _pcbnew.wxSize_Get(self)

     __swig_destroy__ = _pcbnew.delete_wxSize
     __del__ = lambda self : None;
    def SetWidth(self, *args):
         """SetWidth(wxSize self, int w)"""
         return _pcbnew.wxSize_SetWidth(self, *args)

    def SetHeight(self, *args):
         """SetHeight(wxSize self, int h)"""
         return _pcbnew.wxSize_SetHeight(self, *args)

    def GetWidth(self):
         """GetWidth(wxSize self) -> int"""
         return _pcbnew.wxSize_GetWidth(self)

    def GetHeight(self):
         """GetHeight(wxSize self) -> int"""
         return _pcbnew.wxSize_GetHeight(self)

    def Scale(self,xscale,yscale):
         return wxSize(self.x*xscale,self.y*yscale)
    def __eq__(self,other):
         return self.GetWidth()==other.GetWidth() and self.GetHeight()==other.GetHeight()
    def __str__(self):                   return str(self.Get())
    def __repr__(self):                  return 'wxSize'+str(self.Get())
    def __len__(self):                   return len(self.Get())
    def __getitem__(self, index):        return self.Get()[index]
    def __setitem__(self, index, val):
         if  index == 0:     self.SetWidth(val)
         elif    index == 1:     self.SetHeight(val)
         else:           raise IndexError
    def __nonzero__(self):               return self.Get() != (0,0)
     __safe_for_unpickling__ = True


 wxSize_swigregister = _pcbnew.wxSize_swigregister
 wxSize_swigregister(wxSize)

 class wxPoint(_object):
     """
     C++ includes:
     polygon_test_point_inside.h
     """
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, wxPoint, name, value)
     __swig_getmethods__ = {}
     __getattr__ = lambda self, name: _swig_getattr(self, wxPoint, name)
     __repr__ = _swig_repr
     __swig_setmethods__["x"] = _pcbnew.wxPoint_x_set
     __swig_getmethods__["x"] = _pcbnew.wxPoint_x_get
     if _newclass:x = _swig_property(_pcbnew.wxPoint_x_get, _pcbnew.wxPoint_x_set)
     __swig_setmethods__["y"] = _pcbnew.wxPoint_y_set
     __swig_getmethods__["y"] = _pcbnew.wxPoint_y_get
     if _newclass:y = _swig_property(_pcbnew.wxPoint_y_get, _pcbnew.wxPoint_y_set)
    def __init__(self, *args):
         """
         __init__(wxPoint self, int xx, int yy) -> wxPoint
         __init__(wxPoint self, double xx, double yy) -> wxPoint

         C++ includes:
         polygon_test_point_inside.h
         """
         this = _pcbnew.new_wxPoint(*args)
         try: self.this.append(this)
         except: self.this = this
     __swig_destroy__ = _pcbnew.delete_wxPoint
     __del__ = lambda self : None;
    def __add__(self, *args):
         """__add__(wxPoint self, wxPoint pt) -> wxPoint"""
         return _pcbnew.wxPoint___add__(self, *args)

    def __sub__(self, *args):
         """__sub__(wxPoint self, wxPoint pt) -> wxPoint"""
         return _pcbnew.wxPoint___sub__(self, *args)

    def Set(self, *args):
         """Set(wxPoint self, long x, long y)"""
         return _pcbnew.wxPoint_Set(self, *args)

    def Get(self):
         """Get(wxPoint self) -> PyObject *"""
         return _pcbnew.wxPoint_Get(self)

    def __eq__(self,other):            return (self.x==other.x and self.y==other.y)
    def __ne__(self,other):            return not (self==other)
    def __str__(self):                 return str(self.Get())
    def __repr__(self):                return 'wxPoint'+str(self.Get())
    def __len__(self):                 return len(self.Get())
    def __getitem__(self, index):      return self.Get()[index]
    def __setitem__(self, index, val):
         if index == 0:
             self.x = val
         elif index == 1:
             self.y = val
         else:
             raise IndexError
    def __nonzero__(self):               return self.Get() != (0,0)


 wxPoint_swigregister = _pcbnew.wxPoint_swigregister
 wxPoint_swigregister(wxPoint)

 class DHEAD(_object):
     """
     Class DHEAD is only for use by template class DLIST, use that instead.

     C++ includes: dlist.h
     """
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, DHEAD, name, value)
     __swig_getmethods__ = {}
     __getattr__ = lambda self, name: _swig_getattr(self, DHEAD, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
    def DeleteAll(self):
         """
         DeleteAll(DHEAD self)

         void DHEAD::DeleteAll()

         Function DeleteAll deletes all items on the list and leaves the list
         empty.

         The destructor for each item is called.
         """
         return _pcbnew.DHEAD_DeleteAll(self)

    def SetOwnership(self, *args):
         """
         SetOwnership(DHEAD self, bool Iown)

         void
         DHEAD::SetOwnership(bool Iown)

         Function SetOwnership controls whether the list owns the objects and
         is responsible for deleteing their memory at time of this object's
         destruction.
         """
         return _pcbnew.DHEAD_SetOwnership(self, *args)

    def GetCount(self):
         """
         GetCount(DHEAD self) -> unsigned int

         unsigned DHEAD::GetCount()
         const

         Function GetCount returns the number of elements in the list.
         """
         return _pcbnew.DHEAD_GetCount(self)

 DHEAD_swigregister = _pcbnew.DHEAD_swigregister
 DHEAD_swigregister(DHEAD)

 NO_FILL = _pcbnew.NO_FILL
 FILLED_SHAPE = _pcbnew.FILLED_SHAPE
 FILLED_WITH_BG_BODYCOLOR = _pcbnew.FILLED_WITH_BG_BODYCOLOR
 SEARCH_QUIT = _pcbnew.SEARCH_QUIT
 SEARCH_CONTINUE = _pcbnew.SEARCH_CONTINUE
 class INSPECTOR(_object):
     """
     Class INSPECTOR is an abstract class that is used to inspect and
     possibly collect the (search) results of Iterating over a list or tree
     of KICAD_T objects.

     Extend from this class and implement the Inspect function and provide
     for a way for the extension to collect the results of the search/scan
     data and provide them to the caller.

     C++ includes: base_struct.h
     """
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, INSPECTOR, name, value)
     __swig_getmethods__ = {}
     __getattr__ = lambda self, name: _swig_getattr(self, INSPECTOR, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
     __repr__ = _swig_repr
     __swig_destroy__ = _pcbnew.delete_INSPECTOR
     __del__ = lambda self : None;
    def Inspect(self, *args):
         """
         Inspect(INSPECTOR self, EDA_ITEM aItem, void const * aTestData) -> SEARCH_RESULT

         virtual SEARCH_RESULT
         INSPECTOR::Inspect(EDA_ITEM *aItem, const void *aTestData)=0

         Function Inspect is the examining function within the INSPECTOR which
         is passed to the EDA_ITEM::Iterate() function.

         It is used primarily for searching, but not limited to that. It can
         also collect or modify the scanned objects.

         Parameters:
         -----------

         aItem:  An EDA_ITEM to examine.

         aTestData:  is arbitrary data needed by the inspector to determine if
         the EDA_ITEM under test meets its match criteria.

         A SEARCH_RESULT type SEARCH_QUIT if the iterator function is to stop
         the scan, else SEARCH_CONTINUE;
         """
         return _pcbnew.INSPECTOR_Inspect(self, *args)

 INSPECTOR_swigregister = _pcbnew.INSPECTOR_swigregister
 INSPECTOR_swigregister(INSPECTOR)
 cvar = _pcbnew.cvar
 traceFindReplace = cvar.traceFindReplace

 IS_CHANGED = _pcbnew.IS_CHANGED
 IS_LINKED = _pcbnew.IS_LINKED
 IN_EDIT = _pcbnew.IN_EDIT
 IS_MOVED = _pcbnew.IS_MOVED
 IS_NEW = _pcbnew.IS_NEW
 IS_RESIZED = _pcbnew.IS_RESIZED
 IS_DRAGGED = _pcbnew.IS_DRAGGED
 IS_DELETED = _pcbnew.IS_DELETED
 IS_WIRE_IMAGE = _pcbnew.IS_WIRE_IMAGE
 STARTPOINT = _pcbnew.STARTPOINT
 ENDPOINT = _pcbnew.ENDPOINT
 SELECTED = _pcbnew.SELECTED
 SELECTEDNODE = _pcbnew.SELECTEDNODE
 STRUCT_DELETED = _pcbnew.STRUCT_DELETED
 CANDIDATE = _pcbnew.CANDIDATE
 SKIP_STRUCT = _pcbnew.SKIP_STRUCT
 DO_NOT_DRAW = _pcbnew.DO_NOT_DRAW
 IS_CANCELLED = _pcbnew.IS_CANCELLED
 TRACK_LOCKED = _pcbnew.TRACK_LOCKED
 TRACK_AR = _pcbnew.TRACK_AR
 FLAG1 = _pcbnew.FLAG1
 FLAG0 = _pcbnew.FLAG0
 BEGIN_ONPAD = _pcbnew.BEGIN_ONPAD
 END_ONPAD = _pcbnew.END_ONPAD
 BUSY = _pcbnew.BUSY
 HIGHLIGHTED = _pcbnew.HIGHLIGHTED
 BRIGHTENED = _pcbnew.BRIGHTENED
 EDA_ITEM_ALL_FLAGS = _pcbnew.EDA_ITEM_ALL_FLAGS
 class EDA_ITEM(_object):
     """
     Class EDA_ITEM is a base class for most all the KiCad significant
     classes, used in schematics and boards.

     C++ includes: base_struct.h
     """
     __swig_setmethods__ = {}
     __setattr__ = lambda self, name, value: _swig_setattr(self, EDA_ITEM, name, value)
     __swig_getmethods__ = {}
     __getattr__ = lambda self, name: _swig_getattr(self, EDA_ITEM, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
     __swig_destroy__ = _pcbnew.delete_EDA_ITEM
     __del__ = lambda self : None;
    def Type(self):
         """
         Type(EDA_ITEM self) -> KICAD_T

         KICAD_T EDA_ITEM::Type() const

         Function Type()

         returns the type of object. This attribute should never be changed
         after a constructor sets it, so there is no public "setter" method.
         KICAD_T - the type of object.
         """
         return _pcbnew.EDA_ITEM_Type(self)

    def SetTimeStamp(self, *args):
         """
         SetTimeStamp(EDA_ITEM self, time_t aNewTimeStamp)

         void
         EDA_ITEM::SetTimeStamp(time_t aNewTimeStamp)
         """
         return _pcbnew.EDA_ITEM_SetTimeStamp(self, *args)

    def GetTimeStamp(self):
         """
         GetTimeStamp(EDA_ITEM self) -> time_t

         time_t
         EDA_ITEM::GetTimeStamp() const
         """
         return _pcbnew.EDA_ITEM_GetTimeStamp(self)

    def Next(self):
         """
         Next(EDA_ITEM self) -> EDA_ITEM

         EDA_ITEM* EDA_ITEM::Next()
         const
         """
         return _pcbnew.EDA_ITEM_Next(self)

    def Back(self):
         """
         Back(EDA_ITEM self) -> EDA_ITEM

         EDA_ITEM* EDA_ITEM::Back()
         const
         """
         return _pcbnew.EDA_ITEM_Back(self)

    def GetParent(self):
         """
         GetParent(EDA_ITEM self) -> EDA_ITEM

         EDA_ITEM*
         EDA_ITEM::GetParent() const
         """
         return _pcbnew.EDA_ITEM_GetParent(self)

    def GetList(self):
         """
         GetList(EDA_ITEM self) -> DHEAD

         DHEAD* EDA_ITEM::GetList()
         const
         """
         return _pcbnew.EDA_ITEM_GetList(self)

    def SetParent(self, *args):
         """
         SetParent(EDA_ITEM self, EDA_ITEM aParent)

         void
         EDA_ITEM::SetParent(EDA_ITEM *aParent)
         """
         return _pcbnew.EDA_ITEM_SetParent(self, *args)

    def SetList(self, *args):
         """
         SetList(EDA_ITEM self, DHEAD aList)

         void
         EDA_ITEM::SetList(DHEAD *aList)
         """
         return _pcbnew.EDA_ITEM_SetList(self, *args)

    def IsNew(self):
         """
         IsNew(EDA_ITEM self) -> bool

         bool EDA_ITEM::IsNew() const

         """
         return _pcbnew.EDA_ITEM_IsNew(self)

    def IsModified(self):
         """
         IsModified(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsModified() const
         """
         return _pcbnew.EDA_ITEM_IsModified(self)

    def IsMoving(self):
         """
         IsMoving(EDA_ITEM self) -> bool

         bool EDA_ITEM::IsMoving()
         const
         """
         return _pcbnew.EDA_ITEM_IsMoving(self)

    def IsDragging(self):
         """
         IsDragging(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsDragging() const
         """
         return _pcbnew.EDA_ITEM_IsDragging(self)

    def IsWireImage(self):
         """
         IsWireImage(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsWireImage() const
         """
         return _pcbnew.EDA_ITEM_IsWireImage(self)

    def IsSelected(self):
         """
         IsSelected(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsSelected() const
         """
         return _pcbnew.EDA_ITEM_IsSelected(self)

    def IsResized(self):
         """
         IsResized(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsResized() const
         """
         return _pcbnew.EDA_ITEM_IsResized(self)

    def IsHighlighted(self):
         """
         IsHighlighted(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsHighlighted() const
         """
         return _pcbnew.EDA_ITEM_IsHighlighted(self)

    def IsBrightened(self):
         """
         IsBrightened(EDA_ITEM self) -> bool

         bool
         EDA_ITEM::IsBrightened() const
         """
         return _pcbnew.EDA_ITEM_IsBrightened(self)

    def SetWireImage(self):
         """
         SetWireImage(EDA_ITEM self)

         void
         EDA_ITEM::SetWireImage()
         """
         return _pcbnew.EDA_ITEM_SetWireImage(self)

    def SetSelected(self):
         """
         SetSelected(EDA_ITEM self)

         void
         EDA_ITEM::SetSelected()
         """
         return _pcbnew.EDA_ITEM_SetSelected(self)

    def SetHighlighted(self):
         """
         SetHighlighted(EDA_ITEM self)

         void
         EDA_ITEM::SetHighlighted()
         """
         return _pcbnew.EDA_ITEM_SetHighlighted(self)

    def SetBrightened(self):
         """
         SetBrightened(EDA_ITEM self)

         void
         EDA_ITEM::SetBrightened()
         """
         return _pcbnew.EDA_ITEM_SetBrightened(self)

    def ClearSelected(self):
         """
         ClearSelected(EDA_ITEM self)

         void
         EDA_ITEM::ClearSelected()
         """
         return _pcbnew.EDA_ITEM_ClearSelected(self)

    def ClearHighlighted(self):
         """
         ClearHighlighted(EDA_ITEM self)

         void
         EDA_ITEM::ClearHighlighted()
         """
         return _pcbnew.EDA_ITEM_ClearHighlighted(self)

    def ClearBrightened(self):
         """
         ClearBrightened(EDA_ITEM self)

         void
         EDA_ITEM::ClearBrightened()
         """
         return _pcbnew.EDA_ITEM_ClearBrightened(self)

    def SetModified(self):
         """
         SetModified(EDA_ITEM self)

         void
         EDA_ITEM::SetModified()
         """
         return _pcbnew.EDA_ITEM_SetModified(self)

    def GetState(self, *args):
         """
         GetState(EDA_ITEM self, int type) -> int

         int EDA_ITEM::GetState(int
         type) const
         """
         return _pcbnew.EDA_ITEM_GetState(self, *args)

    def SetState(self, *args):
         """
         SetState(EDA_ITEM self, int type, int state)

         void
         EDA_ITEM::SetState(int type, int state)
         """
         return _pcbnew.EDA_ITEM_SetState(self, *args)

    def GetStatus(self):
         """
         GetStatus(EDA_ITEM self) -> STATUS_FLAGS

         STATUS_FLAGS
         EDA_ITEM::GetStatus() const
         """
         return _pcbnew.EDA_ITEM_GetStatus(self)

    def SetStatus(self, *args):
         """
         SetStatus(EDA_ITEM self, STATUS_FLAGS aStatus)

         void
         EDA_ITEM::SetStatus(STATUS_FLAGS aStatus)
         """
         return _pcbnew.EDA_ITEM_SetStatus(self, *args)

    def SetFlags(self, *args):
         """
         SetFlags(EDA_ITEM self, STATUS_FLAGS aMask)

         void
         EDA_ITEM::SetFlags(STATUS_FLAGS aMask)
         """
         return _pcbnew.EDA_ITEM_SetFlags(self, *args)

    def ClearFlags(self, *args):
         """
         ClearFlags(EDA_ITEM self, STATUS_FLAGS aMask=-1)
         ClearFlags(EDA_ITEM self)

         void
         EDA_ITEM::ClearFlags(STATUS_FLAGS aMask=EDA_ITEM_ALL_FLAGS)
         """
         return _pcbnew.EDA_ITEM_ClearFlags(self, *args)

    def GetFlags(self):
         """
         GetFlags(EDA_ITEM self) -> STATUS_FLAGS

         STATUS_FLAGS
         EDA_ITEM::GetFlags() const
         """
         return _pcbnew.EDA_ITEM_GetFlags(self)

    def SetImage(self, *args):
         """
         SetImage(EDA_ITEM self, EDA_ITEM aItem)

         void
         EDA_ITEM::SetImage(EDA_ITEM *aItem)
         """
         return _pcbnew.EDA_ITEM_SetImage(self, *args)

    def SetForceVisible(self, *args):
         """
         SetForceVisible(EDA_ITEM self, bool aEnable)

         void
         EDA_ITEM::SetForceVisible(bool aEnable)

         Function SetForceVisible is used to set and cleag force visible flag
         used to force the item to be drawn even if it's draw attribute is set
         to not visible.

         Parameters:
         -----------

         aEnable:  True forces the item to be drawn. False uses the item's
         visibility setting to determine if the item is to be drawn.
         """
         return _pcbnew.EDA_ITEM_SetForceVisible(self, *args)

    def GetMsgPanelInfo(self, *args):
         """
         GetMsgPanelInfo(EDA_ITEM self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

         virtual void
         EDA_ITEM::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

         Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
         with it's internal state for display purposes.

         This method replaces DisplayInfo() so that KiCad objects no longer
         have any knowledge of wxWidgets UI objects.

         Parameters:
         -----------

         aList:  is the list to populate.
         """
         return _pcbnew.EDA_ITEM_GetMsgPanelInfo(self, *args)

    def HitTest(self, *args):
         """
         HitTest(EDA_ITEM self, wxPoint aPosition) -> bool

         virtual bool
         EDA_ITEM::HitTest(const wxPoint &aPosition) const

         Function HitTest tests if aPosition is contained within or on the
         bounding area of an item.

         Parameters:
         -----------

         aPosition:  A reference to a wxPoint object containing the coordinates
         to test.

         True if aPosition is within or on the item bounding area.
         """
         return _pcbnew.EDA_ITEM_HitTest(self, *args)

    def GetBoundingBox(self):
         """
         GetBoundingBox(EDA_ITEM self) -> EDA_RECT

         virtual const
         EDA_RECT EDA_ITEM::GetBoundingBox() const

         Function GetBoundingBox returns the orthogonal, bounding box of this
         object for display purposes.

         This box should be an enclosing perimeter for visible components of
         this object, and the units should be in the pcb or schematic
         coordinate system. It is OK to overestimate the size by a few counts.

         """
         return _pcbnew.EDA_ITEM_GetBoundingBox(self)

    def Clone(self):
         """
         Clone(EDA_ITEM self) -> EDA_ITEM

         EDA_ITEM * EDA_ITEM::Clone()
         const

         Function Clone creates a duplicate of this item with linked list
         members set to NULL.

        The default version will return NULL in release builds and likely
         crash the program. In debug builds, a warning message indicating the
         derived class has not implemented cloning. This really should be a
         pure virtual function. Due to the fact that there are so many objects
         derived from EDA_ITEM, the decision was made to return NULL until all
         the objects derived from EDA_ITEM implement cloning. Once that
         happens, this function should be made pure.

         A clone of the item.
         """
         return _pcbnew.EDA_ITEM_Clone(self)

    def IterateForward(*args):
         """IterateForward(EDA_ITEM listStart, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT"""
         return _pcbnew.EDA_ITEM_IterateForward(*args)

     if _newclass:IterateForward = staticmethod(IterateForward)
     __swig_getmethods__["IterateForward"] = lambda x: IterateForward
    def Visit(self, *args):
         """
         Visit(EDA_ITEM self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

         SEARCH_RESULT
         EDA_ITEM::Visit(INSPECTOR *inspector, const void *testData, const
         KICAD_T scanTypes[])

         Function Visit may be re-implemented for each derived class in order
         to handle all the types given by its member data.

         Implementations should call inspector->Inspect() on types in
         scanTypes[], and may use IterateForward() to do so on lists of such
         data.

         Parameters:
         -----------

         inspector:  An INSPECTOR instance to use in the inspection.

         testData:  Arbitrary data used by the inspector.

         scanTypes:  Which KICAD_T types are of interest and the order is
         significant too, terminated by EOT.

         SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
         SCAN_CONTINUE, and determined by the inspector.
         """
         return _pcbnew.EDA_ITEM_Visit(self, *args)

    def GetClass(self):
         """
         GetClass(EDA_ITEM self) -> wxString

         virtual wxString
         EDA_ITEM::GetClass() const

         Function GetClass returns the class name.

         wxString
         """
         return _pcbnew.EDA_ITEM_GetClass(self)

    def GetSelectMenuText(self):
         """
         GetSelectMenuText(EDA_ITEM self) -> wxString

         wxString
         EDA_ITEM::GetSelectMenuText() const

         Function GetSelectMenuText returns the text to display to be used in
         the selection clarification context menu when multiple items are found
         at the current cursor position.

        The default version of this function raises an assertion in the debug
         mode and returns a string to indicate that it was not overridden to
         provide the object specific text.

         The menu text string.
         """
         return _pcbnew.EDA_ITEM_GetSelectMenuText(self)

    def GetMenuImage(self):
         """
         GetMenuImage(EDA_ITEM self) -> BITMAP_DEF

         virtual BITMAP_DEF
        EDA_ITEM::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.EDA_ITEM_GetMenuImage(self)

   def Matches(self, *args):
        """
        Matches(EDA_ITEM self, wxFindReplaceData & aSearchData, void * aAuxData, wxPoint aFindLocation) -> bool
        Matches(EDA_ITEM self, wxString const & aText, wxFindReplaceData & aSearchData) -> bool

        bool
        EDA_ITEM::Matches(const wxString &aText, wxFindReplaceData
        &aSearchData)

        Function Matches compares aText against search criteria in
        aSearchData.

        Parameters:
        -----------

        aText:  A reference to a wxString object containing the string to
        test.

        aSearchData:  The criteria to search against.

        True if aText matches the search criteria in aSearchData.
        """
        return _pcbnew.EDA_ITEM_Matches(self, *args)

   def Replace(self, *args):
        """
        Replace(EDA_ITEM self, wxFindReplaceData & aSearchData, wxString & aText) -> bool
        Replace(EDA_ITEM self, wxFindReplaceData & aSearchData, void * aAuxData=None) -> bool
        Replace(EDA_ITEM self, wxFindReplaceData & aSearchData) -> bool

        virtual bool
        EDA_ITEM::Replace(wxFindReplaceData &aSearchData, void *aAuxData=NULL)

        Function Replace performs a text replace using the find and replace
        criteria in aSearchData on items that support text find and replace.

        This function must be overridden for items that support text replace.

        Parameters:
        -----------

        aSearchData:  A reference to a wxFindReplaceData object containing the
        search and replace criteria.

        aAuxData:  A pointer to optional data required for the search or NULL
        if not used.

        True if the item text was modified, otherwise false.
        """
        return _pcbnew.EDA_ITEM_Replace(self, *args)

   def IsReplaceable(self):
        """
        IsReplaceable(EDA_ITEM self) -> bool

        virtual bool
        EDA_ITEM::IsReplaceable() const

        Function IsReplaceable.

        Override this method in any derived object that supports test find and
        replace.

        True if the item has replaceable text that can be modified using the
        find and replace dialog.
        """
        return _pcbnew.EDA_ITEM_IsReplaceable(self)

   def __lt__(self, *args):
        """__lt__(EDA_ITEM self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.EDA_ITEM___lt__(self, *args)

   def Sort(*args):
        """Sort(EDA_ITEM aLeft, EDA_ITEM aRight) -> bool"""
        return _pcbnew.EDA_ITEM_Sort(*args)

    if _newclass:Sort = staticmethod(Sort)
    __swig_getmethods__["Sort"] = lambda x: Sort
   def ViewBBox(self):
        """
        ViewBBox(EDA_ITEM self) -> BOX2I const

        const BOX2I
        EDA_ITEM::ViewBBox() const
        """
        return _pcbnew.EDA_ITEM_ViewBBox(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(EDA_ITEM self, int [] aLayers, int & aCount)

        void
        EDA_ITEM::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.EDA_ITEM_ViewGetLayers(self, *args)

EDA_ITEM_swigregister = _pcbnew.EDA_ITEM_swigregister
EDA_ITEM_swigregister(EDA_ITEM)

def EDA_ITEM_IterateForward(*args):
  """EDA_ITEM_IterateForward(EDA_ITEM listStart, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT"""
  return _pcbnew.EDA_ITEM_IterateForward(*args)

def EDA_ITEM_Sort(*args):
  """EDA_ITEM_Sort(EDA_ITEM aLeft, EDA_ITEM aRight) -> bool"""
  return _pcbnew.EDA_ITEM_Sort(*args)


def new_clone(*args):
  """new_clone(EDA_ITEM aItem) -> EDA_ITEM"""
  return _pcbnew.new_clone(*args)
class EDA_RECT(_object):
    """
    Class EDA_RECT handles the component boundary box.

    This class is similar to wxRect, but some wxRect functions are very
    curious, and are working only if dimensions are >= 0 (not always the
    case in KiCad) and also KiCad needs some specific method. so I prefer
    this more suitable class

    C++ includes: class_eda_rect.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EDA_RECT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EDA_RECT, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(EDA_RECT self) -> EDA_RECT
        __init__(EDA_RECT self, wxPoint aPos, wxSize aSize) -> EDA_RECT

        EDA_RECT::EDA_RECT(const
        wxPoint &aPos, const wxSize &aSize)
        """
        this = _pcbnew.new_EDA_RECT(*args)
        try: self.this.append(this)
        except: self.this = this
   def Centre(self):
        """
        Centre(EDA_RECT self) -> wxPoint

        wxPoint EDA_RECT::Centre()
        const
        """
        return _pcbnew.EDA_RECT_Centre(self)

   def Move(self, *args):
        """
        Move(EDA_RECT self, wxPoint aMoveVector)

        void EDA_RECT::Move(const
        wxPoint &aMoveVector)

        Function Move moves the rectangle by the aMoveVector.

        Parameters:
        -----------

        aMoveVector:  A wxPoint that is the value to move this rectangle
        """
        return _pcbnew.EDA_RECT_Move(self, *args)

   def Normalize(self):
        """
        Normalize(EDA_RECT self)

        void
        EDA_RECT::Normalize()

        Function Normalize ensures that the height ant width are positive.
        """
        return _pcbnew.EDA_RECT_Normalize(self)

   def Contains(self, *args):
        """
        Contains(EDA_RECT self, wxPoint aPoint) -> bool
        Contains(EDA_RECT self, int x, int y) -> bool
        Contains(EDA_RECT self, EDA_RECT aRect) -> bool

        bool
        EDA_RECT::Contains(const EDA_RECT &aRect) const

        Function Contains.

        Parameters:
        -----------

        aRect:  = the EDA_RECT to test

        true if aRect is Contained. A common edge is seen as contained
        """
        return _pcbnew.EDA_RECT_Contains(self, *args)

   def GetSize(self):
        """
        GetSize(EDA_RECT self) -> wxSize

        const wxSize&
        EDA_RECT::GetSize() const
        """
        return _pcbnew.EDA_RECT_GetSize(self)

   def GetX(self):
        """
        GetX(EDA_RECT self) -> int

        int EDA_RECT::GetX() const
        """
        return _pcbnew.EDA_RECT_GetX(self)

   def GetY(self):
        """
        GetY(EDA_RECT self) -> int

        int EDA_RECT::GetY() const
        """
        return _pcbnew.EDA_RECT_GetY(self)

   def GetOrigin(self):
        """
        GetOrigin(EDA_RECT self) -> wxPoint

        const wxPoint&
        EDA_RECT::GetOrigin() const
        """
        return _pcbnew.EDA_RECT_GetOrigin(self)

   def GetPosition(self):
        """
        GetPosition(EDA_RECT self) -> wxPoint

        const wxPoint&
        EDA_RECT::GetPosition() const
        """
        return _pcbnew.EDA_RECT_GetPosition(self)

   def GetEnd(self):
        """
        GetEnd(EDA_RECT self) -> wxPoint

        const wxPoint
        EDA_RECT::GetEnd() const
        """
        return _pcbnew.EDA_RECT_GetEnd(self)

   def GetWidth(self):
        """
        GetWidth(EDA_RECT self) -> int

        int EDA_RECT::GetWidth()
        const
        """
        return _pcbnew.EDA_RECT_GetWidth(self)

   def GetHeight(self):
        """
        GetHeight(EDA_RECT self) -> int

        int EDA_RECT::GetHeight()
        const
        """
        return _pcbnew.EDA_RECT_GetHeight(self)

   def GetRight(self):
        """
        GetRight(EDA_RECT self) -> int

        int EDA_RECT::GetRight()
        const
        """
        return _pcbnew.EDA_RECT_GetRight(self)

   def GetLeft(self):
        """
        GetLeft(EDA_RECT self) -> int

        int EDA_RECT::GetLeft()
        const
        """
        return _pcbnew.EDA_RECT_GetLeft(self)

   def GetBottom(self):
        """
        GetBottom(EDA_RECT self) -> int

        int EDA_RECT::GetBottom()
        const
        """
        return _pcbnew.EDA_RECT_GetBottom(self)

   def SetOrigin(self, *args):
        """
        SetOrigin(EDA_RECT self, wxPoint pos)
        SetOrigin(EDA_RECT self, int x, int y)

        void
        EDA_RECT::SetOrigin(int x, int y)
        """
        return _pcbnew.EDA_RECT_SetOrigin(self, *args)

   def SetSize(self, *args):
        """
        SetSize(EDA_RECT self, wxSize size)
        SetSize(EDA_RECT self, int w, int h)

        void EDA_RECT::SetSize(int
        w, int h)
        """
        return _pcbnew.EDA_RECT_SetSize(self, *args)

   def Offset(self, *args):
        """
        Offset(EDA_RECT self, int dx, int dy)
        Offset(EDA_RECT self, wxPoint offset)

        void EDA_RECT::Offset(const
        wxPoint &offset)
        """
        return _pcbnew.EDA_RECT_Offset(self, *args)

   def SetX(self, *args):
        """
        SetX(EDA_RECT self, int val)

        void EDA_RECT::SetX(int val)

        """
        return _pcbnew.EDA_RECT_SetX(self, *args)

   def SetY(self, *args):
        """
        SetY(EDA_RECT self, int val)

        void EDA_RECT::SetY(int val)

        """
        return _pcbnew.EDA_RECT_SetY(self, *args)

   def SetWidth(self, *args):
        """
        SetWidth(EDA_RECT self, int val)

        void
        EDA_RECT::SetWidth(int val)
        """
        return _pcbnew.EDA_RECT_SetWidth(self, *args)

   def SetHeight(self, *args):
        """
        SetHeight(EDA_RECT self, int val)

        void
        EDA_RECT::SetHeight(int val)
        """
        return _pcbnew.EDA_RECT_SetHeight(self, *args)

   def SetEnd(self, *args):
        """
        SetEnd(EDA_RECT self, int x, int y)
        SetEnd(EDA_RECT self, wxPoint pos)

        void EDA_RECT::SetEnd(const
        wxPoint &pos)
        """
        return _pcbnew.EDA_RECT_SetEnd(self, *args)

   def Intersects(self, *args):
        """
        Intersects(EDA_RECT self, EDA_RECT aRect) -> bool
        Intersects(EDA_RECT self, wxPoint aPoint1, wxPoint aPoint2) -> bool

        bool
        EDA_RECT::Intersects(const wxPoint &aPoint1, const wxPoint &aPoint2)
        const

        Function Intersects tests for a common area between a segment and this
        rectangle.

        Parameters:
        -----------

        aPoint1:  First point of the segment to test intersection with.

        aPoint2:  Second point of the segment to test intersection with.

        bool - true if the argument segment intersects this rectangle. (i.e.
        if the segment and rectangle have at least a common point)
        """
        return _pcbnew.EDA_RECT_Intersects(self, *args)

   def getWxRect(self):
        """getWxRect(EDA_RECT self) -> wxRect"""
        return _pcbnew.EDA_RECT_getWxRect(self)

   def Inflate(self, *args):
        """
        Inflate(EDA_RECT self, wxCoord dx, wxCoord dy) -> EDA_RECT
        Inflate(EDA_RECT self, int aDelta) -> EDA_RECT

        EDA_RECT &
        EDA_RECT::Inflate(int aDelta)

        Function Inflate inflates the rectangle horizontally and vertically by
        aDelta.

       If aDelta is negative the rectangle is deflated.
        """
        return _pcbnew.EDA_RECT_Inflate(self, *args)

   def Merge(self, *args):
        """
        Merge(EDA_RECT self, EDA_RECT aRect)
        Merge(EDA_RECT self, wxPoint aPoint)

        void EDA_RECT::Merge(const
        wxPoint &aPoint)

        Function Merge modifies the position and size of the rectangle in
        order to contain the given point.

        Parameters:
        -----------

        aPoint:  The point to merge with the rectangle.
        """
        return _pcbnew.EDA_RECT_Merge(self, *args)

   def GetArea(self):
        """
        GetArea(EDA_RECT self) -> double

        double EDA_RECT::GetArea()
        const

        Function GetArea returns the area of the rectangle.

        The area of the rectangle.
        """
        return _pcbnew.EDA_RECT_GetArea(self)

   def GetBoundingBoxRotated(self, *args):
        """
        GetBoundingBoxRotated(EDA_RECT self, wxPoint aRotCenter, double aAngle) -> EDA_RECT

        const
        EDA_RECT EDA_RECT::GetBoundingBoxRotated(wxPoint aRotCenter, double
        aAngle)

        Function GetBoundingBoxRotated.

        the bounding box of this, after rotation

        Parameters:
        -----------

        aAngle:  = the rotation angle in 0.1 deg.

        aRotCenter:  = the rotation point. useful to calculate bounding box of
        rotated items, when rotation if not k*90 degrees
        """
        return _pcbnew.EDA_RECT_GetBoundingBoxRotated(self, *args)

    __swig_destroy__ = _pcbnew.delete_EDA_RECT
    __del__ = lambda self : None;
EDA_RECT_swigregister = _pcbnew.EDA_RECT_swigregister
EDA_RECT_swigregister(EDA_RECT)

GR_KB_RIGHTSHIFT = _pcbnew.GR_KB_RIGHTSHIFT
GR_KB_LEFTSHIFT = _pcbnew.GR_KB_LEFTSHIFT
GR_KB_CTRL = _pcbnew.GR_KB_CTRL
GR_KB_ALT = _pcbnew.GR_KB_ALT
GR_KB_SHIFT = _pcbnew.GR_KB_SHIFT
GR_KB_SHIFTCTRL = _pcbnew.GR_KB_SHIFTCTRL
MOUSE_MIDDLE = _pcbnew.MOUSE_MIDDLE
EDA_PANNING_UP_KEY = _pcbnew.EDA_PANNING_UP_KEY
EDA_PANNING_DOWN_KEY = _pcbnew.EDA_PANNING_DOWN_KEY
EDA_PANNING_LEFT_KEY = _pcbnew.EDA_PANNING_LEFT_KEY
EDA_PANNING_RIGHT_KEY = _pcbnew.EDA_PANNING_RIGHT_KEY
EDA_ZOOM_IN_FROM_MOUSE = _pcbnew.EDA_ZOOM_IN_FROM_MOUSE
EDA_ZOOM_OUT_FROM_MOUSE = _pcbnew.EDA_ZOOM_OUT_FROM_MOUSE
EDA_ZOOM_CENTER_FROM_MOUSE = _pcbnew.EDA_ZOOM_CENTER_FROM_MOUSE
ESC = _pcbnew.ESC
TEXT_ORIENT_HORIZ = _pcbnew.TEXT_ORIENT_HORIZ
TEXT_ORIENT_VERT = _pcbnew.TEXT_ORIENT_VERT

def KiROUND(*args):
  """KiROUND(double v) -> int"""
  return _pcbnew.KiROUND(*args)

def Mm2mils(*args):
  """Mm2mils(double x) -> int"""
  return _pcbnew.Mm2mils(*args)

def Mils2mm(*args):
  """Mils2mm(double x) -> int"""
  return _pcbnew.Mils2mm(*args)
INCHES = _pcbnew.INCHES
MILLIMETRES = _pcbnew.MILLIMETRES
UNSCALED_UNITS = _pcbnew.UNSCALED_UNITS

def SetLocaleTo_C_standard():
  """SetLocaleTo_C_standard()"""
  return _pcbnew.SetLocaleTo_C_standard()

def SetLocaleTo_Default():
  """SetLocaleTo_Default()"""
  return _pcbnew.SetLocaleTo_Default()
class LOCALE_IO(_object):
    """
    Class LOCALE_IO is a class that can be instantiated within a scope in
    which you are expecting exceptions to be thrown.

    Its constructor calls SetLocaleTo_C_Standard(). Its destructor insures
   that the default locale is restored if an exception is thrown, or not.

    C++ includes: common.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LOCALE_IO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LOCALE_IO, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(LOCALE_IO self) -> LOCALE_IO

        LOCALE_IO::LOCALE_IO()

        """
        this = _pcbnew.new_LOCALE_IO()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_LOCALE_IO
    __del__ = lambda self : None;
LOCALE_IO_swigregister = _pcbnew.LOCALE_IO_swigregister
LOCALE_IO_swigregister(LOCALE_IO)


def GetTextSize(*args):
  """GetTextSize(wxString const & aSingleLine, wxWindow * aWindow) -> wxSize"""
  return _pcbnew.GetTextSize(*args)

def EnsureTextCtrlWidth(*args):
  """
    EnsureTextCtrlWidth(wxTextCtrl * aCtrl, wxString const * aString=None) -> bool
    EnsureTextCtrlWidth(wxTextCtrl * aCtrl) -> bool
    """
  return _pcbnew.EnsureTextCtrlWidth(*args)

def ProcessExecute(*args):
  """
    ProcessExecute(wxString const & aCommandLine, int aFlags=wxEXEC_ASYNC, wxProcess * callback=None) -> int
    ProcessExecute(wxString const & aCommandLine, int aFlags=wxEXEC_ASYNC) -> int
    ProcessExecute(wxString const & aCommandLine) -> int
    """
  return _pcbnew.ProcessExecute(*args)

def GetNewTimeStamp():
  """GetNewTimeStamp() -> time_t"""
  return _pcbnew.GetNewTimeStamp()

def DisplayColorFrame(*args):
  """DisplayColorFrame(wxWindow * parent, int OldColor) -> EDA_COLOR_T"""
  return _pcbnew.DisplayColorFrame(*args)

def ReturnUnitSymbol(*args):
  """
    ReturnUnitSymbol(EDA_UNITS_T aUnits=g_UserUnit, wxString const & aFormatString=_( " (%s):" )) -> wxString
    ReturnUnitSymbol(EDA_UNITS_T aUnits=g_UserUnit) -> wxString
    ReturnUnitSymbol() -> wxString
    """
  return _pcbnew.ReturnUnitSymbol(*args)

def GetUnitsLabel(*args):
  """GetUnitsLabel(EDA_UNITS_T aUnits) -> wxString"""
  return _pcbnew.GetUnitsLabel(*args)

def GetAbbreviatedUnitsLabel(*args):
  """
    GetAbbreviatedUnitsLabel(EDA_UNITS_T aUnit=g_UserUnit) -> wxString
    GetAbbreviatedUnitsLabel() -> wxString
    """
  return _pcbnew.GetAbbreviatedUnitsLabel(*args)

def AddUnitSymbol(*args):
  """
    AddUnitSymbol(wxStaticText & Stext, EDA_UNITS_T aUnit=g_UserUnit)
    AddUnitSymbol(wxStaticText & Stext)
    """
  return _pcbnew.AddUnitSymbol(*args)

def RoundTo0(*args):
  """RoundTo0(double x, double precision) -> double"""
  return _pcbnew.RoundTo0(*args)

def wxStringSplit(*args):
  """wxStringSplit(wxString aString, wxChar aSplitter) -> wxArrayString *"""
  return _pcbnew.wxStringSplit(*args)

def GetRunningMicroSecs():
  """GetRunningMicroSecs() -> unsigned int"""
  return _pcbnew.GetRunningMicroSecs()

def FormatDateLong(*args):
  """FormatDateLong(wxDateTime const & aDate) -> wxString"""
  return _pcbnew.FormatDateLong(*args)

def SystemDirsAppend(*args):
  """SystemDirsAppend(SEARCH_STACK * aSearchStack)"""
  return _pcbnew.SystemDirsAppend(*args)

def SearchHelpFileFullPath(*args):
  """SearchHelpFileFullPath(SEARCH_STACK const & aSearchStack, wxString const & aBaseName) -> wxString"""
  return _pcbnew.SearchHelpFileFullPath(*args)

def EnsureFileDirectoryExists(*args):
  """
    EnsureFileDirectoryExists(wxFileName * aTargetFullFileName, wxString const & aBaseFilename, REPORTER * aReporter=None) -> bool
    EnsureFileDirectoryExists(wxFileName * aTargetFullFileName, wxString const & aBaseFilename) -> bool
    """
  return _pcbnew.EnsureFileDirectoryExists(*args)

def LockFile(*args):
  """LockFile(wxString const & aFileName) -> wxSingleInstanceChecker *"""
  return _pcbnew.LockFile(*args)

def PrePendPath(*args):
  """PrePendPath(wxString const & aEnvVar, wxString const & aPriorityPath) -> wxString const"""
  return _pcbnew.PrePendPath(*args)

def GetNewConfig(*args):
  """GetNewConfig(wxString const & aProgName) -> wxConfigBase *"""
  return _pcbnew.GetNewConfig(*args)

def GetKicadConfigPath():
  """GetKicadConfigPath() -> wxString"""
  return _pcbnew.GetKicadConfigPath()

def ExpandEnvVarSubstitutions(*args):
  """ExpandEnvVarSubstitutions(wxString const & aString) -> wxString const"""
  return _pcbnew.ExpandEnvVarSubstitutions(*args)
class TITLE_BLOCK(_object):
    """
    Class TITLE_BLOCK holds the information shown in the lower right
    corner of a plot, printout, or editing view.

    Dick Hollenbeck

    C++ includes: class_title_block.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TITLE_BLOCK, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TITLE_BLOCK, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(TITLE_BLOCK self) -> TITLE_BLOCK

        TITLE_BLOCK::TITLE_BLOCK()
        """
        this = _pcbnew.new_TITLE_BLOCK()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_TITLE_BLOCK
    __del__ = lambda self : None;
   def SetTitle(self, *args):
        """
        SetTitle(TITLE_BLOCK self, wxString const & aTitle)

        void
        TITLE_BLOCK::SetTitle(const wxString &aTitle)
        """
        return _pcbnew.TITLE_BLOCK_SetTitle(self, *args)

   def GetTitle(self):
        """
        GetTitle(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetTitle() const
        """
        return _pcbnew.TITLE_BLOCK_GetTitle(self)

   def SetDate(self, *args):
        """
        SetDate(TITLE_BLOCK self, wxString const & aDate)

        void
        TITLE_BLOCK::SetDate(const wxString &aDate)

       Function SetDate sets the date field, and defaults to the current time
        and date.
        """
        return _pcbnew.TITLE_BLOCK_SetDate(self, *args)

   def GetDate(self):
        """
        GetDate(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetDate() const
        """
        return _pcbnew.TITLE_BLOCK_GetDate(self)

   def SetRevision(self, *args):
        """
        SetRevision(TITLE_BLOCK self, wxString const & aRevision)

        void
        TITLE_BLOCK::SetRevision(const wxString &aRevision)
        """
        return _pcbnew.TITLE_BLOCK_SetRevision(self, *args)

   def GetRevision(self):
        """
        GetRevision(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetRevision() const
        """
        return _pcbnew.TITLE_BLOCK_GetRevision(self)

   def SetCompany(self, *args):
        """
        SetCompany(TITLE_BLOCK self, wxString const & aCompany)

        void
        TITLE_BLOCK::SetCompany(const wxString &aCompany)
        """
        return _pcbnew.TITLE_BLOCK_SetCompany(self, *args)

   def GetCompany(self):
        """
        GetCompany(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetCompany() const
        """
        return _pcbnew.TITLE_BLOCK_GetCompany(self)

   def SetComment(self, *args):
        """
        SetComment(TITLE_BLOCK self, int aIdx, wxString const & aComment)

        void
        TITLE_BLOCK::SetComment(int aIdx, const wxString &aComment)
        """
        return _pcbnew.TITLE_BLOCK_SetComment(self, *args)

   def GetComment(self, *args):
        """
        GetComment(TITLE_BLOCK self, int aIdx) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetComment(int aIdx) const
        """
        return _pcbnew.TITLE_BLOCK_GetComment(self, *args)

   def SetComment1(self, *args):
        """
        SetComment1(TITLE_BLOCK self, wxString const & aComment)

        void
        TITLE_BLOCK::SetComment1(const wxString &aComment)
        """
        return _pcbnew.TITLE_BLOCK_SetComment1(self, *args)

   def SetComment2(self, *args):
        """
        SetComment2(TITLE_BLOCK self, wxString const & aComment)

        void
        TITLE_BLOCK::SetComment2(const wxString &aComment)
        """
        return _pcbnew.TITLE_BLOCK_SetComment2(self, *args)

   def SetComment3(self, *args):
        """
        SetComment3(TITLE_BLOCK self, wxString const & aComment)

        void
        TITLE_BLOCK::SetComment3(const wxString &aComment)
        """
        return _pcbnew.TITLE_BLOCK_SetComment3(self, *args)

   def SetComment4(self, *args):
        """
        SetComment4(TITLE_BLOCK self, wxString const & aComment)

        void
        TITLE_BLOCK::SetComment4(const wxString &aComment)
        """
        return _pcbnew.TITLE_BLOCK_SetComment4(self, *args)

   def GetComment1(self):
        """
        GetComment1(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetComment1() const
        """
        return _pcbnew.TITLE_BLOCK_GetComment1(self)

   def GetComment2(self):
        """
        GetComment2(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetComment2() const
        """
        return _pcbnew.TITLE_BLOCK_GetComment2(self)

   def GetComment3(self):
        """
        GetComment3(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetComment3() const
        """
        return _pcbnew.TITLE_BLOCK_GetComment3(self)

   def GetComment4(self):
        """
        GetComment4(TITLE_BLOCK self) -> wxString const &

        const wxString&
        TITLE_BLOCK::GetComment4() const
        """
        return _pcbnew.TITLE_BLOCK_GetComment4(self)

   def Clear(self):
        """
        Clear(TITLE_BLOCK self)

        void TITLE_BLOCK::Clear()

        """
        return _pcbnew.TITLE_BLOCK_Clear(self)

   def Format(self, *args):
        """
        Format(TITLE_BLOCK self, OUTPUTFORMATTER * aFormatter, int aNestLevel, int aControlBits)

        void
        TITLE_BLOCK::Format(OUTPUTFORMATTER *aFormatter, int aNestLevel, int
        aControlBits) const  throw ( IO_ERROR ) Function Format outputs the
        object to aFormatter in s-expression form.

        Parameters:
        -----------

        aFormatter:  The OUTPUTFORMATTER object to write to.

        aNestLevel:  The indentation next level.

       aControlBits:  The control bit definition for object specific
        formatting.

        Parameters:
        -----------

        ???:  on write error.
        """
        return _pcbnew.TITLE_BLOCK_Format(self, *args)

TITLE_BLOCK_swigregister = _pcbnew.TITLE_BLOCK_swigregister
TITLE_BLOCK_swigregister(TITLE_BLOCK)

class COLORS_DESIGN_SETTINGS(_object):
    """
    Class COLORS_DESIGN_SETTINGS is a list of color settings for designs
    in Eeschema, Pcbnew and GerbView.

    C++ includes: class_colors_design_settings.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, COLORS_DESIGN_SETTINGS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, COLORS_DESIGN_SETTINGS, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_LayersColors"] = _pcbnew.COLORS_DESIGN_SETTINGS_m_LayersColors_set
    __swig_getmethods__["m_LayersColors"] = _pcbnew.COLORS_DESIGN_SETTINGS_m_LayersColors_get
    if _newclass:m_LayersColors = _swig_property(_pcbnew.COLORS_DESIGN_SETTINGS_m_LayersColors_get, _pcbnew.COLORS_DESIGN_SETTINGS_m_LayersColors_set)
    __swig_setmethods__["m_ItemsColors"] = _pcbnew.COLORS_DESIGN_SETTINGS_m_ItemsColors_set
    __swig_getmethods__["m_ItemsColors"] = _pcbnew.COLORS_DESIGN_SETTINGS_m_ItemsColors_get
    if _newclass:m_ItemsColors = _swig_property(_pcbnew.COLORS_DESIGN_SETTINGS_m_ItemsColors_get, _pcbnew.COLORS_DESIGN_SETTINGS_m_ItemsColors_set)
   def __init__(self):
        """
        __init__(COLORS_DESIGN_SETTINGS self) -> COLORS_DESIGN_SETTINGS

        COLORS_DESIGN_SETTINGS::COLORS_DESIGN_SETTINGS()
        """
        this = _pcbnew.new_COLORS_DESIGN_SETTINGS()
        try: self.this.append(this)
        except: self.this = this
   def GetLayerColor(self, *args):
        """
        GetLayerColor(COLORS_DESIGN_SETTINGS self, LAYER_NUM aLayer) -> EDA_COLOR_T

        EDA_COLOR_T COLORS_DESIGN_SETTINGS::GetLayerColor(LAYER_NUM aLayer)
        const

        Function GetLayerColor.

        the color for aLayer which is one of the layer indices given in
        pcbstruct.h or in schematic
        """
        return _pcbnew.COLORS_DESIGN_SETTINGS_GetLayerColor(self, *args)

   def SetLayerColor(self, *args):
        """
        SetLayerColor(COLORS_DESIGN_SETTINGS self, LAYER_NUM aLayer, EDA_COLOR_T aColor)

        void
        COLORS_DESIGN_SETTINGS::SetLayerColor(LAYER_NUM aLayer, EDA_COLOR_T
        aColor)

        Function SetLayerColor sets the color for aLayer which is one of the
        layer indices given in pcbstruct.h or in schematic.
        """
        return _pcbnew.COLORS_DESIGN_SETTINGS_SetLayerColor(self, *args)

   def GetItemColor(self, *args):
        """
        GetItemColor(COLORS_DESIGN_SETTINGS self, int aItemIdx) -> EDA_COLOR_T

        EDA_COLOR_T COLORS_DESIGN_SETTINGS::GetItemColor(int aItemIdx) const

        Function GetItemColor.

        the color for an item which is one of the item indices given in
        pcbstruct.h, enum PCB_VISIBLE or in schematic
        """
        return _pcbnew.COLORS_DESIGN_SETTINGS_GetItemColor(self, *args)

   def SetItemColor(self, *args):
        """
        SetItemColor(COLORS_DESIGN_SETTINGS self, int aItemIdx, EDA_COLOR_T aColor)

        void
        COLORS_DESIGN_SETTINGS::SetItemColor(int aItemIdx, EDA_COLOR_T aColor)

        Function SetItemColor sets the color for an item which is one of the
        item indices given in pcbstruct.h, enum PCB_VISIBLE or in schematic.

        """
        return _pcbnew.COLORS_DESIGN_SETTINGS_SetItemColor(self, *args)

   def SetAllColorsAs(self, *args):
        """
        SetAllColorsAs(COLORS_DESIGN_SETTINGS self, EDA_COLOR_T aColor)

        void
        COLORS_DESIGN_SETTINGS::SetAllColorsAs(EDA_COLOR_T aColor)

        Function SetAllColorsAs sets alls colors to aColor Usefull to create a
        monochrome color selection for printing purpose.
        """
        return _pcbnew.COLORS_DESIGN_SETTINGS_SetAllColorsAs(self, *args)

    __swig_destroy__ = _pcbnew.delete_COLORS_DESIGN_SETTINGS
    __del__ = lambda self : None;
COLORS_DESIGN_SETTINGS_swigregister = _pcbnew.COLORS_DESIGN_SETTINGS_swigregister
COLORS_DESIGN_SETTINGS_swigregister(COLORS_DESIGN_SETTINGS)

class MARKER_BASE(_object):
    """
    C++ includes: class_marker_base.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MARKER_BASE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MARKER_BASE, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_Pos"] = _pcbnew.MARKER_BASE_m_Pos_set
    __swig_getmethods__["m_Pos"] = _pcbnew.MARKER_BASE_m_Pos_get
    if _newclass:m_Pos = _swig_property(_pcbnew.MARKER_BASE_m_Pos_get, _pcbnew.MARKER_BASE_m_Pos_set)
   def __init__(self, *args):
        """
        __init__(MARKER_BASE self) -> MARKER_BASE
        __init__(MARKER_BASE self, int aErrorCode, wxPoint aMarkerPos, wxString const & aText, wxPoint aPos, wxString const & bText,
            wxPoint bPos) -> MARKER_BASE
        __init__(MARKER_BASE self, int aErrorCode, wxPoint aMarkerPos, wxString const & aText, wxPoint aPos) -> MARKER_BASE
        __init__(MARKER_BASE self, MARKER_BASE aMarker) -> MARKER_BASE

        MARKER_BASE::MARKER_BASE(const MARKER_BASE &aMarker)

        Contructor makes a copy of aMarker but does not copy the DRC_ITEM.

        Parameters:
        -----------

        aMarker:  The marker to copy.
        """
        this = _pcbnew.new_MARKER_BASE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_MARKER_BASE
    __del__ = lambda self : None;
   def DrawMarker(self, *args):
        """
        DrawMarker(MARKER_BASE self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset)

        void
        MARKER_BASE::DrawMarker(EDA_DRAW_PANEL *aPanel, wxDC *aDC, GR_DRAWMODE
        aDrawMode, const wxPoint &aOffset)

       Function DrawMarker draws the shape is the polygon defined in
        m_Corners (array of wxPoints).
        """
        return _pcbnew.MARKER_BASE_DrawMarker(self, *args)

   def GetPos(self):
        """
        GetPos(MARKER_BASE self) -> wxPoint

        const wxPoint&
        MARKER_BASE::GetPos() const

        Function GetPos returns the position of this MARKER, const.
        """
        return _pcbnew.MARKER_BASE_GetPos(self)

   def SetColor(self, *args):
        """
        SetColor(MARKER_BASE self, EDA_COLOR_T aColor)

        void
        MARKER_BASE::SetColor(EDA_COLOR_T aColor)

        Function SetColor Set the color of this marker.
        """
        return _pcbnew.MARKER_BASE_SetColor(self, *args)

   def SetErrorLevel(self, *args):
        """
        SetErrorLevel(MARKER_BASE self, int aErrorLevel)

        void
        MARKER_BASE::SetErrorLevel(int aErrorLevel)

        Function to set/get error levels (warning, fatal ..) this value is
        stored in m_MarkerType.
        """
        return _pcbnew.MARKER_BASE_SetErrorLevel(self, *args)

   def GetErrorLevel(self):
        """
        GetErrorLevel(MARKER_BASE self) -> int

        int
        MARKER_BASE::GetErrorLevel() const
        """
        return _pcbnew.MARKER_BASE_GetErrorLevel(self)

   def SetMarkerType(self, *args):
        """
        SetMarkerType(MARKER_BASE self, int aMarkerType)

        void
        MARKER_BASE::SetMarkerType(int aMarkerType)

        Functions to set/get marker type ( DRC, ERC, or other) this value is
        stored in m_MarkerType.
        """
        return _pcbnew.MARKER_BASE_SetMarkerType(self, *args)

   def GetMarkerType(self):
        """
        GetMarkerType(MARKER_BASE self) -> int

        int
        MARKER_BASE::GetMarkerType() const
        """
        return _pcbnew.MARKER_BASE_GetMarkerType(self)

   def SetData(self, *args):
        """
        SetData(MARKER_BASE self, int aErrorCode, wxPoint aMarkerPos, wxString const & aText, wxPoint aPos, wxString const & bText,
            wxPoint bPos)
        SetData(MARKER_BASE self, int aErrorCode, wxPoint aMarkerPos, wxString const & aText, wxPoint aPos)

        void
        MARKER_BASE::SetData(int aErrorCode, const wxPoint &aMarkerPos, const
        wxString &aText, const wxPoint &aPos)

        Function SetData fills in all the reportable data associated with a
        MARKER.

        Parameters:
        -----------

        aErrorCode:  The categorizing identifier for an error

        aMarkerPos:  The position of the MARKER on the BOARD

        aText:  Text describing the object

        aPos:  The position of the object
        """
        return _pcbnew.MARKER_BASE_SetData(self, *args)

   def SetAuxiliaryData(self, *args):
        """
        SetAuxiliaryData(MARKER_BASE self, wxString const & aAuxiliaryText, wxPoint aAuxiliaryPos)

        void
        MARKER_BASE::SetAuxiliaryData(const wxString &aAuxiliaryText, const
        wxPoint &aAuxiliaryPos)

        Function SetAuxiliaryData initialize data for the second (auxiliary)
        item.

        Parameters:
        -----------

        aAuxiliaryText:  = the second text (main text) concerning the second
        schematic or board item

        aAuxiliaryPos:  = position the second item
        """
        return _pcbnew.MARKER_BASE_SetAuxiliaryData(self, *args)

   def SetShowNoCoordinate(self):
        """
        SetShowNoCoordinate(MARKER_BASE self)

        void
        MARKER_BASE::SetShowNoCoordinate()
        """
        return _pcbnew.MARKER_BASE_SetShowNoCoordinate(self)

   def GetReporter(self):
        """
        GetReporter(MARKER_BASE self) -> DRC_ITEM const &

        const DRC_ITEM&
        MARKER_BASE::GetReporter() const

        Function GetReporter returns the DRC_ITEM held within this MARKER so
        that its interface may be used.

        const& DRC_ITEM
        """
        return _pcbnew.MARKER_BASE_GetReporter(self)

   def DisplayMarkerInfo(self, *args):
        """
        DisplayMarkerInfo(MARKER_BASE self, EDA_DRAW_FRAME * aFrame)

        void
        MARKER_BASE::DisplayMarkerInfo(EDA_DRAW_FRAME *aFrame)

        Function DisplayMarkerInfo displays the full info of this marker, in a
        HTML window.
        """
        return _pcbnew.MARKER_BASE_DisplayMarkerInfo(self, *args)

   def HitTestMarker(self, *args):
        """
        HitTestMarker(MARKER_BASE self, wxPoint ref_pos) -> bool

        bool
        MARKER_BASE::HitTestMarker(const wxPoint &ref_pos) const

        Function HitTestMarker tests if the given wxPoint is within the bounds
        of this object.

        Parameters:
        -----------

        ref_pos:  A wxPoint to test

        bool - true if a hit, else false
        """
        return _pcbnew.MARKER_BASE_HitTestMarker(self, *args)

   def GetBoundingBoxMarker(self):
        """
        GetBoundingBoxMarker(MARKER_BASE self) -> EDA_RECT

        EDA_RECT
        MARKER_BASE::GetBoundingBoxMarker() const

        Function GetBoundingBoxMarker returns the orthogonal, bounding box of
        this object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.MARKER_BASE_GetBoundingBoxMarker(self)

MARKER_BASE_swigregister = _pcbnew.MARKER_BASE_swigregister
MARKER_BASE_swigregister(MARKER_BASE)

GR_TEXT_HJUSTIFY_LEFT = _pcbnew.GR_TEXT_HJUSTIFY_LEFT
GR_TEXT_HJUSTIFY_CENTER = _pcbnew.GR_TEXT_HJUSTIFY_CENTER
GR_TEXT_HJUSTIFY_RIGHT = _pcbnew.GR_TEXT_HJUSTIFY_RIGHT
GR_TEXT_VJUSTIFY_TOP = _pcbnew.GR_TEXT_VJUSTIFY_TOP
GR_TEXT_VJUSTIFY_CENTER = _pcbnew.GR_TEXT_VJUSTIFY_CENTER
GR_TEXT_VJUSTIFY_BOTTOM = _pcbnew.GR_TEXT_VJUSTIFY_BOTTOM
LINE = _pcbnew.LINE
FILLED = _pcbnew.FILLED
SKETCH = _pcbnew.SKETCH
DEFAULT_SIZE_TEXT = _pcbnew.DEFAULT_SIZE_TEXT
TEXT_NO_VISIBLE = _pcbnew.TEXT_NO_VISIBLE
DIM_ANCRE_TEXTE = _pcbnew.DIM_ANCRE_TEXTE
class EDA_TEXT(_object):
    """
    Class EDA_TEXT is a basic class to handle texts (labels, texts on
    components or footprints ..) not used directly.

    The "used" text classes are derived from EDA_ITEM and EDA_TEXT using
    multiple inheritance.

    C++ includes: eda_text.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EDA_TEXT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EDA_TEXT, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(EDA_TEXT self, wxString const & text=wxEmptyString) -> EDA_TEXT
        __init__(EDA_TEXT self) -> EDA_TEXT
        __init__(EDA_TEXT self, EDA_TEXT aText) -> EDA_TEXT

        EDA_TEXT::EDA_TEXT(const
        EDA_TEXT &aText)
        """
        this = _pcbnew.new_EDA_TEXT(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_EDA_TEXT
    __del__ = lambda self : None;
   def GetText(self):
        """
        GetText(EDA_TEXT self) -> wxString const &

        const wxString&
        EDA_TEXT::GetText() const

        Function GetText returns the string associated with the text object.

        a const wxString reference containing the string of the item.
        """
        return _pcbnew.EDA_TEXT_GetText(self)

   def GetShownText(self):
        """
        GetShownText(EDA_TEXT self) -> wxString

        virtual wxString
        EDA_TEXT::GetShownText() const

        Returns the string actually shown after processing of the base text.

       Default is no processing
        """
        return _pcbnew.EDA_TEXT_GetShownText(self)

   def ShortenedShownText(self):
        """
        ShortenedShownText(EDA_TEXT self) -> wxString

        wxString
        EDA_TEXT::ShortenedShownText() const

        Returns a shortened version (max 15 characters) of the shown text.
        """
        return _pcbnew.EDA_TEXT_ShortenedShownText(self)

   def SetText(self, *args):
        """
        SetText(EDA_TEXT self, wxString const & aText)

        virtual void
        EDA_TEXT::SetText(const wxString &aText)
        """
        return _pcbnew.EDA_TEXT_SetText(self, *args)

   def SetThickness(self, *args):
        """
        SetThickness(EDA_TEXT self, int aNewThickness)

        void
        EDA_TEXT::SetThickness(int aNewThickness)

        Function SetThickness sets text thickness.

        Parameters:
        -----------

        aNewThickness:  is the new text thickness.
        """
        return _pcbnew.EDA_TEXT_SetThickness(self, *args)

   def GetThickness(self):
        """
        GetThickness(EDA_TEXT self) -> int

        int
        EDA_TEXT::GetThickness() const

        Function GetThickness returns text thickness.

        int - text thickness.
        """
        return _pcbnew.EDA_TEXT_GetThickness(self)

   def SetOrientation(self, *args):
        """
        SetOrientation(EDA_TEXT self, double aOrientation)

        void
        EDA_TEXT::SetOrientation(double aOrientation)
        """
        return _pcbnew.EDA_TEXT_SetOrientation(self, *args)

   def GetOrientation(self):
        """
        GetOrientation(EDA_TEXT self) -> double

        double
        EDA_TEXT::GetOrientation() const
        """
        return _pcbnew.EDA_TEXT_GetOrientation(self)

   def SetItalic(self, *args):
        """
        SetItalic(EDA_TEXT self, bool isItalic)

        void
        EDA_TEXT::SetItalic(bool isItalic)
        """
        return _pcbnew.EDA_TEXT_SetItalic(self, *args)

   def IsItalic(self):
        """
        IsItalic(EDA_TEXT self) -> bool

        bool EDA_TEXT::IsItalic()
        const
        """
        return _pcbnew.EDA_TEXT_IsItalic(self)

   def SetBold(self, *args):
        """
        SetBold(EDA_TEXT self, bool aBold)

        void EDA_TEXT::SetBold(bool
        aBold)
        """
        return _pcbnew.EDA_TEXT_SetBold(self, *args)

   def IsBold(self):
        """
        IsBold(EDA_TEXT self) -> bool

        bool EDA_TEXT::IsBold()
        const
        """
        return _pcbnew.EDA_TEXT_IsBold(self)

   def SetVisible(self, *args):
        """
        SetVisible(EDA_TEXT self, bool aVisible)

        void
        EDA_TEXT::SetVisible(bool aVisible)
        """
        return _pcbnew.EDA_TEXT_SetVisible(self, *args)

   def IsVisible(self):
        """
        IsVisible(EDA_TEXT self) -> bool

        bool
        EDA_TEXT::IsVisible() const
        """
        return _pcbnew.EDA_TEXT_IsVisible(self)

   def SetMirrored(self, *args):
        """
        SetMirrored(EDA_TEXT self, bool isMirrored)

        void
        EDA_TEXT::SetMirrored(bool isMirrored)
        """
        return _pcbnew.EDA_TEXT_SetMirrored(self, *args)

   def IsMirrored(self):
        """
        IsMirrored(EDA_TEXT self) -> bool

        bool
        EDA_TEXT::IsMirrored() const
        """
        return _pcbnew.EDA_TEXT_IsMirrored(self)

   def SetAttributes(self, *args):
        """
        SetAttributes(EDA_TEXT self, int aAttributes)

        void
        EDA_TEXT::SetAttributes(int aAttributes)
        """
        return _pcbnew.EDA_TEXT_SetAttributes(self, *args)

   def GetAttributes(self):
        """
        GetAttributes(EDA_TEXT self) -> int

        int
        EDA_TEXT::GetAttributes() const
        """
        return _pcbnew.EDA_TEXT_GetAttributes(self)

   def IsDefaultFormatting(self):
        """
        IsDefaultFormatting(EDA_TEXT self) -> bool

        bool
        EDA_TEXT::IsDefaultFormatting() const
        """
        return _pcbnew.EDA_TEXT_IsDefaultFormatting(self)

   def SetSize(self, *args):
        """
        SetSize(EDA_TEXT self, wxSize aNewSize)

        void
        EDA_TEXT::SetSize(const wxSize &aNewSize)

        Function SetSize sets text size.

        Parameters:
        -----------

        aNewSize:  is the new text size.
        """
        return _pcbnew.EDA_TEXT_SetSize(self, *args)

   def GetSize(self):
        """
        GetSize(EDA_TEXT self) -> wxSize

        const wxSize&
        EDA_TEXT::GetSize() const

        Function GetSize returns text size.

        wxSize - text size.
        """
        return _pcbnew.EDA_TEXT_GetSize(self)

   def SetWidth(self, *args):
        """
        SetWidth(EDA_TEXT self, int aWidth)

        void
        EDA_TEXT::SetWidth(int aWidth)
        """
        return _pcbnew.EDA_TEXT_SetWidth(self, *args)

   def GetWidth(self):
        """
        GetWidth(EDA_TEXT self) -> int

        int EDA_TEXT::GetWidth()
        const
        """
        return _pcbnew.EDA_TEXT_GetWidth(self)

   def SetHeight(self, *args):
        """
        SetHeight(EDA_TEXT self, int aHeight)

        void
        EDA_TEXT::SetHeight(int aHeight)
        """
        return _pcbnew.EDA_TEXT_SetHeight(self, *args)

   def GetHeight(self):
        """
        GetHeight(EDA_TEXT self) -> int

        int EDA_TEXT::GetHeight()
        const
        """
        return _pcbnew.EDA_TEXT_GetHeight(self)

   def SetTextPosition(self, *args):
        """
        SetTextPosition(EDA_TEXT self, wxPoint aPoint)

        void
        EDA_TEXT::SetTextPosition(const wxPoint &aPoint)

        named differently than the ones using multiple inheritance and
        including this class
        """
        return _pcbnew.EDA_TEXT_SetTextPosition(self, *args)

   def GetTextPosition(self):
        """
        GetTextPosition(EDA_TEXT self) -> wxPoint

        const wxPoint&
        EDA_TEXT::GetTextPosition() const
        """
        return _pcbnew.EDA_TEXT_GetTextPosition(self)

   def SetMultilineAllowed(self, *args):
        """
        SetMultilineAllowed(EDA_TEXT self, bool aAllow)

        void
        EDA_TEXT::SetMultilineAllowed(bool aAllow)
        """
        return _pcbnew.EDA_TEXT_SetMultilineAllowed(self, *args)

   def IsMultilineAllowed(self):
        """
        IsMultilineAllowed(EDA_TEXT self) -> bool

        bool
        EDA_TEXT::IsMultilineAllowed() const
        """
        return _pcbnew.EDA_TEXT_IsMultilineAllowed(self)

   def Offset(self, *args):
        """
        Offset(EDA_TEXT self, wxPoint aOffset)

        void EDA_TEXT::Offset(const
        wxPoint &aOffset)
        """
        return _pcbnew.EDA_TEXT_Offset(self, *args)

   def Empty(self):
        """
        Empty(EDA_TEXT self)

        void EDA_TEXT::Empty()
        """
        return _pcbnew.EDA_TEXT_Empty(self)

   def Draw(self, *args):
        """
        Draw(EDA_TEXT self, EDA_RECT aClipBox, wxDC * aDC, wxPoint aOffset, EDA_COLOR_T aColor, GR_DRAWMODE aDrawMode,
            EDA_DRAW_MODE_T aDisplay_mode=LINE, EDA_COLOR_T aAnchor_color=UNSPECIFIED_COLOR)
        Draw(EDA_TEXT self, EDA_RECT aClipBox, wxDC * aDC, wxPoint aOffset, EDA_COLOR_T aColor, GR_DRAWMODE aDrawMode,
            EDA_DRAW_MODE_T aDisplay_mode=LINE)
        Draw(EDA_TEXT self, EDA_RECT aClipBox, wxDC * aDC, wxPoint aOffset, EDA_COLOR_T aColor, GR_DRAWMODE aDrawMode)

        void EDA_TEXT::Draw(EDA_RECT
        *aClipBox, wxDC *aDC, const wxPoint &aOffset, EDA_COLOR_T aColor,
        GR_DRAWMODE aDrawMode, EDA_DRAW_MODE_T aDisplay_mode=LINE, EDA_COLOR_T
        aAnchor_color=UNSPECIFIED_COLOR)

        Function Draw.

        Parameters:
        -----------

        aClipBox:  = the clipping rect, or NULL if no clipping

        aDC:  = the current Device Context

        aOffset:  = draw offset (usually (0,0))

        aColor:  = text color

        aDrawMode:  = GR_OR, GR_XOR.., -1 to use the current mode.

        aDisplay_mode:  = LINE, FILLED or SKETCH

        aAnchor_color:  = anchor color ( UNSPECIFIED = do not draw anchor ).

        """
        return _pcbnew.EDA_TEXT_Draw(self, *args)

   def TransformTextShapeToSegmentList(self, *args):
        """
        TransformTextShapeToSegmentList(EDA_TEXT self, std::vector< wxPoint,std::allocator< wxPoint > > & aCornerBuffer)

        void EDA_TEXT::TransformTextShapeToSegmentList(std::vector< wxPoint >
        &aCornerBuffer) const

        Convert the text shape to a list of segment each segment is stored as
        2 wxPoints: the starting point and the ending point there are
        therefore 2*n points.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon
        """
        return _pcbnew.EDA_TEXT_TransformTextShapeToSegmentList(self, *args)

   def TextHitTest(self, *args):
        """
        TextHitTest(EDA_TEXT self, wxPoint aPoint, int aAccuracy=0) -> bool
        TextHitTest(EDA_TEXT self, wxPoint aPoint) -> bool
        TextHitTest(EDA_TEXT self, EDA_RECT aRect, bool aContains=False, int aAccuracy=0) -> bool
        TextHitTest(EDA_TEXT self, EDA_RECT aRect, bool aContains=False) -> bool
        TextHitTest(EDA_TEXT self, EDA_RECT aRect) -> bool

        bool
        EDA_TEXT::TextHitTest(const EDA_RECT &aRect, bool aContains=false, int
        aAccuracy=0) const

        Function TextHitTest (overloaded) Tests if object bounding box is
        contained within or intersects aRect.

        Parameters:
        -----------

        aRect:  - Rect to test against.

        aContains:  - Test for containment instead of intersection if true.

        aAccuracy:  - Amount to inflate the bounding box.

        bool - true if a hit, else false
        """
        return _pcbnew.EDA_TEXT_TextHitTest(self, *args)

   def LenSize(self, *args):
        """
        LenSize(EDA_TEXT self, wxString const & aLine) -> int

        int EDA_TEXT::LenSize(const
        wxString &aLine) const

        Function LenSize.

        the text length in internal units

        Parameters:
        -----------

        aLine:  : the line of text to consider. For single line text, this
        parameter is always m_Text
        """
        return _pcbnew.EDA_TEXT_LenSize(self, *args)

   def GetTextBox(self, *args):
        """
        GetTextBox(EDA_TEXT self, int aLine=-1, int aThickness=-1, bool aInvertY=False) -> EDA_RECT
        GetTextBox(EDA_TEXT self, int aLine=-1, int aThickness=-1) -> EDA_RECT
        GetTextBox(EDA_TEXT self, int aLine=-1) -> EDA_RECT
        GetTextBox(EDA_TEXT self) -> EDA_RECT

        EDA_RECT
        EDA_TEXT::GetTextBox(int aLine=-1, int aThickness=-1, bool
        aInvertY=false) const

        Function GetTextBox useful in multiline texts to calculate the full
        text or a line area (for zones filling, locate functions....)

        the rect containing the line of text (i.e. the position and the size
        of one line) this rectangle is calculated for 0 orient text. If
        orientation is not 0 the rect must be rotated to match the physical
        area

        Parameters:
        -----------

        aLine:  The line of text to consider. for single line text, aLine is
        unused If aLine == -1, the full area (considering all lines) is
        returned

        aThickness:  Overrides the current thickness when greater than 0. this
       is needed when the current m_Thickness is 0 and a default line
        thickness is used

        aInvertY:  Invert the Y axis when calculating bounding box.
        """
        return _pcbnew.EDA_TEXT_GetTextBox(self, *args)

   def GetInterline(self, *args):
        """
        GetInterline(EDA_TEXT self, int aTextThickness=-1) -> int
        GetInterline(EDA_TEXT self) -> int

        int
        EDA_TEXT::GetInterline(int aTextThickness=-1) const

        Function GetInterline return the distance between 2 text lines has
        meaning only for multiline texts.

        Parameters:
        -----------

        aTextThickness:  Overrides the current thickness when greater than 0.
       this is needed when the current m_Thickness is 0 and a default line
        thickness is used
        """
        return _pcbnew.EDA_TEXT_GetInterline(self, *args)

   def GetTextStyleName(self):
        """
        GetTextStyleName(EDA_TEXT self) -> wxString

        wxString
        EDA_TEXT::GetTextStyleName()

        Function GetTextStyleName.

        a wxString with the style name( Normal, Italic, Bold, Bold+Italic)
        """
        return _pcbnew.EDA_TEXT_GetTextStyleName(self)

   def GetHorizJustify(self):
        """
        GetHorizJustify(EDA_TEXT self) -> EDA_TEXT_HJUSTIFY_T

        EDA_TEXT_HJUSTIFY_T
        EDA_TEXT::GetHorizJustify() const
        """
        return _pcbnew.EDA_TEXT_GetHorizJustify(self)

   def GetVertJustify(self):
        """
        GetVertJustify(EDA_TEXT self) -> EDA_TEXT_VJUSTIFY_T

        EDA_TEXT_VJUSTIFY_T
        EDA_TEXT::GetVertJustify() const
        """
        return _pcbnew.EDA_TEXT_GetVertJustify(self)

   def SetHorizJustify(self, *args):
        """
        SetHorizJustify(EDA_TEXT self, EDA_TEXT_HJUSTIFY_T aType)

        void
        EDA_TEXT::SetHorizJustify(EDA_TEXT_HJUSTIFY_T aType)
        """
        return _pcbnew.EDA_TEXT_SetHorizJustify(self, *args)

   def SetVertJustify(self, *args):
        """
        SetVertJustify(EDA_TEXT self, EDA_TEXT_VJUSTIFY_T aType)

        void
        EDA_TEXT::SetVertJustify(EDA_TEXT_VJUSTIFY_T aType)
        """
        return _pcbnew.EDA_TEXT_SetVertJustify(self, *args)

   def GetPositionsOfLinesOfMultilineText(self, *args):
        """
        GetPositionsOfLinesOfMultilineText(EDA_TEXT self, std::vector< wxPoint,std::allocator< wxPoint > > & aPositions, int aLineCount)

        void EDA_TEXT::GetPositionsOfLinesOfMultilineText(std::vector< wxPoint
        > &aPositions, int aLineCount) const

        Function GetPositionsOfLinesOfMultilineText Populates aPositions with
        the position of each line of a multiline text, according to the
        vertical justification and the rotation of the whole text.

        Parameters:
        -----------

        aPositions:  is the list to populate by the wxPoint positions

        aLineCount:  is the number of lines (not recalculated here for
        efficiency reasons
        """
        return _pcbnew.EDA_TEXT_GetPositionsOfLinesOfMultilineText(self, *args)

   def Format(self, *args):
        """
        Format(EDA_TEXT self, OUTPUTFORMATTER * aFormatter, int aNestLevel, int aControlBits)

        void
        EDA_TEXT::Format(OUTPUTFORMATTER *aFormatter, int aNestLevel, int
        aControlBits) const  throw ( IO_ERROR ) Function Format outputs the
        object to aFormatter in s-expression form.

        Parameters:
        -----------

        aFormatter:  The OUTPUTFORMATTER object to write to.

        aNestLevel:  The indentation next level.

       aControlBits:  The control bit definition for object specific
        formatting.

        Parameters:
        -----------

        ???:  on write error.
        """
        return _pcbnew.EDA_TEXT_Format(self, *args)

EDA_TEXT_swigregister = _pcbnew.EDA_TEXT_swigregister
EDA_TEXT_swigregister(EDA_TEXT)

MM_PER_IU = _pcbnew.MM_PER_IU
MILS_PER_IU = _pcbnew.MILS_PER_IU
DECIMILS_PER_IU = _pcbnew.DECIMILS_PER_IU

def Iu2Mils(*args):
  """Iu2Mils(int iu) -> int"""
  return _pcbnew.Iu2Mils(*args)

def Iu2DMils(*args):
  """Iu2DMils(int iu) -> int"""
  return _pcbnew.Iu2DMils(*args)
IU_PER_MM = _pcbnew.IU_PER_MM
IU_PER_MILS = _pcbnew.IU_PER_MILS
IU_PER_DECIMILS = _pcbnew.IU_PER_DECIMILS

def Mils2iu(*args):
  """Mils2iu(int mils) -> int"""
  return _pcbnew.Mils2iu(*args)

def DMils2iu(*args):
  """DMils2iu(int dmils) -> int"""
  return _pcbnew.DMils2iu(*args)

def Millimeter2iu(*args):
  """Millimeter2iu(double mm) -> int"""
  return _pcbnew.Millimeter2iu(*args)
class FPID(_object):
    """
    Class FPID is a Logical Footprint ID and consists of various portions
    much like a URI.

    It is a container for the separated portions of a logical footprint id
    so they can be accessed individually. The various portions of an FPID
    are: logicalLibraryName (nick name), footprint name, and revision. The
    logical library name and the footprint name are mandatory. The
    revision is optional and currently is not used.

    Example FPID string: "smt:R_0805/rev0".

    "smt" is the logical library name used to look up library
    information saved in the FP_LIB_TABLE.

    "R" is the name of the footprint within the library.

    "rev0" is the revision, which is optional. If missing then its /
    delimiter should also not be present. A revision must begin with
    "rev" and be followed by at least one or more decimal digits.

    Dick Hollenbeck

    C++ includes: fpid.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FPID, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FPID, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(FPID self) -> FPID
        __init__(FPID self, std::string const & aId) -> FPID
        __init__(FPID self, wxString const & aId) -> FPID

        FPID::FPID(const wxString &aId)
        throw ( PARSE_ERROR )
        """
        this = _pcbnew.new_FPID(*args)
        try: self.this.append(this)
        except: self.this = this
   def Parse(self, *args):
        """
        Parse(FPID self, UTF8 aId) -> int

        int FPID::Parse(const UTF8 &aId)

        Function Parse [re-]stuffs this FPID with the information from aId.

        Parameters:
        -----------

        aId:  is the string to populate the FPID object.

        int - minus 1 (i.e. -1) means success, >= 0 indicates the character
        offset into aId at which an error was detected.
        """
        return _pcbnew.FPID_Parse(self, *args)

   def GetLibNickname(self):
        """
        GetLibNickname(FPID self) -> UTF8

        const UTF8&
        FPID::GetLibNickname() const

        Function GetLibNickname returns the logical library name portion of a
        FPID.
        """
        return _pcbnew.FPID_GetLibNickname(self)

   def SetLibNickname(self, *args):
        """
        SetLibNickname(FPID self, UTF8 aNickname) -> int

        int
        FPID::SetLibNickname(const UTF8 &aNickname)

        Function SetLibNickname overrides the logical footprint library name
        portion of the FPID to aNickname.

        int - minus 1 (i.e. -1) means success, >= 0 indicates the character
        offset into the parameter at which an error was detected, usually
        because it contained '/' or ':'.
        """
        return _pcbnew.FPID_SetLibNickname(self, *args)

   def GetFootprintName(self):
        """
        GetFootprintName(FPID self) -> UTF8

        const UTF8&
        FPID::GetFootprintName() const

        Function GetFootprintName returns the footprint name, i.e.

        footprintName.
        """
        return _pcbnew.FPID_GetFootprintName(self)

   def SetFootprintName(self, *args):
        """
        SetFootprintName(FPID self, UTF8 aFootprintName) -> int

        int
        FPID::SetFootprintName(const UTF8 &aFootprintName)

        Function SetFootprintName overrides the footprint name portion of the
        FPID to aFootprintName.
        """
        return _pcbnew.FPID_SetFootprintName(self, *args)

   def SetRevision(self, *args):
        """
        SetRevision(FPID self, UTF8 aRevision) -> int

        int FPID::SetRevision(const
        UTF8 &aRevision)
        """
        return _pcbnew.FPID_SetRevision(self, *args)

   def GetRevision(self):
        """
        GetRevision(FPID self) -> UTF8

        const UTF8&
        FPID::GetRevision() const
        """
        return _pcbnew.FPID_GetRevision(self)

   def GetFootprintNameAndRev(self):
        """
        GetFootprintNameAndRev(FPID self) -> UTF8

        UTF8
        FPID::GetFootprintNameAndRev() const
        """
        return _pcbnew.FPID_GetFootprintNameAndRev(self)

   def Format(self):
        """
        Format(FPID self) -> UTF8

        UTF8 FPID::Format() const

        Function Format returns the fully formatted text of the FPID.
        """
        return _pcbnew.FPID_Format(self)

   def IsValid(self):
        """
        IsValid(FPID self) -> bool

        bool FPID::IsValid() const

        Function Format returns a wxString in the proper format as an FPID for
        a combination of aLibNickname, aFootprintName, and aRevision.

        Parameters:
        -----------

        ???:  if any of the pieces are illegal. static UTF8 Format( const
        UTF8& aLibNickname, const UTF8& aFootprintName, const UTF8& aRevision
        = "" ) throw( PARSE_ERROR ); Function IsValid

        true is the FPID is valid.  A valid FPID must have both the footprint
       library nickname and the footprint name defined. The revision field is
        optional.

        A return value of true does not indicated that the FPID is a valid
        FP_LIB_TABLE entry.
        """
        return _pcbnew.FPID_IsValid(self)

   def IsLegacy(self):
        """
        IsLegacy(FPID self) -> bool

        bool FPID::IsLegacy() const

        Function IsLegacy.

       true if the FPID only has the footprint name defined.
        """
        return _pcbnew.FPID_IsLegacy(self)

   def clear(self):
        """
        clear(FPID self)

        void FPID::clear()

        Function clear clears the contents of the library nickname, footprint
        name, and revision strings.
        """
        return _pcbnew.FPID_clear(self)

   def empty(self):
        """
        empty(FPID self) -> bool

        bool FPID::empty() const

        Function empty.

        a boolean true value if the FPID is empty. Otherwise return false.
        """
        return _pcbnew.FPID_empty(self)

   def compare(self, *args):
        """
        compare(FPID self, FPID aFPID) -> int

        int FPID::compare(const FPID
        &aFPID) const

        Function Compare compares the contents of FPID objects by performing a
        std::string comparison of the library nickname, footprint name, and
        revision strings respectively.

        Parameters:
        -----------

        aFPID:  is the FPID to compare against.

        -1 if less than aFPID, 1 if greater than aFPID, and 0 if equal to
        aFPID.
        """
        return _pcbnew.FPID_compare(self, *args)

   def __lt__(self, *args):
        """__lt__(FPID self, FPID aFPID) -> bool"""
        return _pcbnew.FPID___lt__(self, *args)

   def __gt__(self, *args):
        """__gt__(FPID self, FPID aFPID) -> bool"""
        return _pcbnew.FPID___gt__(self, *args)

   def __eq__(self, *args):
        """__eq__(FPID self, FPID aFPID) -> bool"""
        return _pcbnew.FPID___eq__(self, *args)

   def __ne__(self, *args):
        """__ne__(FPID self, FPID aFPID) -> bool"""
        return _pcbnew.FPID___ne__(self, *args)

    __swig_destroy__ = _pcbnew.delete_FPID
    __del__ = lambda self : None;
FPID_swigregister = _pcbnew.FPID_swigregister
FPID_swigregister(FPID)

class intVector(_object):
    """Proxy of C++ std::vector<(int)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, intVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, intVector, name)
    __repr__ = _swig_repr
   def iterator(self):
        """iterator(intVector self) -> SwigPyIterator"""
        return _pcbnew.intVector_iterator(self)

   def __iter__(self): return self.iterator()
   def __nonzero__(self):
        """__nonzero__(intVector self) -> bool"""
        return _pcbnew.intVector___nonzero__(self)

   def __bool__(self):
        """__bool__(intVector self) -> bool"""
        return _pcbnew.intVector___bool__(self)

   def __len__(self):
        """__len__(intVector self) -> std::vector< int >::size_type"""
        return _pcbnew.intVector___len__(self)

   def pop(self):
        """pop(intVector self) -> std::vector< int >::value_type"""
        return _pcbnew.intVector_pop(self)

   def __getslice__(self, *args):
        """__getslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> intVector"""
        return _pcbnew.intVector___getslice__(self, *args)

   def __setslice__(self, *args):
        """
        __setslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, intVector v=std::vector< int,std::allocator< int > >())
        __setslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        """
        return _pcbnew.intVector___setslice__(self, *args)

   def __delslice__(self, *args):
        """__delslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _pcbnew.intVector___delslice__(self, *args)

   def __delitem__(self, *args):
        """
        __delitem__(intVector self, std::vector< int >::difference_type i)
        __delitem__(intVector self, PySliceObject * slice)
        """
        return _pcbnew.intVector___delitem__(self, *args)

   def __getitem__(self, *args):
        """
        __getitem__(intVector self, PySliceObject * slice) -> intVector
        __getitem__(intVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _pcbnew.intVector___getitem__(self, *args)

   def __setitem__(self, *args):
        """
        __setitem__(intVector self, PySliceObject * slice, intVector v)
        __setitem__(intVector self, PySliceObject * slice)
        __setitem__(intVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _pcbnew.intVector___setitem__(self, *args)

   def append(self, *args):
        """append(intVector self, std::vector< int >::value_type const & x)"""
        return _pcbnew.intVector_append(self, *args)

   def empty(self):
        """empty(intVector self) -> bool"""
        return _pcbnew.intVector_empty(self)

   def size(self):
        """size(intVector self) -> std::vector< int >::size_type"""
        return _pcbnew.intVector_size(self)

   def clear(self):
        """clear(intVector self)"""
        return _pcbnew.intVector_clear(self)

   def swap(self, *args):
        """swap(intVector self, intVector v)"""
        return _pcbnew.intVector_swap(self, *args)

   def get_allocator(self):
        """get_allocator(intVector self) -> std::vector< int >::allocator_type"""
        return _pcbnew.intVector_get_allocator(self)

   def begin(self):
        """begin(intVector self) -> std::vector< int >::iterator"""
        return _pcbnew.intVector_begin(self)

   def end(self):
        """end(intVector self) -> std::vector< int >::iterator"""
        return _pcbnew.intVector_end(self)

   def rbegin(self):
        """rbegin(intVector self) -> std::vector< int >::reverse_iterator"""
        return _pcbnew.intVector_rbegin(self)

   def rend(self):
        """rend(intVector self) -> std::vector< int >::reverse_iterator"""
        return _pcbnew.intVector_rend(self)

   def pop_back(self):
        """pop_back(intVector self)"""
        return _pcbnew.intVector_pop_back(self)

   def erase(self, *args):
        """
        erase(intVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(intVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _pcbnew.intVector_erase(self, *args)

   def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> intVector
        __init__(std::vector<(int)> self, intVector arg2) -> intVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> intVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> intVector
        """
        this = _pcbnew.new_intVector(*args)
        try: self.this.append(this)
        except: self.this = this
   def push_back(self, *args):
        """push_back(intVector self, std::vector< int >::value_type const & x)"""
        return _pcbnew.intVector_push_back(self, *args)

   def front(self):
        """front(intVector self) -> std::vector< int >::value_type const &"""
        return _pcbnew.intVector_front(self)

   def back(self):
        """back(intVector self) -> std::vector< int >::value_type const &"""
        return _pcbnew.intVector_back(self)

   def assign(self, *args):
        """assign(intVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _pcbnew.intVector_assign(self, *args)

   def resize(self, *args):
        """
        resize(intVector self, std::vector< int >::size_type new_size)
        resize(intVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _pcbnew.intVector_resize(self, *args)

   def insert(self, *args):
        """
        insert(intVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(intVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _pcbnew.intVector_insert(self, *args)

   def reserve(self, *args):
        """reserve(intVector self, std::vector< int >::size_type n)"""
        return _pcbnew.intVector_reserve(self, *args)

   def capacity(self):
        """capacity(intVector self) -> std::vector< int >::size_type"""
        return _pcbnew.intVector_capacity(self)

    __swig_destroy__ = _pcbnew.delete_intVector
    __del__ = lambda self : None;
intVector_swigregister = _pcbnew.intVector_swigregister
intVector_swigregister(intVector)

class str_utf8_Map(_object):
    """Proxy of C++ std::map<(std::string,UTF8)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, str_utf8_Map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, str_utf8_Map, name)
    __repr__ = _swig_repr
   def iterator(self):
        """iterator(str_utf8_Map self) -> SwigPyIterator"""
        return _pcbnew.str_utf8_Map_iterator(self)

   def __iter__(self): return self.iterator()
   def __nonzero__(self):
        """__nonzero__(str_utf8_Map self) -> bool"""
        return _pcbnew.str_utf8_Map___nonzero__(self)

   def __bool__(self):
        """__bool__(str_utf8_Map self) -> bool"""
        return _pcbnew.str_utf8_Map___bool__(self)

   def __len__(self):
        """__len__(str_utf8_Map self) -> std::map< std::string,UTF8 >::size_type"""
        return _pcbnew.str_utf8_Map___len__(self)

   def __iter__(self): return self.key_iterator()
   def iterkeys(self): return self.key_iterator()
   def itervalues(self): return self.value_iterator()
   def iteritems(self): return self.iterator()
   def __getitem__(self, *args):
        """__getitem__(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & key) -> UTF8"""
        return _pcbnew.str_utf8_Map___getitem__(self, *args)

   def __delitem__(self, *args):
        """__delitem__(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & key)"""
        return _pcbnew.str_utf8_Map___delitem__(self, *args)

   def has_key(self, *args):
        """has_key(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & key) -> bool"""
        return _pcbnew.str_utf8_Map_has_key(self, *args)

   def keys(self):
        """keys(str_utf8_Map self) -> PyObject *"""
        return _pcbnew.str_utf8_Map_keys(self)

   def values(self):
        """values(str_utf8_Map self) -> PyObject *"""
        return _pcbnew.str_utf8_Map_values(self)

   def items(self):
        """items(str_utf8_Map self) -> PyObject *"""
        return _pcbnew.str_utf8_Map_items(self)

   def __contains__(self, *args):
        """__contains__(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & key) -> bool"""
        return _pcbnew.str_utf8_Map___contains__(self, *args)

   def key_iterator(self):
        """key_iterator(str_utf8_Map self) -> SwigPyIterator"""
        return _pcbnew.str_utf8_Map_key_iterator(self)

   def value_iterator(self):
        """value_iterator(str_utf8_Map self) -> SwigPyIterator"""
        return _pcbnew.str_utf8_Map_value_iterator(self)

   def __setitem__(self, *args):
        """
        __setitem__(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & key)
        __setitem__(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & key, UTF8 x)
        """
        return _pcbnew.str_utf8_Map___setitem__(self, *args)

   def asdict(self):
        """asdict(str_utf8_Map self) -> PyObject *"""
        return _pcbnew.str_utf8_Map_asdict(self)

   def __init__(self, *args):
        """
        __init__(std::map<(std::string,UTF8)> self, std::less< std::string > const & arg2) -> str_utf8_Map
        __init__(std::map<(std::string,UTF8)> self) -> str_utf8_Map
        __init__(std::map<(std::string,UTF8)> self, str_utf8_Map arg2) -> str_utf8_Map
        """
        this = _pcbnew.new_str_utf8_Map(*args)
        try: self.this.append(this)
        except: self.this = this
   def empty(self):
        """empty(str_utf8_Map self) -> bool"""
        return _pcbnew.str_utf8_Map_empty(self)

   def size(self):
        """size(str_utf8_Map self) -> std::map< std::string,UTF8 >::size_type"""
        return _pcbnew.str_utf8_Map_size(self)

   def clear(self):
        """clear(str_utf8_Map self)"""
        return _pcbnew.str_utf8_Map_clear(self)

   def swap(self, *args):
        """swap(str_utf8_Map self, str_utf8_Map v)"""
        return _pcbnew.str_utf8_Map_swap(self, *args)

   def get_allocator(self):
        """get_allocator(str_utf8_Map self) -> std::map< std::string,UTF8 >::allocator_type"""
        return _pcbnew.str_utf8_Map_get_allocator(self)

   def begin(self):
        """begin(str_utf8_Map self) -> std::map< std::string,UTF8 >::iterator"""
        return _pcbnew.str_utf8_Map_begin(self)

   def end(self):
        """end(str_utf8_Map self) -> std::map< std::string,UTF8 >::iterator"""
        return _pcbnew.str_utf8_Map_end(self)

   def rbegin(self):
        """rbegin(str_utf8_Map self) -> std::map< std::string,UTF8 >::reverse_iterator"""
        return _pcbnew.str_utf8_Map_rbegin(self)

   def rend(self):
        """rend(str_utf8_Map self) -> std::map< std::string,UTF8 >::reverse_iterator"""
        return _pcbnew.str_utf8_Map_rend(self)

   def count(self, *args):
        """count(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & x) -> std::map< std::string,UTF8 >::size_type"""
        return _pcbnew.str_utf8_Map_count(self, *args)

   def erase(self, *args):
        """
        erase(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & x) -> std::map< std::string,UTF8 >::size_type
        erase(str_utf8_Map self, std::map< std::string,UTF8 >::iterator position)
        erase(str_utf8_Map self, std::map< std::string,UTF8 >::iterator first, std::map< std::string,UTF8 >::iterator last)
        """
        return _pcbnew.str_utf8_Map_erase(self, *args)

   def find(self, *args):
        """find(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & x) -> std::map< std::string,UTF8 >::iterator"""
        return _pcbnew.str_utf8_Map_find(self, *args)

   def lower_bound(self, *args):
        """lower_bound(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & x) -> std::map< std::string,UTF8 >::iterator"""
        return _pcbnew.str_utf8_Map_lower_bound(self, *args)

   def upper_bound(self, *args):
        """upper_bound(str_utf8_Map self, std::map< std::string,UTF8 >::key_type const & x) -> std::map< std::string,UTF8 >::iterator"""
        return _pcbnew.str_utf8_Map_upper_bound(self, *args)

    __swig_destroy__ = _pcbnew.delete_str_utf8_Map
    __del__ = lambda self : None;
str_utf8_Map_swigregister = _pcbnew.str_utf8_Map_swigregister
str_utf8_Map_swigregister(str_utf8_Map)

KICAD_PLUGINS={}

def ReloadPlugin(name):
    if not KICAD_PLUGINS.has_key(name):
        return False

    KICAD_PLUGINS[name]["object"].deregister()
    mod = reload(KICAD_PLUGINS[name]["module"])
    KICAD_PLUGINS[name]["object"]= mod.register()


def ReloadPlugins():
    import os.path
    for k in KICAD_PLUGINS.keys():
        plugin = KICAD_PLUGINS[k]

        filename = plugin["filename"]
        mtime = plugin["modification_time"]
        now_mtime = os.path.getmtime(filename)

        if mtime!=now_mtime:
            print filename, " is modified, reloading"
            KICAD_PLUGINS[k]["modification_time"]=now_mtime
            ReloadPlugin(k)


def LoadPlugins( plugpath ):
    import os
    import sys

    kicad_path = os.environ.get('KICAD_PATH')
    plugin_directories=[]

    if plugpath and os.path.isdir( plugpath ):
        plugin_directories.append( plugpath )

    if kicad_path and os.path.isdir(kicad_path):
        plugin_directories.append(os.path.join(kicad_path, 'scripting', 'plugins'))

    if sys.platform.startswith('linux'):
        plugin_directories.append(os.environ['HOME']+'/.kicad_plugins/')
        plugin_directories.append(os.environ['HOME']+'/.kicad/scripting/plugins/')

    if sys.platform.startswith('darwin'):
        for singlepath in sys.path:
            if os.path.isdir( os.path.join( singlepath, 'scripting', 'plugins') ):
                plugin_directories.append( os.path.join( singlepath, 'scripting', 'plugins') )

    for plugins_dir in plugin_directories:
        sys.path.append(plugins_dir)

        if not os.path.isdir(plugins_dir):
            continue

        for module in os.listdir(plugins_dir):
            if os.path.isdir(plugins_dir+module):
                __import__(module, locals(), globals())

            if module == '__init__.py' or module[-3:] != '.py':
                continue

            mod = __import__(module[:-3], locals(), globals())

            module_filename = plugins_dir+"/"+module
            mtime = os.path.getmtime(module_filename)
            if hasattr(mod,'register'):
                KICAD_PLUGINS[module]={"filename":module_filename,
                                       "modification_time":mtime,
                                       "object":mod.register(),
                                       "module":mod}



class KiCadPlugin:
   def __init__(self):
        pass

   def register(self):
        if isinstance(self,FilePlugin):
            pass # register to file plugins in C++
        if isinstance(self,FootprintWizardPlugin):
            PYTHON_FOOTPRINT_WIZARDS.register_wizard(self)
            return

        if isinstance(self,ActionPlugin):
            pass # register to action plugins in C++

        return

   def deregister(self):
        if isinstance(self,FilePlugin):
            pass # register to file plugins in C++
        if isinstance(self,FootprintWizardPlugin):
            PYTHON_FOOTPRINT_WIZARDS.deregister_wizard(self)
            return

        if isinstance(self,ActionPlugin):
            pass # register to action plugins in C++

        return




class FilePlugin(KiCadPlugin):
   def __init__(self):
        KiCadPlugin.__init__(self)



class FootprintWizardPlugin(KiCadPlugin):
   def __init__(self):
        KiCadPlugin.__init__(self)
        self.defaults()

   def defaults(self):
        self.module = None
        self.parameters = {}
        self.parameter_errors={}
        self.name = "Undefined Footprint Wizard plugin"
        self.description = ""
        self.image = ""

   def GetName(self):
        return self.name

   def GetImage(self):
        return self.image

   def GetDescription(self):
        return self.description


   def GetNumParameterPages(self):
        return len(self.parameters)

   def GetParameterPageName(self,page_n):
        return self.parameters.keys()[page_n]

   def GetParameterNames(self,page_n):
        name = self.GetParameterPageName(page_n)
        return self.parameters[name].keys()

   def GetParameterValues(self,page_n):
        name = self.GetParameterPageName(page_n)
        values = self.parameters[name].values()
        return map( lambda x: str(x) , values) # list elements as strings

   def GetParameterErrors(self,page_n):
        self.CheckParameters()
        name = self.GetParameterPageName(page_n)
        values = self.parameter_errors[name].values()
        return map( lambda x: str(x) , values) # list elements as strings

   def CheckParameters(self):
        return ""

   def TryConvertToFloat(self,value):
        v = value
        try:
            v = float(value)
        except:
            pass

        return v

   def SetParameterValues(self,page_n,values):
        name = self.GetParameterPageName(page_n)
        keys = self.parameters[name].keys()
        n=0
        for key in keys:
            val = self.TryConvertToFloat(values[n])
            self.parameters[name][key] = val
            print "[%s][%s]<="%(name,key),val
            n+=1


   def ClearErrors(self):
        errs={}

        for page in self.parameters.keys():
            page_dict = self.parameters[page]
            page_params = {}
            for param in page_dict.keys():
                page_params[param]=""

            errs[page]=page_params

        self.parameter_errors = errs


   def GetModule(self):
        self.BuildFootprint()
        return self.module

   def BuildFootprint(self):
        return

   def Show(self):
        print "Footprint Wizard Name:        ",self.GetName()
        print "Footprint Wizard Description: ",self.GetDescription()
        n_pages = self.GetNumParameterPages()
        print " setup pages: ",n_pages
        for page in range(0,n_pages):
            name = self.GetParameterPageName(page)
            values = self.GetParameterValues(page)
            names =  self.GetParameterNames(page)
            print "page %d) %s"%(page,name)
            for n in range (0,len(values)):
                print "\t%s\t:\t%s"%(names[n],values[n])

class ActionPlugin(KiCadPlugin):
   def __init__(self):
        KiCadPlugin.__init__(self)


class CSegment(_object):
    """C++ includes: PolyLine.h """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSegment, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSegment, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_Start"] = _pcbnew.CSegment_m_Start_set
    __swig_getmethods__["m_Start"] = _pcbnew.CSegment_m_Start_get
    if _newclass:m_Start = _swig_property(_pcbnew.CSegment_m_Start_get, _pcbnew.CSegment_m_Start_set)
    __swig_setmethods__["m_End"] = _pcbnew.CSegment_m_End_set
    __swig_getmethods__["m_End"] = _pcbnew.CSegment_m_End_get
    if _newclass:m_End = _swig_property(_pcbnew.CSegment_m_End_get, _pcbnew.CSegment_m_End_set)
   def __init__(self, *args):
        """
        __init__(CSegment self) -> CSegment
        __init__(CSegment self, wxPoint aStart, wxPoint aEnd) -> CSegment
        __init__(CSegment self, int x0, int y0, int x1, int y1) -> CSegment

        CSegment::CSegment(int x0,
        int y0, int x1, int y1)
        """
        this = _pcbnew.new_CSegment(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_CSegment
    __del__ = lambda self : None;
CSegment_swigregister = _pcbnew.CSegment_swigregister
CSegment_swigregister(CSegment)

class CPolyPt(wxPoint):
    """C++ includes: PolyLine.h """
    __swig_setmethods__ = {}
    for _s in [wxPoint]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPolyPt, name, value)
    __swig_getmethods__ = {}
    for _s in [wxPoint]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, CPolyPt, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(CPolyPt self, int aX=0, int aY=0, bool aEnd=False, int aUtility=0) -> CPolyPt
        __init__(CPolyPt self, int aX=0, int aY=0, bool aEnd=False) -> CPolyPt
        __init__(CPolyPt self, int aX=0, int aY=0) -> CPolyPt
        __init__(CPolyPt self, int aX=0) -> CPolyPt
        __init__(CPolyPt self) -> CPolyPt
        __init__(CPolyPt self, CPolyPt aPt) -> CPolyPt
        __init__(CPolyPt self, wxPoint aPoint) -> CPolyPt

        CPolyPt::CPolyPt(const
        wxPoint &aPoint)
        """
        this = _pcbnew.new_CPolyPt(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_setmethods__["end_contour"] = _pcbnew.CPolyPt_end_contour_set
    __swig_getmethods__["end_contour"] = _pcbnew.CPolyPt_end_contour_get
    if _newclass:end_contour = _swig_property(_pcbnew.CPolyPt_end_contour_get, _pcbnew.CPolyPt_end_contour_set)
    __swig_setmethods__["m_flags"] = _pcbnew.CPolyPt_m_flags_set
    __swig_getmethods__["m_flags"] = _pcbnew.CPolyPt_m_flags_get
    if _newclass:m_flags = _swig_property(_pcbnew.CPolyPt_m_flags_get, _pcbnew.CPolyPt_m_flags_set)
   def __eq__(self, *args):
        """__eq__(CPolyPt self, CPolyPt cpt2) -> bool"""
        return _pcbnew.CPolyPt___eq__(self, *args)

   def __ne__(self, *args):
        """__ne__(CPolyPt self, CPolyPt cpt2) -> bool"""
        return _pcbnew.CPolyPt___ne__(self, *args)

    __swig_destroy__ = _pcbnew.delete_CPolyPt
    __del__ = lambda self : None;
CPolyPt_swigregister = _pcbnew.CPolyPt_swigregister
CPolyPt_swigregister(CPolyPt)

class CPOLYGONS_LIST(_object):
    """
    CPOLYGONS_LIST handle a list of contours (polygons corners).

    Each corner is a CPolyPt item. The last cornet of each contour has its
    end_contour member = true

    C++ includes: PolyLine.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPOLYGONS_LIST, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CPOLYGONS_LIST, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(CPOLYGONS_LIST self) -> CPOLYGONS_LIST

        CPOLYGONS_LIST::CPOLYGONS_LIST()
        """
        this = _pcbnew.new_CPOLYGONS_LIST()
        try: self.this.append(this)
        except: self.this = this
   def GetList(self):
        """
        GetList(CPOLYGONS_LIST self) -> std::vector< CPolyPt,std::allocator< CPolyPt > > const &

        const
        std::vector<CPolyPt>& CPOLYGONS_LIST::GetList() const
        """
        return _pcbnew.CPOLYGONS_LIST_GetList(self)

   def GetX(self, *args):
        """
        GetX(CPOLYGONS_LIST self, int ic) -> int

        int
        CPOLYGONS_LIST::GetX(int ic) const
        """
        return _pcbnew.CPOLYGONS_LIST_GetX(self, *args)

   def SetX(self, *args):
        """
        SetX(CPOLYGONS_LIST self, int ic, int aValue)

        void
        CPOLYGONS_LIST::SetX(int ic, int aValue)
        """
        return _pcbnew.CPOLYGONS_LIST_SetX(self, *args)

   def GetY(self, *args):
        """
        GetY(CPOLYGONS_LIST self, int ic) -> int

        int
        CPOLYGONS_LIST::GetY(int ic) const
        """
        return _pcbnew.CPOLYGONS_LIST_GetY(self, *args)

   def SetY(self, *args):
        """
        SetY(CPOLYGONS_LIST self, int ic, int aValue)

        void
        CPOLYGONS_LIST::SetY(int ic, int aValue)
        """
        return _pcbnew.CPOLYGONS_LIST_SetY(self, *args)

   def GetUtility(self, *args):
        """
        GetUtility(CPOLYGONS_LIST self, int ic) -> int

        int
        CPOLYGONS_LIST::GetUtility(int ic) const
        """
        return _pcbnew.CPOLYGONS_LIST_GetUtility(self, *args)

   def SetFlag(self, *args):
        """
        SetFlag(CPOLYGONS_LIST self, int ic, int aFlag)

        void
        CPOLYGONS_LIST::SetFlag(int ic, int aFlag)
        """
        return _pcbnew.CPOLYGONS_LIST_SetFlag(self, *args)

   def IsEndContour(self, *args):
        """
        IsEndContour(CPOLYGONS_LIST self, int ic) -> bool

        bool
        CPOLYGONS_LIST::IsEndContour(int ic) const
        """
        return _pcbnew.CPOLYGONS_LIST_IsEndContour(self, *args)

   def SetEndContour(self, *args):
        """
        SetEndContour(CPOLYGONS_LIST self, int ic, bool end_contour)

        void
        CPOLYGONS_LIST::SetEndContour(int ic, bool end_contour)
        """
        return _pcbnew.CPOLYGONS_LIST_SetEndContour(self, *args)

   def GetPos(self, *args):
        """
        GetPos(CPOLYGONS_LIST self, int ic) -> wxPoint

        const wxPoint&
        CPOLYGONS_LIST::GetPos(int ic) const
        """
        return _pcbnew.CPOLYGONS_LIST_GetPos(self, *args)

   def GetCorner(self, *args):
        """
        GetCorner(CPOLYGONS_LIST self, int ic) -> CPolyPt

        const CPolyPt&
        CPOLYGONS_LIST::GetCorner(int ic) const
        """
        return _pcbnew.CPOLYGONS_LIST_GetCorner(self, *args)

   def reserve(self, *args):
        """
        reserve(CPOLYGONS_LIST self, int aSize)

        void
        CPOLYGONS_LIST::reserve(int aSize)
        """
        return _pcbnew.CPOLYGONS_LIST_reserve(self, *args)

   def RemoveAllContours(self):
        """
        RemoveAllContours(CPOLYGONS_LIST self)

        void
        CPOLYGONS_LIST::RemoveAllContours(void)
        """
        return _pcbnew.CPOLYGONS_LIST_RemoveAllContours(self)

   def GetLastCorner(self):
        """
        GetLastCorner(CPOLYGONS_LIST self) -> CPolyPt

        CPolyPt&
        CPOLYGONS_LIST::GetLastCorner()
        """
        return _pcbnew.CPOLYGONS_LIST_GetLastCorner(self)

   def GetCornersCount(self):
        """
        GetCornersCount(CPOLYGONS_LIST self) -> unsigned int

        unsigned
        CPOLYGONS_LIST::GetCornersCount() const
        """
        return _pcbnew.CPOLYGONS_LIST_GetCornersCount(self)

   def DeleteCorner(self, *args):
        """
        DeleteCorner(CPOLYGONS_LIST self, int aIdx)

        void
        CPOLYGONS_LIST::DeleteCorner(int aIdx)
        """
        return _pcbnew.CPOLYGONS_LIST_DeleteCorner(self, *args)

   def DeleteCorners(self, *args):
        """
        DeleteCorners(CPOLYGONS_LIST self, int aIdFirstCorner, int aIdLastCorner)

        void
        CPOLYGONS_LIST::DeleteCorners(int aIdFirstCorner, int aIdLastCorner)

        """
        return _pcbnew.CPOLYGONS_LIST_DeleteCorners(self, *args)

   def Append(self, *args):
        """
        Append(CPOLYGONS_LIST self, CPOLYGONS_LIST aList)
        Append(CPOLYGONS_LIST self, CPolyPt aItem)
        Append(CPOLYGONS_LIST self, wxPoint aItem)

        void
        CPOLYGONS_LIST::Append(const wxPoint &aItem)
        """
        return _pcbnew.CPOLYGONS_LIST_Append(self, *args)

   def InsertCorner(self, *args):
        """
        InsertCorner(CPOLYGONS_LIST self, int aPosition, CPolyPt aItem)

        void
        CPOLYGONS_LIST::InsertCorner(int aPosition, const CPolyPt &aItem)
        """
        return _pcbnew.CPOLYGONS_LIST_InsertCorner(self, *args)

   def AddCorner(self, *args):
        """
        AddCorner(CPOLYGONS_LIST self, CPolyPt aCorner)

        void
        CPOLYGONS_LIST::AddCorner(const CPolyPt &aCorner)

        function AddCorner add a corner to the list
        """
        return _pcbnew.CPOLYGONS_LIST_AddCorner(self, *args)

   def CloseLastContour(self):
        """
        CloseLastContour(CPOLYGONS_LIST self)

        void
        CPOLYGONS_LIST::CloseLastContour()

        function CloseLastContour Set the .end_contour member of the last
        corner in list to true
        """
        return _pcbnew.CPOLYGONS_LIST_CloseLastContour(self)

   def ExportTo(self, *args):
        """
        ExportTo(CPOLYGONS_LIST self, KI_POLYGON_SET & aPolygons)
        ExportTo(CPOLYGONS_LIST self, KI_POLYGON_WITH_HOLES & aPolygoneWithHole)
        ExportTo(CPOLYGONS_LIST self, ClipperLib::Paths & aPolygons)

        void
        CPOLYGONS_LIST::ExportTo(ClipperLib::Paths &aPolygons) const

        Function ExportTo Copy all contours to a ClipperLib::Paths, each
        contour is exported to a ClipperLib::Path.

        Parameters:
        -----------

        aPolygons:  = the ClipperLib::Paths to populate
        """
        return _pcbnew.CPOLYGONS_LIST_ExportTo(self, *args)

   def ImportFrom(self, *args):
        """
        ImportFrom(CPOLYGONS_LIST self, KI_POLYGON_SET & aPolygons)
        ImportFrom(CPOLYGONS_LIST self, ClipperLib::Paths & aPolygons)

        void
        CPOLYGONS_LIST::ImportFrom(ClipperLib::Paths &aPolygons)

        Function ImportFrom Copy all polygons from a ClipperLib::Paths in
        list.

        Parameters:
        -----------

        aPolygons:  = the ClipperLib::Paths to import
        """
        return _pcbnew.CPOLYGONS_LIST_ImportFrom(self, *args)

   def InflateOutline(self, *args):
        """
        InflateOutline(CPOLYGONS_LIST self, CPOLYGONS_LIST aResult, int aInflateValue, bool aLinkHoles)

        void
        CPOLYGONS_LIST::InflateOutline(CPOLYGONS_LIST &aResult, int
        aInflateValue, bool aLinkHoles)

        Function InflateOutline Inflate the outline stored in m_cornersList.

        The first polygon is the external outline. It is inflated The other
       polygons are holes. they are deflated

        Parameters:
        -----------

        aResult:  = the Inflated outline

       aInflateValue:  = the Inflate value. when < 0, this is a deflate
        transform

        aLinkHoles:  = if true, aResult contains only one polygon, with holes
        linked by overlapping segments
        """
        return _pcbnew.CPOLYGONS_LIST_InflateOutline(self, *args)

    __swig_destroy__ = _pcbnew.delete_CPOLYGONS_LIST
    __del__ = lambda self : None;
CPOLYGONS_LIST_swigregister = _pcbnew.CPOLYGONS_LIST_swigregister
CPOLYGONS_LIST_swigregister(CPOLYGONS_LIST)

class CPolyLine(_object):
    """C++ includes: PolyLine.h """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CPolyLine, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CPolyLine, name)
    __repr__ = _swig_repr
    NO_HATCH = _pcbnew.CPolyLine_NO_HATCH
    DIAGONAL_FULL = _pcbnew.CPolyLine_DIAGONAL_FULL
    DIAGONAL_EDGE = _pcbnew.CPolyLine_DIAGONAL_EDGE
   def __init__(self, *args):
        """
        __init__(CPolyLine self) -> CPolyLine
        __init__(CPolyLine self, CPolyLine aCPolyLine) -> CPolyLine

        CPolyLine::CPolyLine(const CPolyLine &aCPolyLine)
        """
        this = _pcbnew.new_CPolyLine(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_CPolyLine
    __del__ = lambda self : None;
   def ImportSettings(self, *args):
        """
        ImportSettings(CPolyLine self, CPolyLine aPoly)

        void
        CPolyLine::ImportSettings(const CPolyLine *aPoly)

        Function ImportSettings Copy settings (layer, hatch styles) from
        aPoly.

        Parameters:
        -----------

        aPoly:  is the CPolyLine to import settings
        """
        return _pcbnew.CPolyLine_ImportSettings(self, *args)

   def Start(self, *args):
        """
        Start(CPolyLine self, LAYER_NUM layer, int x, int y, int hatch)

        void
        CPolyLine::Start(LAYER_NUM layer, int x, int y, int hatch)
        """
        return _pcbnew.CPolyLine_Start(self, *args)

   def AppendCorner(self, *args):
        """
        AppendCorner(CPolyLine self, int x, int y)

        void
        CPolyLine::AppendCorner(int x, int y)
        """
        return _pcbnew.CPolyLine_AppendCorner(self, *args)

   def InsertCorner(self, *args):
        """
        InsertCorner(CPolyLine self, int ic, int x, int y)

        void
        CPolyLine::InsertCorner(int ic, int x, int y)

        Function InsertCorner insert a new corner between two existing
        corners.

        Parameters:
        -----------

        ic:  = index for the insertion point: the corner is inserted AFTER ic

        x:  y:  = coordinates corner to insert
        """
        return _pcbnew.CPolyLine_InsertCorner(self, *args)

   def DeleteCorner(self, *args):
        """
        DeleteCorner(CPolyLine self, int ic)

        void
        CPolyLine::DeleteCorner(int ic)

        Function DeleteCorner remove the given corner.

        if it is the last point of a contour keep the controur closed by
        modifying the previous corner

        Parameters:
        -----------

        ic:  = the index of the corner to delete
        """
        return _pcbnew.CPolyLine_DeleteCorner(self, *args)

   def MoveCorner(self, *args):
        """
        MoveCorner(CPolyLine self, int ic, int x, int y)

        void
        CPolyLine::MoveCorner(int ic, int x, int y)
        """
        return _pcbnew.CPolyLine_MoveCorner(self, *args)

   def CloseLastContour(self):
        """
        CloseLastContour(CPolyLine self)

        void
        CPolyLine::CloseLastContour()

        function CloseLastContour Set the .end_contour member of the last
        corner of the last contour to true
        """
        return _pcbnew.CPolyLine_CloseLastContour(self)

   def RemoveContour(self, *args):
        """
        RemoveContour(CPolyLine self, int icont)

        void
        CPolyLine::RemoveContour(int icont)

        Function RemoveContour.

        Parameters:
        -----------

        icont:  = contour number to remove remove a contour only if there is
        more than 1 contour
        """
        return _pcbnew.CPolyLine_RemoveContour(self, *args)

   def IsPolygonSelfIntersecting(self):
        """
        IsPolygonSelfIntersecting(CPolyLine self) -> bool

        bool
        CPolyLine::IsPolygonSelfIntersecting()

        Function IsPolygonSelfIntersecting Test a CPolyLine for self-
        intersection of vertex (all contours).

        : false if no intersecting sides true if intersecting sides When a
        CPolyLine is self intersectic, it need to be normalized. (converted to
        non intersecting polygons)
        """
        return _pcbnew.CPolyLine_IsPolygonSelfIntersecting(self)

   def Chamfer(self, *args):
        """
        Chamfer(CPolyLine self, unsigned int aDistance) -> CPolyLine

        CPolyLine *
        CPolyLine::Chamfer(unsigned int aDistance)

        Function Chamfer returns a chamfered version of a polygon.

        Parameters:
        -----------

        aDistance:  is the chamfering distance.

        CPolyLine* - Pointer to new polygon.
        """
        return _pcbnew.CPolyLine_Chamfer(self, *args)

   def Fillet(self, *args):
        """
        Fillet(CPolyLine self, unsigned int aRadius, unsigned int aSegments) -> CPolyLine

        CPolyLine *
        CPolyLine::Fillet(unsigned int aRadius, unsigned int aSegments)

        Function Fillet returns a filleted version of a polygon.

        Parameters:
        -----------

        aRadius:  is the fillet radius.

        aSegments:  is the number of segments / fillet.

        CPolyLine* - Pointer to new polygon.
        """
        return _pcbnew.CPolyLine_Fillet(self, *args)

   def RemoveNullSegments(self):
        """
        RemoveNullSegments(CPolyLine self) -> int

        int
        CPolyLine::RemoveNullSegments()

        Function RemoveNullSegments Removes corners which create a null
        segment edge (i.e.

        when 2 successive corners are at the same location) the count of
        removed corners.
        """
        return _pcbnew.CPolyLine_RemoveNullSegments(self)

   def RemoveAllContours(self):
        """
        RemoveAllContours(CPolyLine self)

        void
        CPolyLine::RemoveAllContours(void)

        function RemoveAllContours removes all corners from the list.

        Others params are not changed
        """
        return _pcbnew.CPolyLine_RemoveAllContours(self)

   def UnHatch(self):
        """
        UnHatch(CPolyLine self)

        void CPolyLine::UnHatch()

        """
        return _pcbnew.CPolyLine_UnHatch(self)

   def Hatch(self):
        """
        Hatch(CPolyLine self)

        void CPolyLine::Hatch()
        """
        return _pcbnew.CPolyLine_Hatch(self)

   def MoveOrigin(self, *args):
        """
        MoveOrigin(CPolyLine self, int x_off, int y_off)

        void
        CPolyLine::MoveOrigin(int x_off, int y_off)
        """
        return _pcbnew.CPolyLine_MoveOrigin(self, *args)

   def GetBoundingBox(self, *args):
        """
        GetBoundingBox(CPolyLine self) -> EDA_RECT
        GetBoundingBox(CPolyLine self, int icont) -> EDA_RECT

        EDA_RECT
        CPolyLine::GetBoundingBox(int icont)

        the bounding box of a given polygon

        Parameters:
        -----------

        icont:  = the index of the polygon contour (0 = main contour, 1 ... n
        = other contours, usually holes)
        """
        return _pcbnew.CPolyLine_GetBoundingBox(self, *args)

   def Copy(self, *args):
        """
        Copy(CPolyLine self, CPolyLine src)

        void CPolyLine::Copy(const
        CPolyLine *src)
        """
        return _pcbnew.CPolyLine_Copy(self, *args)

   def TestPointInside(self, *args):
        """
        TestPointInside(CPolyLine self, int x, int y) -> bool

        bool
        CPolyLine::TestPointInside(int x, int y)
        """
        return _pcbnew.CPolyLine_TestPointInside(self, *args)

   def IsCutoutContour(self, *args):
        """
        IsCutoutContour(CPolyLine self, int aCornerIdx) -> bool

        bool
        CPolyLine::IsCutoutContour(int aCornerIdx)

        true if the corner aCornerIdx is on a hole inside the main outline and
        false if it is on the main outline
        """
        return _pcbnew.CPolyLine_IsCutoutContour(self, *args)

   def AppendArc(self, *args):
        """
        AppendArc(CPolyLine self, int xi, int yi, int xf, int yf, int xc, int yc, int num)

        void
        CPolyLine::AppendArc(int xi, int yi, int xf, int yf, int xc, int yc,
        int num)

        Function AppendArc.

        Adds segments to current contour to approximate the given arc
        """
        return _pcbnew.CPolyLine_AppendArc(self, *args)

   def SetLayer(self, *args):
        """
        SetLayer(CPolyLine self, LAYER_NUM aLayer)

        void
        CPolyLine::SetLayer(LAYER_NUM aLayer)
        """
        return _pcbnew.CPolyLine_SetLayer(self, *args)

   def GetLayer(self):
        """
        GetLayer(CPolyLine self) -> LAYER_NUM

        LAYER_NUM
        CPolyLine::GetLayer() const
        """
        return _pcbnew.CPolyLine_GetLayer(self)

   def GetCornersCount(self):
        """
        GetCornersCount(CPolyLine self) -> int

        int
        CPolyLine::GetCornersCount() const
        """
        return _pcbnew.CPolyLine_GetCornersCount(self)

   def GetClosed(self):
        """
        GetClosed(CPolyLine self) -> int

        int
        CPolyLine::GetClosed()
        """
        return _pcbnew.CPolyLine_GetClosed(self)

   def GetContoursCount(self):
        """
        GetContoursCount(CPolyLine self) -> int

        int
        CPolyLine::GetContoursCount()
        """
        return _pcbnew.CPolyLine_GetContoursCount(self)

   def GetContour(self, *args):
        """
        GetContour(CPolyLine self, int ic) -> int

        int
        CPolyLine::GetContour(int ic)
        """
        return _pcbnew.CPolyLine_GetContour(self, *args)

   def GetContourStart(self, *args):
        """
        GetContourStart(CPolyLine self, int icont) -> int

        int
        CPolyLine::GetContourStart(int icont)
        """
        return _pcbnew.CPolyLine_GetContourStart(self, *args)

   def GetContourEnd(self, *args):
        """
        GetContourEnd(CPolyLine self, int icont) -> int

        int
        CPolyLine::GetContourEnd(int icont)
        """
        return _pcbnew.CPolyLine_GetContourEnd(self, *args)

   def GetContourSize(self, *args):
        """
        GetContourSize(CPolyLine self, int icont) -> int

        int
        CPolyLine::GetContourSize(int icont)
        """
        return _pcbnew.CPolyLine_GetContourSize(self, *args)

   def GetX(self, *args):
        """
        GetX(CPolyLine self, int ic) -> int

        int CPolyLine::GetX(int ic)
        const
        """
        return _pcbnew.CPolyLine_GetX(self, *args)

   def GetY(self, *args):
        """
        GetY(CPolyLine self, int ic) -> int

        int CPolyLine::GetY(int ic)
        const
        """
        return _pcbnew.CPolyLine_GetY(self, *args)

   def IsEndContour(self, *args):
        """
        IsEndContour(CPolyLine self, int ic) -> bool

        bool
        CPolyLine::IsEndContour(int ic) const
        """
        return _pcbnew.CPolyLine_IsEndContour(self, *args)

   def GetPos(self, *args):
        """
        GetPos(CPolyLine self, int ic) -> wxPoint

        const wxPoint&
        CPolyLine::GetPos(int ic) const
        """
        return _pcbnew.CPolyLine_GetPos(self, *args)

   def GetEndContour(self, *args):
        """
        GetEndContour(CPolyLine self, int ic) -> int

        int
        CPolyLine::GetEndContour(int ic)
        """
        return _pcbnew.CPolyLine_GetEndContour(self, *args)

   def GetUtility(self, *args):
        """
        GetUtility(CPolyLine self, int ic) -> int

        int
        CPolyLine::GetUtility(int ic) const
        """
        return _pcbnew.CPolyLine_GetUtility(self, *args)

   def SetUtility(self, *args):
        """
        SetUtility(CPolyLine self, int ic, int aFlag)

        void
        CPolyLine::SetUtility(int ic, int aFlag)
        """
        return _pcbnew.CPolyLine_SetUtility(self, *args)

   def GetHatchPitch(self):
        """
        GetHatchPitch(CPolyLine self) -> int

        int
        CPolyLine::GetHatchPitch() const
        """
        return _pcbnew.CPolyLine_GetHatchPitch(self)

   def GetDefaultHatchPitchMils():
        """GetDefaultHatchPitchMils() -> int"""
        return _pcbnew.CPolyLine_GetDefaultHatchPitchMils()

    if _newclass:GetDefaultHatchPitchMils = staticmethod(GetDefaultHatchPitchMils)
    __swig_getmethods__["GetDefaultHatchPitchMils"] = lambda x: GetDefaultHatchPitchMils
   def GetHatchStyle(self):
        """
        GetHatchStyle(CPolyLine self) -> enum CPolyLine::HATCH_STYLE

        enum HATCH_STYLE
        CPolyLine::GetHatchStyle() const
        """
        return _pcbnew.CPolyLine_GetHatchStyle(self)

   def SetHatch(self, *args):
        """
        SetHatch(CPolyLine self, int aHatchStyle, int aHatchPitch, bool aRebuildHatch)

        void
        CPolyLine::SetHatch(int aHatchStyle, int aHatchPitch, bool
        aRebuildHatch)
        """
        return _pcbnew.CPolyLine_SetHatch(self, *args)

   def SetX(self, *args):
        """
        SetX(CPolyLine self, int ic, int x)

        void CPolyLine::SetX(int ic,
        int x)
        """
        return _pcbnew.CPolyLine_SetX(self, *args)

   def SetY(self, *args):
        """
        SetY(CPolyLine self, int ic, int y)

        void CPolyLine::SetY(int ic,
        int y)
        """
        return _pcbnew.CPolyLine_SetY(self, *args)

   def SetEndContour(self, *args):
        """
        SetEndContour(CPolyLine self, int ic, bool end_contour)

        void
        CPolyLine::SetEndContour(int ic, bool end_contour)
        """
        return _pcbnew.CPolyLine_SetEndContour(self, *args)

   def SetHatchStyle(self, *args):
        """
        SetHatchStyle(CPolyLine self, enum CPolyLine::HATCH_STYLE style)

        void
        CPolyLine::SetHatchStyle(enum HATCH_STYLE style)
        """
        return _pcbnew.CPolyLine_SetHatchStyle(self, *args)

   def SetHatchPitch(self, *args):
        """
        SetHatchPitch(CPolyLine self, int pitch)

        void
        CPolyLine::SetHatchPitch(int pitch)
        """
        return _pcbnew.CPolyLine_SetHatchPitch(self, *args)

   def NormalizeAreaOutlines(self, *args):
        """
        NormalizeAreaOutlines(CPolyLine self, std::vector< CPolyLine *,std::allocator< CPolyLine * > > * aNewPolygonList) -> int

        int
        CPolyLine::NormalizeAreaOutlines(std::vector< CPolyLine * >
        *aNewPolygonList)

        Function NormalizeAreaOutlines Convert a self-intersecting polygon to
        one (or more) non self-intersecting polygon(s)

        Parameters:
        -----------

        aNewPolygonList:  = a std::vector<CPolyLine*> reference where to store
        new CPolyLine needed by the normalization

        the polygon count (always >= 1, because there is at least one polygon)
        There are new polygons only if the polygon count is > 1
        """
        return _pcbnew.CPolyLine_NormalizeAreaOutlines(self, *args)

   def AppendBezier(self, *args):
        """
        AppendBezier(CPolyLine self, int x1, int y1, int x2, int y2, int x3, int y3)
        AppendBezier(CPolyLine self, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)

        void
        CPolyLine::AppendBezier(int x1, int y1, int x2, int y2, int x3, int
        y3, int x4, int y4)
        """
        return _pcbnew.CPolyLine_AppendBezier(self, *args)

   def Distance(self, *args):
        """
        Distance(CPolyLine self, wxPoint aPoint) -> int
        Distance(CPolyLine self, wxPoint aStart, wxPoint aEnd, int aWidth) -> int

        int
        CPolyLine::Distance(wxPoint aStart, wxPoint aEnd, int aWidth)

        Function Distance Calculates the distance between a segment and the
        zone:

        Parameters:
        -----------

        aStart:  the starting point of the segment.

        aEnd:  the ending point of the segment.

        aWidth:  the width of the segment.

        int = distance between the segment and outline. 0 if segment
        intersects or is inside
        """
        return _pcbnew.CPolyLine_Distance(self, *args)

   def HitTestForEdge(self, *args):
        """
        HitTestForEdge(CPolyLine self, wxPoint aPos, int aDistMax) -> int

        int
        CPolyLine::HitTestForEdge(const wxPoint &aPos, int aDistMax) const

        Function HitTestForEdge test is the point aPos is near (< aDistMax ) a
        vertex.

        Parameters:
        -----------

        aPos:  = the reference point

        aDistMax:  = the max distance between a vertex and the reference point

        int = the index of the first corner of the vertex, or -1 if not found.

        """
        return _pcbnew.CPolyLine_HitTestForEdge(self, *args)

   def HitTestForCorner(self, *args):
        """
        HitTestForCorner(CPolyLine self, wxPoint aPos, int aDistMax) -> int

        int
        CPolyLine::HitTestForCorner(const wxPoint &aPos, int aDistMax) const

        Function HitTestForCorner test is the point aPos is near (< aDistMax )
        a corner.

        Parameters:
        -----------

        aPos:  = the reference point

        aDistMax:  = the max distance between a vertex and the corner

        int = the index of corner of the, or -1 if not found.
        """
        return _pcbnew.CPolyLine_HitTestForCorner(self, *args)

    __swig_setmethods__["m_CornersList"] = _pcbnew.CPolyLine_m_CornersList_set
    __swig_getmethods__["m_CornersList"] = _pcbnew.CPolyLine_m_CornersList_get
    if _newclass:m_CornersList = _swig_property(_pcbnew.CPolyLine_m_CornersList_get, _pcbnew.CPolyLine_m_CornersList_set)
    __swig_setmethods__["m_HatchLines"] = _pcbnew.CPolyLine_m_HatchLines_set
    __swig_getmethods__["m_HatchLines"] = _pcbnew.CPolyLine_m_HatchLines_get
    if _newclass:m_HatchLines = _swig_property(_pcbnew.CPolyLine_m_HatchLines_get, _pcbnew.CPolyLine_m_HatchLines_set)
CPolyLine_swigregister = _pcbnew.CPolyLine_swigregister
CPolyLine_swigregister(CPolyLine)

def CPolyLine_GetDefaultHatchPitchMils():
  """CPolyLine_GetDefaultHatchPitchMils() -> int"""
  return _pcbnew.CPolyLine_GetDefaultHatchPitchMils()


def ConvertPolysListWithHolesToOnePolygon(*args):
  """ConvertPolysListWithHolesToOnePolygon(CPOLYGONS_LIST aPolysListWithHoles, CPOLYGONS_LIST aOnePolyList)"""
  return _pcbnew.ConvertPolysListWithHolesToOnePolygon(*args)

def ConvertOnePolygonToPolysListWithHoles(*args):
  """ConvertOnePolygonToPolysListWithHoles(CPOLYGONS_LIST aOnePolyList, CPOLYGONS_LIST aPolysListWithHoles)"""
  return _pcbnew.ConvertOnePolygonToPolysListWithHoles(*args)
class UTF8(_object):
    """
    Class UTF8 is an 8 bit std::string that is assuredly encoded in UTF8,
    and supplies special conversion support to and from wxString, and has
    iteration over unicode characters.

    I've been careful to supply only conversion facilities and not try and
    duplicate wxString() with many member functions. In the end it is to
    be a std::string. There are multiple ways to create text into a
    std::string without the need of too many member functions:

    richio.h's StrPrintf()

    std::ostringstream.

    Because this class used no virtuals, it should be possible to cast any
    std::string into a UTF8 using this kind of cast: ( UTF8 &) without
    construction or copying being the effect of the cast. Be sure the
    source std::string holds UTF8 encoded text before you do that.

    Dick Hollenbeck

    C++ includes: utf8.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UTF8, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UTF8, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(UTF8 self, wxString const & o) -> UTF8
        __init__(UTF8 self, char const * txt) -> UTF8
        __init__(UTF8 self, wchar_t const * txt) -> UTF8
        __init__(UTF8 self, std::string const & o) -> UTF8
        __init__(UTF8 self) -> UTF8

        UTF8::UTF8()
        """
        this = _pcbnew.new_UTF8(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_UTF8
    __del__ = lambda self : None;
   def substr(self, *args):
        """
        substr(UTF8 self, size_t pos=0, size_t len=npos) -> UTF8
        substr(UTF8 self, size_t pos=0) -> UTF8
        substr(UTF8 self) -> UTF8

        UTF8 UTF8::substr(size_t pos=0,
        size_t len=npos) const
        """
        return _pcbnew.UTF8_substr(self, *args)

   def utf8_to_wxstring(self):
        """utf8_to_wxstring(UTF8 self) -> wxString"""
        return _pcbnew.UTF8_utf8_to_wxstring(self)

   def utf8_to_charptr(self):
        """utf8_to_charptr(UTF8 self) -> char *"""
        return _pcbnew.UTF8_utf8_to_charptr(self)

   def uni_forward(*args):
        """
        uni_forward(unsigned char const * aSequence, unsigned int * aResult=None) -> int
        uni_forward(unsigned char const * aSequence) -> int
        """
        return _pcbnew.UTF8_uni_forward(*args)

    if _newclass:uni_forward = staticmethod(uni_forward)
    __swig_getmethods__["uni_forward"] = lambda x: uni_forward
   def ubegin(self):
        """
        ubegin(UTF8 self) -> UTF8::uni_iter

        uni_iter UTF8::ubegin() const

        Function ubegin returns a  uni_iter initialized to the start of
        "this" UTF8 byte sequence.
        """
        return _pcbnew.UTF8_ubegin(self)

   def uend(self):
        """
        uend(UTF8 self) -> UTF8::uni_iter

        uni_iter UTF8::uend() const

        Function uend returns a  uni_iter initialized to the end of "this"
        UTF8 byte sequence.
        """
        return _pcbnew.UTF8_uend(self)

   def Cast_to_CChar(self):
        """Cast_to_CChar(UTF8 self) -> char const *"""
        return _pcbnew.UTF8_Cast_to_CChar(self)

   def GetChars(self):
        return self.Cast_to_CChar()



   def __str__(self):
        return self.GetChars()


UTF8_swigregister = _pcbnew.UTF8_swigregister
UTF8_swigregister(UTF8)

def UTF8_uni_forward(*args):
  """
    uni_forward(unsigned char const * aSequence, unsigned int * aResult=None) -> int
    UTF8_uni_forward(unsigned char const * aSequence) -> int
    """
  return _pcbnew.UTF8_uni_forward(*args)

S_SEGMENT = _pcbnew.S_SEGMENT
S_RECT = _pcbnew.S_RECT
S_ARC = _pcbnew.S_ARC
S_CIRCLE = _pcbnew.S_CIRCLE
S_POLYGON = _pcbnew.S_POLYGON
S_CURVE = _pcbnew.S_CURVE
S_LAST = _pcbnew.S_LAST
class BOARD_ITEM(EDA_ITEM):
    """
    Class BOARD_ITEM is a base class for any item which can be embedded
    within the BOARD container class, and therefore instances of derived
    classes should only be found in Pcbnew or other programs that use
    class BOARD and its contents.

    The corresponding class in Eeschema is SCH_ITEM.

    C++ includes: class_board_item.h
    """
    __swig_setmethods__ = {}
    for _s in [EDA_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOARD_ITEM, name, value)
    __swig_getmethods__ = {}
    for _s in [EDA_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BOARD_ITEM, name)
   def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
   def GetPosition(self):
        """
        GetPosition(BOARD_ITEM self) -> wxPoint

        virtual const
        wxPoint& BOARD_ITEM::GetPosition() const =0
        """
        return _pcbnew.BOARD_ITEM_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(BOARD_ITEM self, wxPoint aPos)

        virtual void
        BOARD_ITEM::SetPosition(const wxPoint &aPos)=0
        """
        return _pcbnew.BOARD_ITEM_SetPosition(self, *args)

   def IsConnected(self):
        """
        IsConnected(BOARD_ITEM self) -> bool

        virtual bool
        BOARD_ITEM::IsConnected() const

        Function IsConnected() Returns information if the object is derived
        from BOARD_CONNECTED_ITEM.

        True if the object is of BOARD_CONNECTED_ITEM type, false otherwise.

        """
        return _pcbnew.BOARD_ITEM_IsConnected(self)

   def Next(self):
        """
        Next(BOARD_ITEM self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::Next() const
        """
        return _pcbnew.BOARD_ITEM_Next(self)

   def Back(self):
        """
        Back(BOARD_ITEM self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::Back() const
        """
        return _pcbnew.BOARD_ITEM_Back(self)

   def GetParent(self):
        """
        GetParent(BOARD_ITEM self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::GetParent() const
        """
        return _pcbnew.BOARD_ITEM_GetParent(self)

   def GetLayer(self):
        """
        GetLayer(BOARD_ITEM self) -> LAYER_ID

        LAYER_ID
        BOARD_ITEM::GetLayer() const

        Function GetLayer returns the layer this item is on.
        """
        return _pcbnew.BOARD_ITEM_GetLayer(self)

   def SetLayer(self, *args):
        """
        SetLayer(BOARD_ITEM self, LAYER_ID aLayer)

        virtual void
        BOARD_ITEM::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.BOARD_ITEM_SetLayer(self, *args)

   def Draw(self, *args):
        """
        Draw(BOARD_ITEM self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(BOARD_ITEM self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        virtual void
        BOARD_ITEM::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset=ZeroOffset)=0

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.BOARD_ITEM_Draw(self, *args)

   def SwapData(self, *args):
        """
        SwapData(BOARD_ITEM self, BOARD_ITEM aImage)

        void
        BOARD_ITEM::SwapData(BOARD_ITEM *aImage)

        Swap data between aItem and aImage.

        aItem and aImage should have the same type Used in undo redo command
        to swap values between an item and its copy Only values like layer,
        size .. which are modified by edition are swapped, not the pointers
        like Pnext and Pback because aItem is not changed in the linked list

        Parameters:
        -----------

        aImage:  = the item image which contains data to swap
        """
        return _pcbnew.BOARD_ITEM_SwapData(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(BOARD_ITEM self, LAYER_ID aLayer) -> bool

        virtual bool
        BOARD_ITEM::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.BOARD_ITEM_IsOnLayer(self, *args)

   def IsTrack(self):
        """
        IsTrack(BOARD_ITEM self) -> bool

        bool
        BOARD_ITEM::IsTrack() const

        Function IsTrack tests to see if this object is a track or via (or
        microvia).

        form of testing. bool - true if a track or via, else false.
        """
        return _pcbnew.BOARD_ITEM_IsTrack(self)

   def IsLocked(self):
        """
        IsLocked(BOARD_ITEM self) -> bool

        virtual bool
        BOARD_ITEM::IsLocked() const

        Function IsLocked.

        bool - true if the object is locked, else false
        """
        return _pcbnew.BOARD_ITEM_IsLocked(self)

   def UnLink(self):
        """
        UnLink(BOARD_ITEM self)

        void BOARD_ITEM::UnLink()

        Function UnLink detaches this object from its owner.

        This base class implementation should work for all derived classes
        which are held in a DLIST<>.
        """
        return _pcbnew.BOARD_ITEM_UnLink(self)

   def DeleteStructure(self):
        """
        DeleteStructure(BOARD_ITEM self)

        void
        BOARD_ITEM::DeleteStructure()

        Function DeleteStructure deletes this object after UnLink()ing it from
        its owner if it has one.
        """
        return _pcbnew.BOARD_ITEM_DeleteStructure(self)

   def ShowShape(*args):
        """ShowShape(STROKE_T aShape) -> wxString"""
        return _pcbnew.BOARD_ITEM_ShowShape(*args)

    if _newclass:ShowShape = staticmethod(ShowShape)
    __swig_getmethods__["ShowShape"] = lambda x: ShowShape
   def Move(self, *args):
        """
        Move(BOARD_ITEM self, wxPoint aMoveVector)

        virtual void
        BOARD_ITEM::Move(const wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.BOARD_ITEM_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(BOARD_ITEM self, wxPoint aRotCentre, double aAngle)

        virtual void
        BOARD_ITEM::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.BOARD_ITEM_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(BOARD_ITEM self, wxPoint aCentre)

        virtual void
        BOARD_ITEM::Flip(const wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.BOARD_ITEM_Flip(self, *args)

   def GetBoard(self):
        """
        GetBoard(BOARD_ITEM self) -> BOARD

        BOARD *
        BOARD_ITEM::GetBoard() const

        Function GetBoard returns the BOARD in which this BOARD_ITEM resides,
        or NULL if none.
        """
        return _pcbnew.BOARD_ITEM_GetBoard(self)

   def GetLayerName(self):
        """
        GetLayerName(BOARD_ITEM self) -> wxString

        wxString
        BOARD_ITEM::GetLayerName() const

        Function GetLayerName returns the name of the PCB layer on which the
        item resides.

        wxString containing the layer name associated with this item.
        """
        return _pcbnew.BOARD_ITEM_GetLayerName(self)

   def HitTest(self, *args):
        """
        HitTest(BOARD_ITEM self, wxPoint aPosition) -> bool
        HitTest(BOARD_ITEM self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(BOARD_ITEM self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(BOARD_ITEM self, EDA_RECT aRect) -> bool

        virtual bool
        BOARD_ITEM::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Function HitTest tests if the aRect intersects or contains this object
        (depending on aContained).

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.BOARD_ITEM_HitTest(self, *args)

   def FormatAngle(*args):
        """FormatAngle(double aAngle) -> std::string"""
        return _pcbnew.BOARD_ITEM_FormatAngle(*args)

    if _newclass:FormatAngle = staticmethod(FormatAngle)
    __swig_getmethods__["FormatAngle"] = lambda x: FormatAngle
   def FormatInternalUnits(*args):
        """
        FormatInternalUnits(int aValue) -> std::string
        FormatInternalUnits(wxPoint aPoint) -> std::string
        FormatInternalUnits(wxSize aSize) -> std::string
        """
        return _pcbnew.BOARD_ITEM_FormatInternalUnits(*args)

    if _newclass:FormatInternalUnits = staticmethod(FormatInternalUnits)
    __swig_getmethods__["FormatInternalUnits"] = lambda x: FormatInternalUnits
   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(BOARD_ITEM self, int [] aLayers, int & aCount)

        void
        BOARD_ITEM::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.BOARD_ITEM_ViewGetLayers(self, *args)

   def Cast_to_TEXTE_PCB(self):
        """Cast_to_TEXTE_PCB(BOARD_ITEM self) -> TEXTE_PCB"""
        return _pcbnew.BOARD_ITEM_Cast_to_TEXTE_PCB(self)

   def Cast_to_DIMENSION(self):
        """Cast_to_DIMENSION(BOARD_ITEM self) -> DIMENSION"""
        return _pcbnew.BOARD_ITEM_Cast_to_DIMENSION(self)

   def Cast_to_MODULE(self):
        """Cast_to_MODULE(BOARD_ITEM self) -> MODULE"""
        return _pcbnew.BOARD_ITEM_Cast_to_MODULE(self)

   def Cast_to_TEXTE_MODULE(self):
        """Cast_to_TEXTE_MODULE(BOARD_ITEM self) -> TEXTE_MODULE"""
        return _pcbnew.BOARD_ITEM_Cast_to_TEXTE_MODULE(self)

   def Cast_to_DRAWSEGMENT(self):
        """Cast_to_DRAWSEGMENT(BOARD_ITEM self) -> DRAWSEGMENT"""
        return _pcbnew.BOARD_ITEM_Cast_to_DRAWSEGMENT(self)

   def Cast_to_MARKER_PCB(self):
        """Cast_to_MARKER_PCB(BOARD_ITEM self) -> MARKER_PCB"""
        return _pcbnew.BOARD_ITEM_Cast_to_MARKER_PCB(self)

   def Cast_to_BOARD(self):
        """Cast_to_BOARD(BOARD_ITEM self) -> BOARD"""
        return _pcbnew.BOARD_ITEM_Cast_to_BOARD(self)

   def Cast_to_EDGE_MODULE(self):
        """Cast_to_EDGE_MODULE(BOARD_ITEM self) -> EDGE_MODULE"""
        return _pcbnew.BOARD_ITEM_Cast_to_EDGE_MODULE(self)

   def Cast_to_D_PAD(self):
        """Cast_to_D_PAD(BOARD_ITEM self) -> D_PAD"""
        return _pcbnew.BOARD_ITEM_Cast_to_D_PAD(self)

   def Cast_to_TRACK(self):
        """Cast_to_TRACK(BOARD_ITEM self) -> TRACK"""
        return _pcbnew.BOARD_ITEM_Cast_to_TRACK(self)

   def Cast_to_VIA(self):
        """Cast_to_VIA(BOARD_ITEM self) -> VIA"""
        return _pcbnew.BOARD_ITEM_Cast_to_VIA(self)

   def Cast_to_ZONE_CONTAINER(self):
        """Cast_to_ZONE_CONTAINER(BOARD_ITEM self) -> ZONE_CONTAINER"""
        return _pcbnew.BOARD_ITEM_Cast_to_ZONE_CONTAINER(self)

   def Cast_to_PCB_TARGET(self):
        """Cast_to_PCB_TARGET(BOARD_ITEM self) -> PCB_TARGET"""
        return _pcbnew.BOARD_ITEM_Cast_to_PCB_TARGET(self)

   def Cast(self):

        ct = self.GetClass()

        if ct=="PTEXT":
            return self.Cast_to_TEXTE_PCB()
        elif ct=="BOARD":
            return self.Cast_to_BOARD()
        elif ct=="DIMENSION":
            return self.Cast_to_DIMENSION()
        elif ct=="DRAWSEGMENT":
            return self.Cast_to_DRAWSEGMENT()
        elif ct=="MGRAPHIC":
            return self.Cast_to_EDGE_MODULE()
        elif ct=="MODULE":
            return self.Cast_to_MODULE()
        elif ct=="PAD":
            return self.Cast_to_D_PAD()
        elif ct=="MTEXT":
            return self.Cast_to_TEXTE_MODULE()
        elif ct=="VIA":
            return self.Cast_to_VIA()
        elif ct=="TRACK":
            return self.Cast_to_TRACK()
        elif ct=="PCB_TARGET":
            return self.Cast_to_PCB_TARGET()
        elif ct=="ZONE_CONTAINER":
            return self.Cast_to_ZONE_CONTAINER()
        else:
            return None


   def Duplicate(self):

        ct = self.GetClass()

        if ct=="BOARD":
            return None
        else:
            return Cast_to_BOARD_ITEM(self.Clone()).Cast()

   def SetPos(self,p):
        self.SetPosition(p)
        self.SetPos0(p)

   def SetStartEnd(self,start,end):
        self.SetStart(start)
        self.SetStart0(start)
        self.SetEnd(end)
        self.SetEnd0(end)

    __swig_destroy__ = _pcbnew.delete_BOARD_ITEM
    __del__ = lambda self : None;
BOARD_ITEM_swigregister = _pcbnew.BOARD_ITEM_swigregister
BOARD_ITEM_swigregister(BOARD_ITEM)

def BOARD_ITEM_ShowShape(*args):
  """BOARD_ITEM_ShowShape(STROKE_T aShape) -> wxString"""
  return _pcbnew.BOARD_ITEM_ShowShape(*args)

def BOARD_ITEM_FormatAngle(*args):
  """BOARD_ITEM_FormatAngle(double aAngle) -> std::string"""
  return _pcbnew.BOARD_ITEM_FormatAngle(*args)

def BOARD_ITEM_FormatInternalUnits(*args):
  """
    FormatInternalUnits(int aValue) -> std::string
    FormatInternalUnits(wxPoint aPoint) -> std::string
    BOARD_ITEM_FormatInternalUnits(wxSize aSize) -> std::string
    """
  return _pcbnew.BOARD_ITEM_FormatInternalUnits(*args)

class BOARD_CONNECTED_ITEM(BOARD_ITEM):
    """
    Class BOARD_CONNECTED_ITEM is a base class derived from BOARD_ITEM for
    items that can be connected and have a net, a netname, a clearance ...

    mainly: tracks, pads and zones Handle connection info

    C++ includes: class_board_connected_item.h
    """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOARD_CONNECTED_ITEM, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BOARD_CONNECTED_ITEM, name)
   def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_setmethods__["m_TracksConnected"] = _pcbnew.BOARD_CONNECTED_ITEM_m_TracksConnected_set
    __swig_getmethods__["m_TracksConnected"] = _pcbnew.BOARD_CONNECTED_ITEM_m_TracksConnected_get
    if _newclass:m_TracksConnected = _swig_property(_pcbnew.BOARD_CONNECTED_ITEM_m_TracksConnected_get, _pcbnew.BOARD_CONNECTED_ITEM_m_TracksConnected_set)
    __swig_setmethods__["m_PadsConnected"] = _pcbnew.BOARD_CONNECTED_ITEM_m_PadsConnected_set
    __swig_getmethods__["m_PadsConnected"] = _pcbnew.BOARD_CONNECTED_ITEM_m_PadsConnected_get
    if _newclass:m_PadsConnected = _swig_property(_pcbnew.BOARD_CONNECTED_ITEM_m_PadsConnected_get, _pcbnew.BOARD_CONNECTED_ITEM_m_PadsConnected_set)
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.BOARD_CONNECTED_ITEM_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
   def IsConnected(self):
        """
        IsConnected(BOARD_CONNECTED_ITEM self) -> bool

        bool
        BOARD_CONNECTED_ITEM::IsConnected() const

        >

        Function IsConnected() Returns information if the object is derived
        from BOARD_CONNECTED_ITEM. True if the object is of
        BOARD_CONNECTED_ITEM type, false otherwise.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_IsConnected(self)

   def GetNet(self):
        """
        GetNet(BOARD_CONNECTED_ITEM self) -> NETINFO_ITEM

        NETINFO_ITEM*
        BOARD_CONNECTED_ITEM::GetNet() const

        Function GetNet Returns NET_INFO object for a given item.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetNet(self)

   def GetNetCode(self):
        """
        GetNetCode(BOARD_CONNECTED_ITEM self) -> int

        int
        BOARD_CONNECTED_ITEM::GetNetCode() const

        Function GetNetCode.

        int - the net code.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetNetCode(self)

   def SetNetCode(self, *args):
        """
        SetNetCode(BOARD_CONNECTED_ITEM self, int aNetCode)

        void
        BOARD_CONNECTED_ITEM::SetNetCode(int aNetCode)

        Function SetNetCode sets net using a net code.

        Parameters:
        -----------

        aNetCode:  is a net code for the new net. It has to exist in
        NETINFO_LIST held by BOARD. Otherwise, item is assigned to the
        unconnected net.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_SetNetCode(self, *args)

   def GetSubNet(self):
        """
        GetSubNet(BOARD_CONNECTED_ITEM self) -> int

        int
        BOARD_CONNECTED_ITEM::GetSubNet() const

        Function GetSubNet.

        int - the sub net code.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetSubNet(self)

   def SetSubNet(self, *args):
        """
        SetSubNet(BOARD_CONNECTED_ITEM self, int aSubNetCode)

        void
        BOARD_CONNECTED_ITEM::SetSubNet(int aSubNetCode)
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_SetSubNet(self, *args)

   def GetZoneSubNet(self):
        """
        GetZoneSubNet(BOARD_CONNECTED_ITEM self) -> int

        int
        BOARD_CONNECTED_ITEM::GetZoneSubNet() const

        Function GetZoneSubNet.

        int - the sub net code in zone connections.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetZoneSubNet(self)

   def SetZoneSubNet(self, *args):
        """
        SetZoneSubNet(BOARD_CONNECTED_ITEM self, int aSubNetCode)

        void
        BOARD_CONNECTED_ITEM::SetZoneSubNet(int aSubNetCode)
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_SetZoneSubNet(self, *args)

   def GetNetname(self):
        """
        GetNetname(BOARD_CONNECTED_ITEM self) -> wxString const &

        const
        wxString& BOARD_CONNECTED_ITEM::GetNetname() const

        Function GetNetname.

        wxString - the full netname
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetNetname(self)

   def GetShortNetname(self):
        """
        GetShortNetname(BOARD_CONNECTED_ITEM self) -> wxString const &

        const
        wxString& BOARD_CONNECTED_ITEM::GetShortNetname() const

        Function GetShortNetname.

        wxString - the short netname
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetShortNetname(self)

   def GetClearance(self, aItem=None):
        """
        GetClearance(BOARD_CONNECTED_ITEM self, BOARD_CONNECTED_ITEM aItem=None) -> int
        GetClearance(BOARD_CONNECTED_ITEM self) -> int

        int
        BOARD_CONNECTED_ITEM::GetClearance(BOARD_CONNECTED_ITEM *aItem=NULL)
        const

        Function GetClearance returns the clearance in 1/10000 inches.

        If aItem is not NULL then the returned clearance is the greater of
        this object's NETCLASS clearance and aItem's NETCLASS clearance. If
        aItem is NULL, then this objects clearance is returned.

        Parameters:
        -----------

        aItem:  is another BOARD_CONNECTED_ITEM or NULL

        int - the clearance in 1/10000 inches.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetClearance(self, aItem)

   def GetNetClass(self):
        """
        GetNetClass(BOARD_CONNECTED_ITEM self) -> boost::shared_ptr< NETCLASS >

        NETCLASSPTR
        BOARD_CONNECTED_ITEM::GetNetClass() const

        Function GetNetClass returns the NETCLASS for this item.
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetNetClass(self)

   def GetNetClassName(self):
        """
        GetNetClassName(BOARD_CONNECTED_ITEM self) -> wxString

        wxString BOARD_CONNECTED_ITEM::GetNetClassName() const

        Function GetNetClassName returns a pointer to the netclass of the
        zone.

        If the net is not found (can happen when a netlist is reread, and the
       net name does not exist, return the default net class (should not
        return a null pointer). the Net Class name of this item
        """
        return _pcbnew.BOARD_CONNECTED_ITEM_GetNetClassName(self)

    __swig_destroy__ = _pcbnew.delete_BOARD_CONNECTED_ITEM
    __del__ = lambda self : None;
BOARD_CONNECTED_ITEM_swigregister = _pcbnew.BOARD_CONNECTED_ITEM_swigregister
BOARD_CONNECTED_ITEM_swigregister(BOARD_CONNECTED_ITEM)

def BOARD_CONNECTED_ITEM_ClassOf(*args):
  """BOARD_CONNECTED_ITEM_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.BOARD_CONNECTED_ITEM_ClassOf(*args)

class VIA_DIMENSION(_object):
    """Proxy of C++ VIA_DIMENSION class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VIA_DIMENSION, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VIA_DIMENSION, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_Diameter"] = _pcbnew.VIA_DIMENSION_m_Diameter_set
    __swig_getmethods__["m_Diameter"] = _pcbnew.VIA_DIMENSION_m_Diameter_get
    if _newclass:m_Diameter = _swig_property(_pcbnew.VIA_DIMENSION_m_Diameter_get, _pcbnew.VIA_DIMENSION_m_Diameter_set)
    __swig_setmethods__["m_Drill"] = _pcbnew.VIA_DIMENSION_m_Drill_set
    __swig_getmethods__["m_Drill"] = _pcbnew.VIA_DIMENSION_m_Drill_get
    if _newclass:m_Drill = _swig_property(_pcbnew.VIA_DIMENSION_m_Drill_get, _pcbnew.VIA_DIMENSION_m_Drill_set)
   def __init__(self, *args):
        """
        __init__(VIA_DIMENSION self) -> VIA_DIMENSION
        __init__(VIA_DIMENSION self, int aDiameter, int aDrill) -> VIA_DIMENSION
        """
        this = _pcbnew.new_VIA_DIMENSION(*args)
        try: self.this.append(this)
        except: self.this = this
   def __eq__(self, *args):
        """__eq__(VIA_DIMENSION self, VIA_DIMENSION aOther) -> bool"""
        return _pcbnew.VIA_DIMENSION___eq__(self, *args)

   def __lt__(self, *args):
        """__lt__(VIA_DIMENSION self, VIA_DIMENSION aOther) -> bool"""
        return _pcbnew.VIA_DIMENSION___lt__(self, *args)

    __swig_destroy__ = _pcbnew.delete_VIA_DIMENSION
    __del__ = lambda self : None;
VIA_DIMENSION_swigregister = _pcbnew.VIA_DIMENSION_swigregister
VIA_DIMENSION_swigregister(VIA_DIMENSION)

class BOARD_DESIGN_SETTINGS(_object):
    """
    Class BOARD_DESIGN_SETTINGS contains design settings for a BOARD
    object.

    C++ includes: class_board_design_settings.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOARD_DESIGN_SETTINGS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BOARD_DESIGN_SETTINGS, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_ViasDimensionsList"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasDimensionsList_set
    __swig_getmethods__["m_ViasDimensionsList"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasDimensionsList_get
    if _newclass:m_ViasDimensionsList = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_ViasDimensionsList_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasDimensionsList_set)
    __swig_setmethods__["m_TrackWidthList"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_TrackWidthList_set
    __swig_getmethods__["m_TrackWidthList"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_TrackWidthList_get
    if _newclass:m_TrackWidthList = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_TrackWidthList_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_TrackWidthList_set)
    __swig_setmethods__["m_NetClasses"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_NetClasses_set
    __swig_getmethods__["m_NetClasses"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_NetClasses_get
    if _newclass:m_NetClasses = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_NetClasses_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_NetClasses_set)
    __swig_setmethods__["m_MicroViasAllowed"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasAllowed_set
    __swig_getmethods__["m_MicroViasAllowed"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasAllowed_get
    if _newclass:m_MicroViasAllowed = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasAllowed_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasAllowed_set)
    __swig_setmethods__["m_BlindBuriedViaAllowed"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_BlindBuriedViaAllowed_set
    __swig_getmethods__["m_BlindBuriedViaAllowed"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_BlindBuriedViaAllowed_get
    if _newclass:m_BlindBuriedViaAllowed = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_BlindBuriedViaAllowed_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_BlindBuriedViaAllowed_set)
    __swig_setmethods__["m_CurrentViaType"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_CurrentViaType_set
    __swig_getmethods__["m_CurrentViaType"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_CurrentViaType_get
    if _newclass:m_CurrentViaType = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_CurrentViaType_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_CurrentViaType_set)
    __swig_setmethods__["m_UseConnectedTrackWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_UseConnectedTrackWidth_set
    __swig_getmethods__["m_UseConnectedTrackWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_UseConnectedTrackWidth_get
    if _newclass:m_UseConnectedTrackWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_UseConnectedTrackWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_UseConnectedTrackWidth_set)
    __swig_setmethods__["m_DrawSegmentWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_DrawSegmentWidth_set
    __swig_getmethods__["m_DrawSegmentWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_DrawSegmentWidth_get
    if _newclass:m_DrawSegmentWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_DrawSegmentWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_DrawSegmentWidth_set)
    __swig_setmethods__["m_EdgeSegmentWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_EdgeSegmentWidth_set
    __swig_getmethods__["m_EdgeSegmentWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_EdgeSegmentWidth_get
    if _newclass:m_EdgeSegmentWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_EdgeSegmentWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_EdgeSegmentWidth_set)
    __swig_setmethods__["m_PcbTextWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextWidth_set
    __swig_getmethods__["m_PcbTextWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextWidth_get
    if _newclass:m_PcbTextWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextWidth_set)
    __swig_setmethods__["m_PcbTextSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextSize_set
    __swig_getmethods__["m_PcbTextSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextSize_get
    if _newclass:m_PcbTextSize = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextSize_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_PcbTextSize_set)
    __swig_setmethods__["m_TrackMinWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_TrackMinWidth_set
    __swig_getmethods__["m_TrackMinWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_TrackMinWidth_get
    if _newclass:m_TrackMinWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_TrackMinWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_TrackMinWidth_set)
    __swig_setmethods__["m_ViasMinSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinSize_set
    __swig_getmethods__["m_ViasMinSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinSize_get
    if _newclass:m_ViasMinSize = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinSize_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinSize_set)
    __swig_setmethods__["m_ViasMinDrill"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinDrill_set
    __swig_getmethods__["m_ViasMinDrill"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinDrill_get
    if _newclass:m_ViasMinDrill = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinDrill_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_ViasMinDrill_set)
    __swig_setmethods__["m_MicroViasMinSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinSize_set
    __swig_getmethods__["m_MicroViasMinSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinSize_get
    if _newclass:m_MicroViasMinSize = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinSize_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinSize_set)
    __swig_setmethods__["m_MicroViasMinDrill"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinDrill_set
    __swig_getmethods__["m_MicroViasMinDrill"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinDrill_get
    if _newclass:m_MicroViasMinDrill = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinDrill_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_MicroViasMinDrill_set)
    __swig_setmethods__["m_SolderMaskMargin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMargin_set
    __swig_getmethods__["m_SolderMaskMargin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMargin_get
    if _newclass:m_SolderMaskMargin = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMargin_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMargin_set)
    __swig_setmethods__["m_SolderMaskMinWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMinWidth_set
    __swig_getmethods__["m_SolderMaskMinWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMinWidth_get
    if _newclass:m_SolderMaskMinWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMinWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderMaskMinWidth_set)
    __swig_setmethods__["m_SolderPasteMargin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMargin_set
    __swig_getmethods__["m_SolderPasteMargin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMargin_get
    if _newclass:m_SolderPasteMargin = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMargin_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMargin_set)
    __swig_setmethods__["m_SolderPasteMarginRatio"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMarginRatio_set
    __swig_getmethods__["m_SolderPasteMarginRatio"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMarginRatio_get
    if _newclass:m_SolderPasteMarginRatio = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMarginRatio_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_SolderPasteMarginRatio_set)
    __swig_setmethods__["m_ModuleTextSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextSize_set
    __swig_getmethods__["m_ModuleTextSize"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextSize_get
    if _newclass:m_ModuleTextSize = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextSize_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextSize_set)
    __swig_setmethods__["m_ModuleTextWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextWidth_set
    __swig_getmethods__["m_ModuleTextWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextWidth_get
    if _newclass:m_ModuleTextWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleTextWidth_set)
    __swig_setmethods__["m_ModuleSegmentWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleSegmentWidth_set
    __swig_getmethods__["m_ModuleSegmentWidth"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleSegmentWidth_get
    if _newclass:m_ModuleSegmentWidth = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleSegmentWidth_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_ModuleSegmentWidth_set)
    __swig_setmethods__["m_AuxOrigin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_AuxOrigin_set
    __swig_getmethods__["m_AuxOrigin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_AuxOrigin_get
    if _newclass:m_AuxOrigin = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_AuxOrigin_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_AuxOrigin_set)
    __swig_setmethods__["m_GridOrigin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_GridOrigin_set
    __swig_getmethods__["m_GridOrigin"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_GridOrigin_get
    if _newclass:m_GridOrigin = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_GridOrigin_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_GridOrigin_set)
    __swig_setmethods__["m_Pad_Master"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_Pad_Master_set
    __swig_getmethods__["m_Pad_Master"] = _pcbnew.BOARD_DESIGN_SETTINGS_m_Pad_Master_get
    if _newclass:m_Pad_Master = _swig_property(_pcbnew.BOARD_DESIGN_SETTINGS_m_Pad_Master_get, _pcbnew.BOARD_DESIGN_SETTINGS_m_Pad_Master_set)
   def __init__(self):
        """
        __init__(BOARD_DESIGN_SETTINGS self) -> BOARD_DESIGN_SETTINGS

        BOARD_DESIGN_SETTINGS::BOARD_DESIGN_SETTINGS()
        """
        this = _pcbnew.new_BOARD_DESIGN_SETTINGS()
        try: self.this.append(this)
        except: self.this = this
   def GetDefault(self):
        """
        GetDefault(BOARD_DESIGN_SETTINGS self) -> NETCLASSPTR

        NETCLASSPTR
        BOARD_DESIGN_SETTINGS::GetDefault() const

        Function GetDefault.

       the default netclass.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetDefault(self)

   def GetCurrentNetClassName(self):
        """
        GetCurrentNetClassName(BOARD_DESIGN_SETTINGS self) -> wxString const &

        const wxString& BOARD_DESIGN_SETTINGS::GetCurrentNetClassName() const

        Function GetCurrentNetClassName.

        the current net class name.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCurrentNetClassName(self)

   def UseNetClassTrack(self):
        """
        UseNetClassTrack(BOARD_DESIGN_SETTINGS self) -> bool

        bool
        BOARD_DESIGN_SETTINGS::UseNetClassTrack() const

        Function UseNetClassTrack returns true if netclass values should be
        used to obtain appropriate track width.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_UseNetClassTrack(self)

   def UseNetClassVia(self):
        """
        UseNetClassVia(BOARD_DESIGN_SETTINGS self) -> bool

        bool
        BOARD_DESIGN_SETTINGS::UseNetClassVia() const

        Function UseNetClassVia returns true if netclass values should be used
        to obtain appropriate via size.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_UseNetClassVia(self)

   def SetCurrentNetClass(self, *args):
        """
        SetCurrentNetClass(BOARD_DESIGN_SETTINGS self, wxString const & aNetClassName) -> bool

        bool BOARD_DESIGN_SETTINGS::SetCurrentNetClass(const wxString
        &aNetClassName)

        Function SetCurrentNetClass Must be called after a netclass selection
        (or after a netclass parameter change Initialize vias and tracks
        values displayed in comb boxes of the auxiliary toolbar and some
        others parameters (netclass name ....)

        Parameters:
        -----------

        aNetClassName:  = the new netclass name

        true if lists of tracks and vias sizes are modified
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetCurrentNetClass(self, *args)

   def GetBiggestClearanceValue(self):
        """
        GetBiggestClearanceValue(BOARD_DESIGN_SETTINGS self) -> int

        int BOARD_DESIGN_SETTINGS::GetBiggestClearanceValue()

        Function GetBiggestClearanceValue.

        the biggest clearance value found in NetClasses list
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetBiggestClearanceValue(self)

   def GetSmallestClearanceValue(self):
        """
        GetSmallestClearanceValue(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetSmallestClearanceValue()

        Function GetSmallestClearanceValue.

        the smallest clearance value found in NetClasses list
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetSmallestClearanceValue(self)

   def GetCurrentMicroViaSize(self):
        """
        GetCurrentMicroViaSize(BOARD_DESIGN_SETTINGS self) -> int

        int BOARD_DESIGN_SETTINGS::GetCurrentMicroViaSize()

        Function GetCurrentMicroViaSize.

        the current micro via size, that is the current netclass value
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCurrentMicroViaSize(self)

   def GetCurrentMicroViaDrill(self):
        """
        GetCurrentMicroViaDrill(BOARD_DESIGN_SETTINGS self) -> int

        int BOARD_DESIGN_SETTINGS::GetCurrentMicroViaDrill()

        Function GetCurrentMicroViaDrill.

        the current micro via drill, that is the current netclass value
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCurrentMicroViaDrill(self)

   def GetTrackWidthIndex(self):
        """
        GetTrackWidthIndex(BOARD_DESIGN_SETTINGS self) -> unsigned int

        unsigned BOARD_DESIGN_SETTINGS::GetTrackWidthIndex() const

        Function GetTrackWidthIndex.

        the current track width list index.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetTrackWidthIndex(self)

   def SetTrackWidthIndex(self, *args):
        """
        SetTrackWidthIndex(BOARD_DESIGN_SETTINGS self, unsigned int aIndex)

        void BOARD_DESIGN_SETTINGS::SetTrackWidthIndex(unsigned aIndex)

        Function SetTrackWidthIndex sets the current track width list index to
        aIndex.

        Parameters:
        -----------

        aIndex:  is the track width list index.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetTrackWidthIndex(self, *args)

   def GetCurrentTrackWidth(self):
        """
        GetCurrentTrackWidth(BOARD_DESIGN_SETTINGS self) -> int

        int BOARD_DESIGN_SETTINGS::GetCurrentTrackWidth() const

        Function GetCurrentTrackWidth.

        the current track width, according to the selected options ( using the
       default netclass value or a preset/custom value ) the default netclass
        is always in m_TrackWidthList[0]
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCurrentTrackWidth(self)

   def SetCustomTrackWidth(self, *args):
        """
        SetCustomTrackWidth(BOARD_DESIGN_SETTINGS self, int aWidth)

        void BOARD_DESIGN_SETTINGS::SetCustomTrackWidth(int aWidth)

        Function SetCustomTrackWidth Sets custom width for track (i.e.

        not available in netclasses or preset list). To have it returned with
        GetCurrentTrackWidth() you need to enable custom track & via sizes (
        UseCustomTrackViaSize()).

        Parameters:
        -----------

        aWidth:  is the new track width.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetCustomTrackWidth(self, *args)

   def GetCustomTrackWidth(self):
        """
        GetCustomTrackWidth(BOARD_DESIGN_SETTINGS self) -> int

        int BOARD_DESIGN_SETTINGS::GetCustomTrackWidth() const

        Function GetCustomTrackWidth.

        Current custom width for a track.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCustomTrackWidth(self)

   def GetViaSizeIndex(self):
        """
        GetViaSizeIndex(BOARD_DESIGN_SETTINGS self) -> unsigned int

        unsigned BOARD_DESIGN_SETTINGS::GetViaSizeIndex() const

        Function GetViaSizeIndex.

        the current via size list index.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetViaSizeIndex(self)

   def SetViaSizeIndex(self, *args):
        """
        SetViaSizeIndex(BOARD_DESIGN_SETTINGS self, unsigned int aIndex)

        void
        BOARD_DESIGN_SETTINGS::SetViaSizeIndex(unsigned aIndex)

        Function SetViaSizeIndex sets the current via size list index to
        aIndex.

        Parameters:
        -----------

        aIndex:  is the via size list index.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetViaSizeIndex(self, *args)

   def GetCurrentViaSize(self):
        """
        GetCurrentViaSize(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetCurrentViaSize() const

        Function GetCurrentViaSize.

        the current via size, according to the selected options ( using the
       default netclass value or a preset/custom value ) the default netclass
        is always in m_TrackWidthList[0]
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCurrentViaSize(self)

   def SetCustomViaSize(self, *args):
        """
        SetCustomViaSize(BOARD_DESIGN_SETTINGS self, int aSize)

        void
        BOARD_DESIGN_SETTINGS::SetCustomViaSize(int aSize)

        Function SetCustomViaSize Sets custom size for via diameter (i.e.

        not available in netclasses or preset list). To have it returned with
        GetCurrentViaSize() you need to enable custom track & via sizes (
        UseCustomTrackViaSize()).

        Parameters:
        -----------

        aSize:  is the new drill diameter.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetCustomViaSize(self, *args)

   def GetCustomViaSize(self):
        """
        GetCustomViaSize(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetCustomViaSize() const

        Function GetCustomViaSize.

        Current custom size for the via diameter.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCustomViaSize(self)

   def GetCurrentViaDrill(self):
        """
        GetCurrentViaDrill(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetCurrentViaDrill() const

        Function GetCurrentViaDrill.

        the current via size, according to the selected options ( using the
       default netclass value or a preset/custom value ) the default netclass
        is always in m_TrackWidthList[0]
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCurrentViaDrill(self)

   def SetCustomViaDrill(self, *args):
        """
        SetCustomViaDrill(BOARD_DESIGN_SETTINGS self, int aDrill)

        void
        BOARD_DESIGN_SETTINGS::SetCustomViaDrill(int aDrill)

        Function SetCustomViaDrill Sets custom size for via drill (i.e.

        not available in netclasses or preset list). To have it returned with
        GetCurrentViaDrill() you need to enable custom track & via sizes (
        UseCustomTrackViaSize()).

        Parameters:
        -----------

        aDrill:  is the new drill size.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetCustomViaDrill(self, *args)

   def GetCustomViaDrill(self):
        """
        GetCustomViaDrill(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetCustomViaDrill() const

        Function GetCustomViaDrill.

        Current custom size for the via drill.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCustomViaDrill(self)

   def UseCustomTrackViaSize(self, *args):
        """
        UseCustomTrackViaSize(BOARD_DESIGN_SETTINGS self, bool aEnabled)
        UseCustomTrackViaSize(BOARD_DESIGN_SETTINGS self) -> bool

        bool BOARD_DESIGN_SETTINGS::UseCustomTrackViaSize() const

        Function UseCustomTrackViaSize.

        True if custom sizes of tracks & vias are enabled, false otherwise.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_UseCustomTrackViaSize(self, *args)

   def GetVisibleLayers(self):
        """
        GetVisibleLayers(BOARD_DESIGN_SETTINGS self) -> LSET

        LSET
        BOARD_DESIGN_SETTINGS::GetVisibleLayers() const

        Function GetVisibleLayers returns a bit-mask of all the layers that
        are visible.

        int - the visible layers in bit-mapped form.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetVisibleLayers(self)

   def SetVisibleAlls(self):
        """
        SetVisibleAlls(BOARD_DESIGN_SETTINGS self)

        void
        BOARD_DESIGN_SETTINGS::SetVisibleAlls()

        Function SetVisibleAlls Set the bit-mask of all visible elements
        categories, including enabled layers.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetVisibleAlls(self)

   def SetVisibleLayers(self, *args):
        """
        SetVisibleLayers(BOARD_DESIGN_SETTINGS self, LSET aMask)

        void
        BOARD_DESIGN_SETTINGS::SetVisibleLayers(LSET aMask)

        Function SetVisibleLayers changes the bit-mask of visible layers.

        Parameters:
        -----------

        aMask:  = The new bit-mask of visible layers
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetVisibleLayers(self, *args)

   def IsLayerVisible(self, *args):
        """
        IsLayerVisible(BOARD_DESIGN_SETTINGS self, LAYER_ID aLayerId) -> bool

        bool
        BOARD_DESIGN_SETTINGS::IsLayerVisible(LAYER_ID aLayerId) const

        Function IsLayerVisible tests whether a given layer is visible.

        Parameters:
        -----------

        aLayerId:  = The layer to be tested

        bool - true if the layer is visible.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_IsLayerVisible(self, *args)

   def SetLayerVisibility(self, *args):
        """
        SetLayerVisibility(BOARD_DESIGN_SETTINGS self, LAYER_ID aLayerId, bool aNewState)

        void BOARD_DESIGN_SETTINGS::SetLayerVisibility(LAYER_ID aLayerId, bool
        aNewState)

        Function SetLayerVisibility changes the visibility of a given layer.

        Parameters:
        -----------

        aLayerId:  = The layer to be changed

        aNewState:  = The new visibility state of the layer
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetLayerVisibility(self, *args)

   def GetVisibleElements(self):
        """
        GetVisibleElements(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetVisibleElements() const

        Function GetVisibleElements returns a bit-mask of all the element
        categories that are visible.

        int - the visible element categories in bit-mapped form.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetVisibleElements(self)

   def SetVisibleElements(self, *args):
        """
        SetVisibleElements(BOARD_DESIGN_SETTINGS self, int aMask)

        void BOARD_DESIGN_SETTINGS::SetVisibleElements(int aMask)

        Function SetVisibleElements changes the bit-mask of visible element
        categories.

        Parameters:
        -----------

        aMask:  = The new bit-mask of visible element categories
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetVisibleElements(self, *args)

   def IsElementVisible(self, *args):
        """
        IsElementVisible(BOARD_DESIGN_SETTINGS self, int aElementCategory) -> bool

        bool
        BOARD_DESIGN_SETTINGS::IsElementVisible(int aElementCategory) const

        Function IsElementVisible tests whether a given element category is
        visible.

        Keep this as an inline function.

        Parameters:
        -----------

        aElementCategory:  is from the enum by the same name

        bool - true if the element is visible.

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_IsElementVisible(self, *args)

   def SetElementVisibility(self, *args):
        """
        SetElementVisibility(BOARD_DESIGN_SETTINGS self, int aElementCategory, bool aNewState)

        void BOARD_DESIGN_SETTINGS::SetElementVisibility(int aElementCategory,
        bool aNewState)

        Function SetElementVisibility changes the visibility of an element
        category.

        Parameters:
        -----------

        aElementCategory:  is from the enum by the same name

        aNewState:  = The new visibility state of the element category

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetElementVisibility(self, *args)

   def GetEnabledLayers(self):
        """
        GetEnabledLayers(BOARD_DESIGN_SETTINGS self) -> LSET

        LSET
        BOARD_DESIGN_SETTINGS::GetEnabledLayers() const

        Function GetEnabledLayers returns a bit-mask of all the layers that
        are enabled.

        int - the enabled layers in bit-mapped form.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetEnabledLayers(self)

   def SetEnabledLayers(self, *args):
        """
        SetEnabledLayers(BOARD_DESIGN_SETTINGS self, LSET aMask)

        void
        BOARD_DESIGN_SETTINGS::SetEnabledLayers(LSET aMask)

        Function SetEnabledLayers changes the bit-mask of enabled layers.

        Parameters:
        -----------

        aMask:  = The new bit-mask of enabled layers
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetEnabledLayers(self, *args)

   def IsLayerEnabled(self, *args):
        """
        IsLayerEnabled(BOARD_DESIGN_SETTINGS self, LAYER_ID aLayerId) -> bool

        bool
        BOARD_DESIGN_SETTINGS::IsLayerEnabled(LAYER_ID aLayerId) const

        Function IsLayerEnabled tests whether a given layer is enabled.

        Parameters:
        -----------

        aLayerId:  = The layer to be tested

        bool - true if the layer is enabled
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_IsLayerEnabled(self, *args)

   def GetCopperLayerCount(self):
        """
        GetCopperLayerCount(BOARD_DESIGN_SETTINGS self) -> int

        int BOARD_DESIGN_SETTINGS::GetCopperLayerCount() const

        Function GetCopperLayerCount.

        int - the number of neabled copper layers
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetCopperLayerCount(self)

   def SetCopperLayerCount(self, *args):
        """
        SetCopperLayerCount(BOARD_DESIGN_SETTINGS self, int aNewLayerCount)

        void BOARD_DESIGN_SETTINGS::SetCopperLayerCount(int aNewLayerCount)

        Function SetCopperLayerCount do what its name says...

        Parameters:
        -----------

        aNewLayerCount:  = The new number of enabled copper layers
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetCopperLayerCount(self, *args)

   def AppendConfigs(self, *args):
        """
        AppendConfigs(BOARD_DESIGN_SETTINGS self, PARAM_CFG_ARRAY * aResult)

        void
        BOARD_DESIGN_SETTINGS::AppendConfigs(PARAM_CFG_ARRAY *aResult)

        Function AppendConfigs appends to aResult the configuration setting
        accessors which will later allow reading or writing of configuration
        file information directly into this object.
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_AppendConfigs(self, *args)

   def GetBoardThickness(self):
        """
        GetBoardThickness(BOARD_DESIGN_SETTINGS self) -> int

        int
        BOARD_DESIGN_SETTINGS::GetBoardThickness() const
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_GetBoardThickness(self)

   def SetBoardThickness(self, *args):
        """
        SetBoardThickness(BOARD_DESIGN_SETTINGS self, int aThickness)

        void
        BOARD_DESIGN_SETTINGS::SetBoardThickness(int aThickness)
        """
        return _pcbnew.BOARD_DESIGN_SETTINGS_SetBoardThickness(self, *args)

    __swig_destroy__ = _pcbnew.delete_BOARD_DESIGN_SETTINGS
    __del__ = lambda self : None;
BOARD_DESIGN_SETTINGS_swigregister = _pcbnew.BOARD_DESIGN_SETTINGS_swigregister
BOARD_DESIGN_SETTINGS_swigregister(BOARD_DESIGN_SETTINGS)

LT_UNDEFINED = _pcbnew.LT_UNDEFINED
LT_SIGNAL = _pcbnew.LT_SIGNAL
LT_POWER = _pcbnew.LT_POWER
LT_MIXED = _pcbnew.LT_MIXED
LT_JUMPER = _pcbnew.LT_JUMPER
class LAYER(_object):
    """Proxy of C++ LAYER class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LAYER, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LAYER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """__init__(LAYER self) -> LAYER"""
        this = _pcbnew.new_LAYER()
        try: self.this.append(this)
        except: self.this = this
   def clear(self):
        """clear(LAYER self)"""
        return _pcbnew.LAYER_clear(self)

    __swig_setmethods__["m_name"] = _pcbnew.LAYER_m_name_set
    __swig_getmethods__["m_name"] = _pcbnew.LAYER_m_name_get
    if _newclass:m_name = _swig_property(_pcbnew.LAYER_m_name_get, _pcbnew.LAYER_m_name_set)
    __swig_setmethods__["m_type"] = _pcbnew.LAYER_m_type_set
    __swig_getmethods__["m_type"] = _pcbnew.LAYER_m_type_get
    if _newclass:m_type = _swig_property(_pcbnew.LAYER_m_type_get, _pcbnew.LAYER_m_type_set)
    __swig_setmethods__["m_visible"] = _pcbnew.LAYER_m_visible_set
    __swig_getmethods__["m_visible"] = _pcbnew.LAYER_m_visible_get
    if _newclass:m_visible = _swig_property(_pcbnew.LAYER_m_visible_get, _pcbnew.LAYER_m_visible_set)
    __swig_setmethods__["m_number"] = _pcbnew.LAYER_m_number_set
    __swig_getmethods__["m_number"] = _pcbnew.LAYER_m_number_get
    if _newclass:m_number = _swig_property(_pcbnew.LAYER_m_number_get, _pcbnew.LAYER_m_number_set)
   def ShowType(*args):
        """ShowType(LAYER_T aType) -> char const *"""
        return _pcbnew.LAYER_ShowType(*args)

    if _newclass:ShowType = staticmethod(ShowType)
    __swig_getmethods__["ShowType"] = lambda x: ShowType
   def ParseType(*args):
        """ParseType(char const * aType) -> LAYER_T"""
        return _pcbnew.LAYER_ParseType(*args)

    if _newclass:ParseType = staticmethod(ParseType)
    __swig_getmethods__["ParseType"] = lambda x: ParseType
    __swig_destroy__ = _pcbnew.delete_LAYER
    __del__ = lambda self : None;
LAYER_swigregister = _pcbnew.LAYER_swigregister
LAYER_swigregister(LAYER)

def LAYER_ShowType(*args):
  """LAYER_ShowType(LAYER_T aType) -> char const *"""
  return _pcbnew.LAYER_ShowType(*args)

def LAYER_ParseType(*args):
  """LAYER_ParseType(char const * aType) -> LAYER_T"""
  return _pcbnew.LAYER_ParseType(*args)

class HIGH_LIGHT_INFO(_object):
    """C++ includes: class_board.h """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HIGH_LIGHT_INFO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HIGH_LIGHT_INFO, name)
   def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _pcbnew.delete_HIGH_LIGHT_INFO
    __del__ = lambda self : None;
HIGH_LIGHT_INFO_swigregister = _pcbnew.HIGH_LIGHT_INFO_swigregister
HIGH_LIGHT_INFO_swigregister(HIGH_LIGHT_INFO)

class BOARD(BOARD_ITEM):
    """
    Class BOARD holds information pertinent to a Pcbnew printed circuit
    board.

    C++ includes: class_board.h
    """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOARD, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BOARD, name)
    __repr__ = _swig_repr
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.BOARD_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
   def SetFileName(self, *args):
        """
        SetFileName(BOARD self, wxString const & aFileName)

        void
        BOARD::SetFileName(const wxString &aFileName)
        """
        return _pcbnew.BOARD_SetFileName(self, *args)

   def GetFileName(self):
        """
        GetFileName(BOARD self) -> wxString const &

        const wxString&
        BOARD::GetFileName() const
        """
        return _pcbnew.BOARD_GetFileName(self)

    __swig_setmethods__["m_Status_Pcb"] = _pcbnew.BOARD_m_Status_Pcb_set
    __swig_getmethods__["m_Status_Pcb"] = _pcbnew.BOARD_m_Status_Pcb_get
    if _newclass:m_Status_Pcb = _swig_property(_pcbnew.BOARD_m_Status_Pcb_get, _pcbnew.BOARD_m_Status_Pcb_set)
    __swig_setmethods__["m_Drawings"] = _pcbnew.BOARD_m_Drawings_set
    __swig_getmethods__["m_Drawings"] = _pcbnew.BOARD_m_Drawings_get
    if _newclass:m_Drawings = _swig_property(_pcbnew.BOARD_m_Drawings_get, _pcbnew.BOARD_m_Drawings_set)
    __swig_setmethods__["m_Modules"] = _pcbnew.BOARD_m_Modules_set
    __swig_getmethods__["m_Modules"] = _pcbnew.BOARD_m_Modules_get
    if _newclass:m_Modules = _swig_property(_pcbnew.BOARD_m_Modules_get, _pcbnew.BOARD_m_Modules_set)
    __swig_setmethods__["m_Track"] = _pcbnew.BOARD_m_Track_set
    __swig_getmethods__["m_Track"] = _pcbnew.BOARD_m_Track_get
    if _newclass:m_Track = _swig_property(_pcbnew.BOARD_m_Track_get, _pcbnew.BOARD_m_Track_set)
    __swig_setmethods__["m_Zone"] = _pcbnew.BOARD_m_Zone_set
    __swig_getmethods__["m_Zone"] = _pcbnew.BOARD_m_Zone_get
    if _newclass:m_Zone = _swig_property(_pcbnew.BOARD_m_Zone_get, _pcbnew.BOARD_m_Zone_set)
    __swig_setmethods__["m_FullRatsnest"] = _pcbnew.BOARD_m_FullRatsnest_set
    __swig_getmethods__["m_FullRatsnest"] = _pcbnew.BOARD_m_FullRatsnest_get
    if _newclass:m_FullRatsnest = _swig_property(_pcbnew.BOARD_m_FullRatsnest_get, _pcbnew.BOARD_m_FullRatsnest_set)
    __swig_setmethods__["m_LocalRatsnest"] = _pcbnew.BOARD_m_LocalRatsnest_set
    __swig_getmethods__["m_LocalRatsnest"] = _pcbnew.BOARD_m_LocalRatsnest_get
    if _newclass:m_LocalRatsnest = _swig_property(_pcbnew.BOARD_m_LocalRatsnest_get, _pcbnew.BOARD_m_LocalRatsnest_set)
    __swig_setmethods__["m_CurrentZoneContour"] = _pcbnew.BOARD_m_CurrentZoneContour_set
    __swig_getmethods__["m_CurrentZoneContour"] = _pcbnew.BOARD_m_CurrentZoneContour_get
    if _newclass:m_CurrentZoneContour = _swig_property(_pcbnew.BOARD_m_CurrentZoneContour_get, _pcbnew.BOARD_m_CurrentZoneContour_set)
   def __init__(self):
        """
        __init__(BOARD self) -> BOARD

        BOARD::BOARD()
        """
        this = _pcbnew.new_BOARD()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_BOARD
    __del__ = lambda self : None;
   def GetPosition(self):
        """
        GetPosition(BOARD self) -> wxPoint

        const wxPoint &
        BOARD::GetPosition() const
        """
        return _pcbnew.BOARD_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(BOARD self, wxPoint aPos)

        void
        BOARD::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.BOARD_SetPosition(self, *args)

   def IsEmpty(self):
        """
        IsEmpty(BOARD self) -> bool

        bool BOARD::IsEmpty() const
        """
        return _pcbnew.BOARD_IsEmpty(self)

   def Move(self, *args):
        """
        Move(BOARD self, wxPoint aMoveVector)

        void BOARD::Move(const wxPoint
        &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.BOARD_Move(self, *args)

   def SetFileFormatVersionAtLoad(self, *args):
        """
        SetFileFormatVersionAtLoad(BOARD self, int aVersion)

        void
        BOARD::SetFileFormatVersionAtLoad(int aVersion)
        """
        return _pcbnew.BOARD_SetFileFormatVersionAtLoad(self, *args)

   def GetFileFormatVersionAtLoad(self):
        """
        GetFileFormatVersionAtLoad(BOARD self) -> int

        int
        BOARD::GetFileFormatVersionAtLoad() const
        """
        return _pcbnew.BOARD_GetFileFormatVersionAtLoad(self)

   def AddNative(self, *args):
        """
        AddNative(BOARD self, BOARD_ITEM aBoardItem, int aControl=0)
        AddNative(BOARD self, BOARD_ITEM aBoardItem)

        void BOARD::Add(BOARD_ITEM
        *aBoardItem, int aControl=0)

        Function Add adds the given item to this BOARD and takes ownership of
        its memory.

        Parameters:
        -----------

        aBoardItem:  The item to add to this board.

        aControl:  An int which can vary how the item is added.
        """
        return _pcbnew.BOARD_AddNative(self, *args)

   def Delete(self, *args):
        """
        Delete(BOARD self, BOARD_ITEM aBoardItem)

        void BOARD::Delete(BOARD_ITEM
        *aBoardItem)

        Function Delete removes the given single item from this BOARD and
        deletes its memory.

        Parameters:
        -----------

        aBoardItem:  The item to remove from this board and delete
        """
        return _pcbnew.BOARD_Delete(self, *args)

   def Remove(self, *args):
        """
        Remove(BOARD self, BOARD_ITEM aBoardItem) -> BOARD_ITEM

        BOARD_ITEM *
        BOARD::Remove(BOARD_ITEM *aBoardItem)

        Function Remove removes aBoardItem from this BOARD and returns it to
        caller without deleting it.

        Parameters:
        -----------

        aBoardItem:  The item to remove from this board.

        BOARD_ITEM* aBoardItem which was passed in.
        """
        return _pcbnew.BOARD_Remove(self, *args)

   def GetRatsnest(self):
        """
        GetRatsnest(BOARD self) -> RN_DATA *

        RN_DATA*
        BOARD::GetRatsnest() const

        Function GetRatsnest() returns list of missing connections between
        components/tracks.

        RATSNEST* is an object that contains informations about missing
        connections.
        """
        return _pcbnew.BOARD_GetRatsnest(self)

   def DeleteMARKERs(self):
        """
        DeleteMARKERs(BOARD self)

        void
        BOARD::DeleteMARKERs()

        Function DeleteMARKERs deletes ALL MARKERS from the board.
        """
        return _pcbnew.BOARD_DeleteMARKERs(self)

   def DeleteZONEOutlines(self):
        """
        DeleteZONEOutlines(BOARD self)

        void
        BOARD::DeleteZONEOutlines()

        Function DeleteZONEOutlines deletes ALL zone outlines from the board.

        """
        return _pcbnew.BOARD_DeleteZONEOutlines(self)

   def GetMARKER(self, *args):
        """
        GetMARKER(BOARD self, int index) -> MARKER_PCB

        MARKER_PCB*
        BOARD::GetMARKER(int index) const

        Function GetMARKER returns the MARKER at a given index.

        Parameters:
        -----------

        index:  The array type index into a collection of MARKER_PCBS.

        MARKER_PCB* - a pointer to the MARKER_PCB or NULL if index out of
        range.
        """
        return _pcbnew.BOARD_GetMARKER(self, *args)

   def GetMARKERCount(self):
        """
        GetMARKERCount(BOARD self) -> int

        int
        BOARD::GetMARKERCount() const

        Function GetMARKERCount.

        int - The number of MARKER_PCBS.
        """
        return _pcbnew.BOARD_GetMARKERCount(self)

   def SetAuxOrigin(self, *args):
        """
        SetAuxOrigin(BOARD self, wxPoint aPoint)

        void
        BOARD::SetAuxOrigin(const wxPoint &aPoint)

        Function SetAuxOrigin sets the origin point used for plotting.
        """
        return _pcbnew.BOARD_SetAuxOrigin(self, *args)

   def GetAuxOrigin(self):
        """
        GetAuxOrigin(BOARD self) -> wxPoint

        const wxPoint&
        BOARD::GetAuxOrigin() const
        """
        return _pcbnew.BOARD_GetAuxOrigin(self)

   def SetGridOrigin(self, *args):
        """
        SetGridOrigin(BOARD self, wxPoint aPoint)

        void
        BOARD::SetGridOrigin(const wxPoint &aPoint)

        Function SetGridOrigin sets the origin point of the grid.
        """
        return _pcbnew.BOARD_SetGridOrigin(self, *args)

   def GetGridOrigin(self):
        """
        GetGridOrigin(BOARD self) -> wxPoint

        const wxPoint&
        BOARD::GetGridOrigin() const
        """
        return _pcbnew.BOARD_GetGridOrigin(self)

   def ResetHighLight(self):
        """
        ResetHighLight(BOARD self)

        void
        BOARD::ResetHighLight()

        Function ResetHighLight Reset all high light data to the init state.

        """
        return _pcbnew.BOARD_ResetHighLight(self)

   def GetHighLightNetCode(self):
        """
        GetHighLightNetCode(BOARD self) -> int

        int
        BOARD::GetHighLightNetCode()

        Function GetHighLightNetCode.

        netcode of net to highlight (-1 when no net selected)
        """
        return _pcbnew.BOARD_GetHighLightNetCode(self)

   def SetHighLightNet(self, *args):
        """
        SetHighLightNet(BOARD self, int aNetCode)

        void
        BOARD::SetHighLightNet(int aNetCode)

        Function SetHighLightNet.

        Parameters:
        -----------

        aNetCode:  = netcode of net to highlight
        """
        return _pcbnew.BOARD_SetHighLightNet(self, *args)

   def IsHighLightNetON(self):
        """
        IsHighLightNetON(BOARD self) -> bool

        bool
        BOARD::IsHighLightNetON()

        Function IsHighLightNetON.

        true if a net is currently highlighted
        """
        return _pcbnew.BOARD_IsHighLightNetON(self)

   def HighLightOFF(self):
        """
        HighLightOFF(BOARD self)

        void
        BOARD::HighLightOFF()

        Function HighLightOFF Disable highlight.
        """
        return _pcbnew.BOARD_HighLightOFF(self)

   def HighLightON(self):
        """
        HighLightON(BOARD self)

        void BOARD::HighLightON()

        Function HighLightON Enable highlight.

        if m_highLight_NetCode >= 0, this net will be highlighted
        """
        return _pcbnew.BOARD_HighLightON(self)

   def PushHighLight(self):
        """
        PushHighLight(BOARD self)

        void
        BOARD::PushHighLight()

        Function PushHighLight save current high light info for later use.
        """
        return _pcbnew.BOARD_PushHighLight(self)

   def PopHighLight(self):
        """
        PopHighLight(BOARD self)

        void
        BOARD::PopHighLight()

        Function PopHighLight retrieve a previously saved high light info.
        """
        return _pcbnew.BOARD_PopHighLight(self)

   def GetCopperLayerCount(self):
        """
        GetCopperLayerCount(BOARD self) -> int

        int
        BOARD::GetCopperLayerCount() const

        Function GetCopperLayerCount.

        int - The number of copper layers in the BOARD.
        """
        return _pcbnew.BOARD_GetCopperLayerCount(self)

   def SetCopperLayerCount(self, *args):
        """
        SetCopperLayerCount(BOARD self, int aCount)

        void
        BOARD::SetCopperLayerCount(int aCount)
        """
        return _pcbnew.BOARD_SetCopperLayerCount(self, *args)

   def GetEnabledLayers(self):
        """
        GetEnabledLayers(BOARD self) -> LSET

        LSET
        BOARD::GetEnabledLayers() const

        Function GetEnabledLayers is a proxy function that calls the
        corresponding function in m_BoardSettings Returns a bit-mask of all
        the layers that are enabled.

        int - the enabled layers in bit-mapped form.
        """
        return _pcbnew.BOARD_GetEnabledLayers(self)

   def SetEnabledLayers(self, *args):
        """
        SetEnabledLayers(BOARD self, LSET aLayerMask)

        void
        BOARD::SetEnabledLayers(LSET aLayerMask)

        Function SetEnabledLayers is a proxy function that calls the
        correspondent function in m_BoardSettings Changes the bit-mask of
        enabled layers.

        Parameters:
        -----------

        aLayerMask:  = The new bit-mask of enabled layers
        """
        return _pcbnew.BOARD_SetEnabledLayers(self, *args)

   def IsLayerEnabled(self, *args):
        """
        IsLayerEnabled(BOARD self, LAYER_ID aLayer) -> bool

        bool
        BOARD::IsLayerEnabled(LAYER_ID aLayer) const

        Function IsLayerEnabled is a proxy function that calls the
        correspondent function in m_BoardSettings tests whether a given layer
        is enabled.

        Parameters:
        -----------

        aLayer:  = The layer to be tested

        bool - true if the layer is visible.
        """
        return _pcbnew.BOARD_IsLayerEnabled(self, *args)

   def IsLayerVisible(self, *args):
        """
        IsLayerVisible(BOARD self, LAYER_ID aLayer) -> bool

        bool
        BOARD::IsLayerVisible(LAYER_ID aLayer) const

        Function IsLayerVisible is a proxy function that calls the
        correspondent function in m_BoardSettings tests whether a given layer
        is visible.

        Parameters:
        -----------

        aLayer:  = The layer to be tested

        bool - true if the layer is visible.
        """
        return _pcbnew.BOARD_IsLayerVisible(self, *args)

   def GetVisibleLayers(self):
        """
        GetVisibleLayers(BOARD self) -> LSET

        LSET
        BOARD::GetVisibleLayers() const

        Function GetVisibleLayers is a proxy function that calls the
        correspondent function in m_BoardSettings Returns a bit-mask of all
        the layers that are visible.

        int - the visible layers in bit-mapped form.
        """
        return _pcbnew.BOARD_GetVisibleLayers(self)

   def SetVisibleLayers(self, *args):
        """
        SetVisibleLayers(BOARD self, LSET aLayerMask)

        void
        BOARD::SetVisibleLayers(LSET aLayerMask)

        Function SetVisibleLayers is a proxy function that calls the
        correspondent function in m_BoardSettings changes the bit-mask of
        visible layers.

        Parameters:
        -----------

        aLayerMask:  = The new bit-mask of visible layers
        """
        return _pcbnew.BOARD_SetVisibleLayers(self, *args)

   def GetVisibleElements(self):
        """
        GetVisibleElements(BOARD self) -> int

        int
        BOARD::GetVisibleElements() const

        Function GetVisibleElements is a proxy function that calls the
        correspondent function in m_BoardSettings returns a bit-mask of all
        the element categories that are visible.

        int - the visible element bitmap or-ed from enum PCB_VISIBLE

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_GetVisibleElements(self)

   def SetVisibleElements(self, *args):
        """
        SetVisibleElements(BOARD self, int aMask)

        void
        BOARD::SetVisibleElements(int aMask)

        Function SetVisibleElements is a proxy function that calls the
        correspondent function in m_BoardSettings changes the bit-mask of
        visible element categories.

        Parameters:
        -----------

        aMask:  = The new bit-mask of visible element bitmap or-ed from enum
        PCB_VISIBLE

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_SetVisibleElements(self, *args)

   def SetVisibleAlls(self):
        """
        SetVisibleAlls(BOARD self)

        void
        BOARD::SetVisibleAlls()

        Function SetVisibleAlls changes the bit-mask of visible element
        categories and layers.

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_SetVisibleAlls(self)

   def IsElementVisible(self, *args):
        """
        IsElementVisible(BOARD self, int aPCB_VISIBLE) -> bool

        bool
        BOARD::IsElementVisible(int aPCB_VISIBLE) const

        Function IsElementVisible tests whether a given element category is
        visible.

        Keep this as an inline function.

        Parameters:
        -----------

        aPCB_VISIBLE:  is from the enum by the same name

        bool - true if the element is visible.

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_IsElementVisible(self, *args)

   def SetElementVisibility(self, *args):
        """
        SetElementVisibility(BOARD self, int aPCB_VISIBLE, bool aNewState)

        void
        BOARD::SetElementVisibility(int aPCB_VISIBLE, bool aNewState)

        Function SetElementVisibility changes the visibility of an element
        category.

        Parameters:
        -----------

        aPCB_VISIBLE:  is from the enum by the same name

        aNewState:  = The new visibility state of the element category

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_SetElementVisibility(self, *args)

   def IsModuleLayerVisible(self, *args):
        """
        IsModuleLayerVisible(BOARD self, LAYER_ID layer) -> bool

        bool
        BOARD::IsModuleLayerVisible(LAYER_ID layer)

        Function IsModuleLayerVisible expects either of the two layers on
        which a module can reside, and returns whether that layer is visible.

        Parameters:
        -----------

        layer:  One of the two allowed layers for modules: F_Cu or B_Cu

        bool - true if the layer is visible, else false.
        """
        return _pcbnew.BOARD_IsModuleLayerVisible(self, *args)

   def GetVisibleElementColor(self, *args):
        """
        GetVisibleElementColor(BOARD self, int aPCB_VISIBLE) -> EDA_COLOR_T

        EDA_COLOR_T
        BOARD::GetVisibleElementColor(int aPCB_VISIBLE)

        Function GetVisibleElementColor returns the color of a pcb visible
        element.

        See:  enum PCB_VISIBLE
        """
        return _pcbnew.BOARD_GetVisibleElementColor(self, *args)

   def SetVisibleElementColor(self, *args):
        """
        SetVisibleElementColor(BOARD self, int aPCB_VISIBLE, EDA_COLOR_T aColor)

        void
        BOARD::SetVisibleElementColor(int aPCB_VISIBLE, EDA_COLOR_T aColor)
        """
        return _pcbnew.BOARD_SetVisibleElementColor(self, *args)

   def GetDesignSettings(self):
        """
        GetDesignSettings(BOARD self) -> BOARD_DESIGN_SETTINGS

        BOARD_DESIGN_SETTINGS& BOARD::GetDesignSettings() const

        Function GetDesignSettings.

        the BOARD_DESIGN_SETTINGS for this BOARD
        """
        return _pcbnew.BOARD_GetDesignSettings(self)

   def SetDesignSettings(self, *args):
        """
        SetDesignSettings(BOARD self, BOARD_DESIGN_SETTINGS aDesignSettings)

        void
        BOARD::SetDesignSettings(const BOARD_DESIGN_SETTINGS &aDesignSettings)

        Function SetDesignSettings.

        Parameters:
        -----------

        aDesignSettings:  the new BOARD_DESIGN_SETTINGS to use
        """
        return _pcbnew.BOARD_SetDesignSettings(self, *args)

   def GetPageSettings(self):
        """
        GetPageSettings(BOARD self) -> PAGE_INFO const &

        const PAGE_INFO&
        BOARD::GetPageSettings() const
        """
        return _pcbnew.BOARD_GetPageSettings(self)

   def SetPageSettings(self, *args):
        """
        SetPageSettings(BOARD self, PAGE_INFO const & aPageSettings)

        void
        BOARD::SetPageSettings(const PAGE_INFO &aPageSettings)
        """
        return _pcbnew.BOARD_SetPageSettings(self, *args)

   def GetPlotOptions(self):
        """
        GetPlotOptions(BOARD self) -> PCB_PLOT_PARAMS

        const PCB_PLOT_PARAMS&
        BOARD::GetPlotOptions() const
        """
        return _pcbnew.BOARD_GetPlotOptions(self)

   def SetPlotOptions(self, *args):
        """
        SetPlotOptions(BOARD self, PCB_PLOT_PARAMS aOptions)

        void
        BOARD::SetPlotOptions(const PCB_PLOT_PARAMS &aOptions)
        """
        return _pcbnew.BOARD_SetPlotOptions(self, *args)

   def GetTitleBlock(self):
        """
        GetTitleBlock(BOARD self) -> TITLE_BLOCK

        TITLE_BLOCK&
        BOARD::GetTitleBlock()
        """
        return _pcbnew.BOARD_GetTitleBlock(self)

   def SetTitleBlock(self, *args):
        """
        SetTitleBlock(BOARD self, TITLE_BLOCK aTitleBlock)

        void
        BOARD::SetTitleBlock(const TITLE_BLOCK &aTitleBlock)
        """
        return _pcbnew.BOARD_SetTitleBlock(self, *args)

   def GetZoneSettings(self):
        """
        GetZoneSettings(BOARD self) -> ZONE_SETTINGS

        const ZONE_SETTINGS&
        BOARD::GetZoneSettings() const
        """
        return _pcbnew.BOARD_GetZoneSettings(self)

   def SetZoneSettings(self, *args):
        """
        SetZoneSettings(BOARD self, ZONE_SETTINGS aSettings)

        void
        BOARD::SetZoneSettings(const ZONE_SETTINGS &aSettings)
        """
        return _pcbnew.BOARD_SetZoneSettings(self, *args)

   def GetColorsSettings(self):
        """
        GetColorsSettings(BOARD self) -> COLORS_DESIGN_SETTINGS

        COLORS_DESIGN_SETTINGS* BOARD::GetColorsSettings() const

        Function GetColorSettings.

        the current COLORS_DESIGN_SETTINGS in use
        """
        return _pcbnew.BOARD_GetColorsSettings(self)

   def SetColorsSettings(self, *args):
        """
        SetColorsSettings(BOARD self, COLORS_DESIGN_SETTINGS aColorsSettings)

        void
        BOARD::SetColorsSettings(COLORS_DESIGN_SETTINGS *aColorsSettings)

        Function SetColorsSettings.

        Parameters:
        -----------

        aColorsSettings:  = the new COLORS_DESIGN_SETTINGS to use
        """
        return _pcbnew.BOARD_SetColorsSettings(self, *args)

   def GetBoardPolygonOutlines(self, *args):
        """
        GetBoardPolygonOutlines(BOARD self, CPOLYGONS_LIST aOutlines, CPOLYGONS_LIST aHoles, wxString * aErrorText=None) -> bool
        GetBoardPolygonOutlines(BOARD self, CPOLYGONS_LIST aOutlines, CPOLYGONS_LIST aHoles) -> bool

        bool
        BOARD::GetBoardPolygonOutlines(CPOLYGONS_LIST &aOutlines,
        CPOLYGONS_LIST &aHoles, wxString *aErrorText=NULL)

        Function GetBoardPolygonOutlines Extracts the board outlines and build
        a closed polygon from lines, arcs and circle items on edge cut layer
        Any closed outline inside the main outline is a hole All contours
        should be closed, i.e.

        have valid vertices to build a closed polygon

        Parameters:
        -----------

        aOutlines:  The CPOLYGONS_LIST to fill in with main outlines.

        aHoles:  The empty CPOLYGONS_LIST to fill in with holes, if any.

        aErrorText:  = a wxString reference to display an error message with
        the coordinate of the point which creates the error (default = NULL ,
        no message returned on error)

        true if success, false if a contour is not valid
        """
        return _pcbnew.BOARD_GetBoardPolygonOutlines(self, *args)

   def ConvertBrdLayerToPolygonalContours(self, *args):
        """
        ConvertBrdLayerToPolygonalContours(BOARD self, LAYER_ID aLayer, CPOLYGONS_LIST aOutlines)

        void BOARD::ConvertBrdLayerToPolygonalContours(LAYER_ID aLayer,
        CPOLYGONS_LIST &aOutlines)

        Function ConvertBrdLayerToPolygonalContours Build a set of polygons
        which are the outlines of copper items (pads, tracks, vias, texts,
        zones) Holes in vias or pads are ignored Usefull to export the shape
        of copper layers to dxf polygons or 3D viewer the polygons are not
        merged.

        Parameters:
        -----------

        aLayer:  = A copper layer, like B_Cu, etc.

        aOutlines:  The CPOLYGONS_LIST to fill in with items outline.
        """
        return _pcbnew.BOARD_ConvertBrdLayerToPolygonalContours(self, *args)

   def GetLayerName(self, *args):
        """
        GetLayerName(BOARD self, LAYER_ID aLayer) -> wxString const

        wxString
        BOARD_ITEM::GetLayerName() const

        Function GetLayerName returns the name of the PCB layer on which the
        item resides.

        wxString containing the layer name associated with this item.
        """
        return _pcbnew.BOARD_GetLayerName(self, *args)

   def SetLayerName(self, *args):
        """
        SetLayerName(BOARD self, LAYER_ID aLayer, wxString const & aLayerName) -> bool

        bool
        BOARD::SetLayerName(LAYER_ID aLayer, const wxString &aLayerName)

        Function SetLayerName changes the name of the layer given by aLayer.

        Parameters:
        -----------

        aLayer:  A layer, like B_Cu, etc.

        aLayerName:  The new layer name

        bool - true if aLayerName was legal and unique among other layer names
        at other layer indices and aLayer was within range, else false.
        """
        return _pcbnew.BOARD_SetLayerName(self, *args)

   def GetStandardLayerName(*args):
        """GetStandardLayerName(LAYER_ID aLayerId) -> wxString const"""
        return _pcbnew.BOARD_GetStandardLayerName(*args)

    if _newclass:GetStandardLayerName = staticmethod(GetStandardLayerName)
    __swig_getmethods__["GetStandardLayerName"] = lambda x: GetStandardLayerName
   def SetLayer(self, *args):
        """
        SetLayer(BOARD self, LAYER_ID aIndex, LAYER aLayer) -> bool

        virtual void
        BOARD_ITEM::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.BOARD_SetLayer(self, *args)

   def GetLayerType(self, *args):
        """
        GetLayerType(BOARD self, LAYER_ID aLayer) -> LAYER_T

        LAYER_T
        BOARD::GetLayerType(LAYER_ID aLayer) const

        Function GetLayerType returns the type of the copper layer given by
        aLayer.

        Parameters:
        -----------

        aLayer:  A layer index, like B_Cu, etc.

        LAYER_T - the layer type, or LAYER_T(-1) if the index was out of
        range.
        """
        return _pcbnew.BOARD_GetLayerType(self, *args)

   def SetLayerType(self, *args):
        """
        SetLayerType(BOARD self, LAYER_ID aLayer, LAYER_T aLayerType) -> bool

        bool
        BOARD::SetLayerType(LAYER_ID aLayer, LAYER_T aLayerType)

        Function SetLayerType changes the type of the layer given by aLayer.

        Parameters:
        -----------

        aLayer:  A layer index, like B_Cu, etc.

        aLayerType:  The new layer type.

        bool - true if aLayerType was legal and aLayer was within range, else
        false.
        """
        return _pcbnew.BOARD_SetLayerType(self, *args)

   def SetLayerColor(self, *args):
        """
        SetLayerColor(BOARD self, LAYER_ID aLayer, EDA_COLOR_T aColor)

        void
        BOARD::SetLayerColor(LAYER_ID aLayer, EDA_COLOR_T aColor)

        Function SetLayerColor changes a layer color for any valid layer,
        including non-copper ones.
        """
        return _pcbnew.BOARD_SetLayerColor(self, *args)

   def GetLayerColor(self, *args):
        """
        GetLayerColor(BOARD self, LAYER_ID aLayer) -> EDA_COLOR_T

        EDA_COLOR_T
        BOARD::GetLayerColor(LAYER_ID aLayer) const

        Function GetLayerColor gets a layer color for any valid layer,
        including non-copper ones.
        """
        return _pcbnew.BOARD_GetLayerColor(self, *args)

   def GetNumSegmTrack(self):
        """
        GetNumSegmTrack(BOARD self) -> int

        int
        BOARD::GetNumSegmTrack() const

        Functions to get some items count.
        """
        return _pcbnew.BOARD_GetNumSegmTrack(self)

   def GetNumSegmZone(self):
        """
        GetNumSegmZone(BOARD self) -> int

        int
        BOARD::GetNumSegmZone() const

        Calculate the zone segment count.
        """
        return _pcbnew.BOARD_GetNumSegmZone(self)

   def GetRatsnestsCount(self):
        """
        GetRatsnestsCount(BOARD self) -> unsigned int

        unsigned
        BOARD::GetRatsnestsCount() const

        Function GetNumRatsnests.

        int - The number of rats
        """
        return _pcbnew.BOARD_GetRatsnestsCount(self)

   def GetNodesCount(self):
        """
        GetNodesCount(BOARD self) -> unsigned int

        unsigned
        BOARD::GetNodesCount() const

        Function GetNodesCount.

        the number of pads members of nets (i.e. with netcode > 0)
        """
        return _pcbnew.BOARD_GetNodesCount(self)

   def SetNodeCount(self, *args):
        """
        SetNodeCount(BOARD self, unsigned int aCount)

        void
        BOARD::SetNodeCount(unsigned aCount)

        Function SetNodeCount set the number of nodes of the current net to
        aCount.

        Parameters:
        -----------

        aCount:  is the number of nodes attached to the current net.
        """
        return _pcbnew.BOARD_SetNodeCount(self, *args)

   def GetUnconnectedNetCount(self):
        """
        GetUnconnectedNetCount(BOARD self) -> unsigned int

        unsigned
        BOARD::GetUnconnectedNetCount() const

        Function GetUnconnectedNetCount.

        the number of unconnected nets in the current rats nest.
        """
        return _pcbnew.BOARD_GetUnconnectedNetCount(self)

   def SetUnconnectedNetCount(self, *args):
        """
        SetUnconnectedNetCount(BOARD self, unsigned int aCount)

        void
        BOARD::SetUnconnectedNetCount(unsigned aCount)

        Function SetUnconnectedNetCount sets the number of unconnected nets in
        the current rats nest to aCount.

        Parameters:
        -----------

        aCount:  is the number of unconneceted nets in the current rats nest.

        """
        return _pcbnew.BOARD_SetUnconnectedNetCount(self, *args)

   def GetPadCount(self):
        """
        GetPadCount(BOARD self) -> unsigned int

        unsigned
        BOARD::GetPadCount() const

        Function GetPadCount.

        the number of pads in board
        """
        return _pcbnew.BOARD_GetPadCount(self)

   def GetPads(self):
        """
        GetPads(BOARD self) -> std::vector< D_PAD *,std::allocator< D_PAD * > >

        std::vector<D_PAD*>
        BOARD::GetPads()

        Function GetPads returns a list of all the pads by value.

        The returned list is not sorted and contains pointers to PADS, but
        those pointers do not convey ownership of the respective PADs.
        std::vector<D_PAD*> - a full list of pads
        """
        return _pcbnew.BOARD_GetPads(self)

   def BuildListOfNets(self):
        """
        BuildListOfNets(BOARD self)

        void
        BOARD::BuildListOfNets()
        """
        return _pcbnew.BOARD_BuildListOfNets(self)

   def FindNet(self, *args):
        """
        FindNet(BOARD self, int aNetcode) -> NETINFO_ITEM
        FindNet(BOARD self, wxString const & aNetname) -> NETINFO_ITEM

        NETINFO_ITEM *
        BOARD::FindNet(const wxString &aNetname) const

        Function FindNet overloaded searches for a net with the given name.

        Parameters:
        -----------

        aNetname:  A Netname to search for.

        NETINFO_ITEM* - the net or NULL if not found.
        """
        return _pcbnew.BOARD_FindNet(self, *args)

   def AppendNet(self, *args):
        """
        AppendNet(BOARD self, NETINFO_ITEM aNewNet)

        void
        BOARD::AppendNet(NETINFO_ITEM *aNewNet)

        Function AppendNet adds a new net description item to the current
        board.

        Parameters:
        -----------

        aNewNet:  is the new description item.
        """
        return _pcbnew.BOARD_AppendNet(self, *args)

   def GetNetCount(self):
        """
        GetNetCount(BOARD self) -> unsigned int

        unsigned
        BOARD::GetNetCount() const

        Function GetNetCount.

        the number of nets ( NETINFO_ITEM)
        """
        return _pcbnew.BOARD_GetNetCount(self)

   def ComputeBoundingBox(self, aBoardEdgesOnly=False):
        """
        ComputeBoundingBox(BOARD self, bool aBoardEdgesOnly=False) -> EDA_RECT
        ComputeBoundingBox(BOARD self) -> EDA_RECT

        EDA_RECT
        BOARD::ComputeBoundingBox(bool aBoardEdgesOnly=false)

        Function ComputeBoundingBox calculates the bounding box containing all
        board items (or board edge segments).

        Parameters:
        -----------

        aBoardEdgesOnly:  is true if we are interested in board edge segments
        only.

        EDA_RECT - the board's bounding box

        See:   PCB_BASE_FRAME::GetBoardBoundingBox() which calls this and
        doctors the result
        """
        return _pcbnew.BOARD_ComputeBoundingBox(self, aBoardEdgesOnly)

   def GetBoundingBox(self):
        """
        GetBoundingBox(BOARD self) -> EDA_RECT

        const EDA_RECT
        BOARD::GetBoundingBox() const

        Function GetBoundingBox may be called soon after ComputeBoundingBox()
        to return the same EDA_RECT, as long as the BOARD has not changed.

        Remember, ComputeBoundingBox()'s aBoardEdgesOnly argument is
        considered in this return value also.
        """
        return _pcbnew.BOARD_GetBoundingBox(self)

   def SetBoundingBox(self, *args):
        """
        SetBoundingBox(BOARD self, EDA_RECT aBox)

        void
        BOARD::SetBoundingBox(const EDA_RECT &aBox)
        """
        return _pcbnew.BOARD_SetBoundingBox(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(BOARD self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        BOARD::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.BOARD_GetMsgPanelInfo(self, *args)

   def Draw(self, *args):
        """
        Draw(BOARD self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(BOARD self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void BOARD::Draw(EDA_DRAW_PANEL
        *aPanel, wxDC *aDC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw.

        Redraw the BOARD items but not cursors, axis or grid.

        Parameters:
        -----------

        aPanel:  = the panel relative to the board

        aDC:  = the current device context

        aDrawMode:  = GR_COPY, GR_OR ... (not always used)

        aOffset:  = an draw offset value (default = 0,0)
        """
        return _pcbnew.BOARD_Draw(self, *args)

   def DrawHighLight(self, *args):
        """
        DrawHighLight(BOARD self, EDA_DRAW_PANEL * aDrawPanel, wxDC * aDC, int aNetCode)

        void
        BOARD::DrawHighLight(EDA_DRAW_PANEL *aDrawPanel, wxDC *aDC, int
        aNetCode)

        Function DrawHighLight redraws the objects in the board that are
        associated with the given aNetCode and turns on or off the brilliance
        associated with that net according to the current value of global
        g_HighLight_Status.

        Parameters:
        -----------

        aDrawPanel:  is needed for the clipping support.

        aDC:  = the current device context

        aNetCode:  is the net number to highlight or to dim.
        """
        return _pcbnew.BOARD_DrawHighLight(self, *args)

   def Visit(self, *args):
        """
        Visit(BOARD self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        BOARD::Visit(INSPECTOR *inspector, const void *testData, const KICAD_T
        scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT - SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.BOARD_Visit(self, *args)

   def FindModuleByReference(self, *args):
        """
        FindModuleByReference(BOARD self, wxString const & aReference) -> MODULE

        MODULE *
        BOARD::FindModuleByReference(const wxString &aReference) const

        Function FindModuleByReference searches for a MODULE within this board
        with the given reference designator.

        Finds only the first one, if there is more than one such MODULE.

        Parameters:
        -----------

        aReference:  The reference designator of the MODULE to find.

        MODULE* - If found, the MODULE having the given reference designator,
        else NULL.
        """
        return _pcbnew.BOARD_FindModuleByReference(self, *args)

   def FindModule(self, *args):
        """
        FindModule(BOARD self, wxString const & aRefOrTimeStamp, bool aSearchByTimeStamp=False) -> MODULE
        FindModule(BOARD self, wxString const & aRefOrTimeStamp) -> MODULE

        MODULE *
        BOARD::FindModule(const wxString &aRefOrTimeStamp, bool
        aSearchByTimeStamp=false) const

        Function FindModule searches for a module matching aRefOrTimeStamp
        depending on the state of aSearchByTimeStamp.

        Parameters:
        -----------

        aRefOrTimeStamp:  is the search string.

        aSearchByTimeStamp:  searches by the module time stamp value if true.
        Otherwise search by reference designator.

        MODULE* - If found, the module meeting the search criteria, else NULL.

        """
        return _pcbnew.BOARD_FindModule(self, *args)

   def ReplaceNetlist(self, *args):
        """
        ReplaceNetlist(BOARD self, NETLIST & aNetlist, bool aDeleteSinglePadNets, REPORTER * aReporter=None)
        ReplaceNetlist(BOARD self, NETLIST & aNetlist, bool aDeleteSinglePadNets)

        void
        BOARD::ReplaceNetlist(NETLIST &aNetlist, bool aDeleteSinglePadNets,
        REPORTER *aReporter=NULL)

        Function ReplaceNetlist updates the BOARD according to aNetlist.

        The changes are made to the board are as follows they are not disabled
        in the status settings in the NETLIST: If a new component is found in
        the NETLIST and not in the BOARD, it is added to the BOARD.

        If a the component in the NETLIST is already on the BOARD, then one or
        more of the following actions can occur: If the footprint name in the
        NETLIST does not match the footprint name on the BOARD, the footprint
        on the BOARD is replaced with the footprint specified in the NETLIST
        and the proper parameters are copied from the existing footprint.

        If the reference designator in the NETLIST does not match the
        reference designator on the BOARD, the reference designator is updated
        from the NETLIST.

        If the value field in the NETLIST does not match the value field on
        the BOARD, the value field is updated from the NETLIST.

        If the time stamp in the NETLIST does not match the time stamp on the
        BOARD, the time stamp is updated from the NETLIST.

        After each footprint is added or update as described above, each
       footprint pad net name is compared and updated to the value defined in
        the NETLIST.

        After all of the footprints have been added, updated, and net names
        properly set, any extra unlock footprints are removed from the BOARD.

        Parameters:
        -----------

        aNetlist:  is the new netlist to revise the contents of the BOARD
        with.

        aDeleteSinglePadNets:  if true, remove nets counting only one pad and
        set net code to 0 for these pads

        aReporter:  is a REPORTER object to report the changes aNetlist makes
        to the BOARD. If NULL, no change reporting occurs.
        """
        return _pcbnew.BOARD_ReplaceNetlist(self, *args)

   def SortedNetnamesList(self, *args):
        """
        SortedNetnamesList(BOARD self, wxArrayString & aNames, bool aSortbyPadsCount) -> int

        int
        BOARD::SortedNetnamesList(wxArrayString &aNames, bool
        aSortbyPadsCount)

        Function SortedNetnamesList.

        Parameters:
        -----------

        aNames:  An array string to fill with net names.

        aSortbyPadsCount:  true = sort by active pads count, false = no sort
        (i.e. leave the sort by net names)

        int - net names count.
        """
        return _pcbnew.BOARD_SortedNetnamesList(self, *args)

   def SynchronizeNetsAndNetClasses(self):
        """
        SynchronizeNetsAndNetClasses(BOARD self)

        void
        BOARD::SynchronizeNetsAndNetClasses()

        Function SynchronizeNetsAndNetClasses copies NETCLASS info to each
        NET, based on NET membership in a NETCLASS.

        Must be called after a Design Rules edition, or after reading a
        netlist (or editing the list of nets) Also this function removes the
       non existing nets in netclasses and add net nets in default netclass
        (this happens after reading a netlist)
        """
        return _pcbnew.BOARD_SynchronizeNetsAndNetClasses(self)

   def GetClass(self):
        """
        GetClass(BOARD self) -> wxString

        wxString BOARD::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.BOARD_GetClass(self)

   def HitTestForAnyFilledArea(self, *args):
        """
        HitTestForAnyFilledArea(BOARD self, wxPoint aRefPos, LAYER_ID aStartLayer, LAYER_ID aEndLayer, int aNetCode) -> ZONE_CONTAINER

        ZONE_CONTAINER
        * BOARD::HitTestForAnyFilledArea(const wxPoint &aRefPos, LAYER_ID
        aStartLayer, LAYER_ID aEndLayer, int aNetCode)

        Function HitTestForAnyFilledArea tests if the given wxPoint is within
        the bounds of a filled area of this zone.

        the test is made on zones on layer from aStartLayer to aEndLayer Note:
        if a zone has its flag BUSY (in .m_State) is set, it is ignored.

        Parameters:
        -----------

        aRefPos:  A wxPoint to test

        aStartLayer:  the first layer to test

        aEndLayer:  the last layer to test

        aNetCode:  = the netcode used to filter zones (-1 to to test all
        zones)

        ZONE_CONTAINER* return a pointer to the ZONE_CONTAINER found, else
        NULL
        """
        return _pcbnew.BOARD_HitTestForAnyFilledArea(self, *args)

   def RedrawAreasOutlines(self, *args):
        """
        RedrawAreasOutlines(BOARD self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, LAYER_ID aLayer)

        void
        BOARD::RedrawAreasOutlines(EDA_DRAW_PANEL *aPanel, wxDC *aDC,
        GR_DRAWMODE aDrawMode, LAYER_ID aLayer)

        Function RedrawAreasOutlines Redraw all areas outlines on layer aLayer
        ( redraw all if aLayer < 0 )
        """
        return _pcbnew.BOARD_RedrawAreasOutlines(self, *args)

   def RedrawFilledAreas(self, *args):
        """
        RedrawFilledAreas(BOARD self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, LAYER_ID aLayer)

        void
        BOARD::RedrawFilledAreas(EDA_DRAW_PANEL *aPanel, wxDC *aDC,
        GR_DRAWMODE aDrawMode, LAYER_ID aLayer)

        Function RedrawFilledAreas Redraw all filled areas on layer aLayer (
        redraw all if aLayer < 0 )
        """
        return _pcbnew.BOARD_RedrawFilledAreas(self, *args)

   def SetAreasNetCodesFromNetNames(self):
        """
        SetAreasNetCodesFromNetNames(BOARD self) -> int

        int
        BOARD::SetAreasNetCodesFromNetNames(void)

        Function SetAreasNetCodesFromNetNames Set the .m_NetCode member of all
        copper areas, according to the area Net Name The
        SetNetCodesFromNetNames is an equivalent to net name, for fast
        comparisons.

        However the Netcode is an arbitrary equivalence, it must be set after
        each netlist read or net change Must be called after pad netcodes are
        calculated : error count For non copper areas, netcode is set to 0
        """
        return _pcbnew.BOARD_SetAreasNetCodesFromNetNames(self)

   def GetArea(self, *args):
        """
        GetArea(BOARD self, int index) -> ZONE_CONTAINER

        ZONE_CONTAINER*
        BOARD::GetArea(int index) const

        Function GetArea returns the Area (Zone Container) at a given index.

        Parameters:
        -----------

        index:  The array type index into a collection of ZONE_CONTAINER *.

        ZONE_CONTAINER* - a pointer to the Area or NULL if index out of range.

        """
        return _pcbnew.BOARD_GetArea(self, *args)

   def GetAreaIndex(self, *args):
        """
        GetAreaIndex(BOARD self, ZONE_CONTAINER aArea) -> int

        int
        BOARD::GetAreaIndex(const ZONE_CONTAINER *aArea) const

        Function GetAreaIndex returns the Area Index for the given Zone
        Container.

        Parameters:
        -----------

        aArea:  :The ZONE_CONTAINER to find.

        an Area Index in m_ZoneDescriptorList or -1 if non found.
        """
        return _pcbnew.BOARD_GetAreaIndex(self, *args)

   def GetAreaCount(self):
        """
        GetAreaCount(BOARD self) -> int

        int BOARD::GetAreaCount()
        const

        Function GetAreaCount.

        int - The number of Areas or ZONE_CONTAINER.
        """
        return _pcbnew.BOARD_GetAreaCount(self)

   def AddArea(self, *args):
        """
        AddArea(BOARD self, PICKED_ITEMS_LIST * aNewZonesList, int aNetcode, LAYER_ID aLayer, wxPoint aStartPointPosition,
            int aHatch) -> ZONE_CONTAINER

        ZONE_CONTAINER *
        BOARD::AddArea(PICKED_ITEMS_LIST *aNewZonesList, int aNetcode,
        LAYER_ID aLayer, wxPoint aStartPointPosition, int aHatch)

        Function AddArea Add an empty copper area to board areas list.

        Parameters:
        -----------

        aNewZonesList:  = a PICKED_ITEMS_LIST * where to store new areas
        pickers (useful in undo commands) can be NULL

        aNetcode:  = the netcode of the copper area (0 = no net)

        aLayer:  = the layer of area

        aStartPointPosition:  = position of the first point of the polygon
        outline of this area

        aHatch:  = hatch option

        a reference to the new area
        """
        return _pcbnew.BOARD_AddArea(self, *args)

   def InsertArea(self, *args):
        """
        InsertArea(BOARD self, int netcode, int iarea, LAYER_ID layer, int x, int y, int hatch) -> ZONE_CONTAINER

        ZONE_CONTAINER *
        BOARD::InsertArea(int netcode, int iarea, LAYER_ID layer, int x, int
        y, int hatch)

        Function InsertArea add empty copper area to net, inserting after
        m_ZoneDescriptorList[iarea].

        pointer to the new area
        """
        return _pcbnew.BOARD_InsertArea(self, *args)

   def NormalizeAreaPolygon(self, *args):
        """
        NormalizeAreaPolygon(BOARD self, PICKED_ITEMS_LIST * aNewZonesList, ZONE_CONTAINER aCurrArea) -> bool

        bool
        BOARD::NormalizeAreaPolygon(PICKED_ITEMS_LIST *aNewZonesList,
        ZONE_CONTAINER *aCurrArea)

        Function NormalizeAreaPolygon Process an area that has been modified,
        by normalizing its polygon against itself.

        i.e. convert a self-intersecting polygon to one (or more) non self-
        intersecting polygon(s) This may change the number and order of copper
        areas in the net.

        Parameters:
        -----------

        aNewZonesList:  = a PICKED_ITEMS_LIST * where to store new created
        areas pickers

        aCurrArea:  = the zone to process

        true if changes are made
        """
        return _pcbnew.BOARD_NormalizeAreaPolygon(self, *args)

   def OnAreaPolygonModified(self, *args):
        """
        OnAreaPolygonModified(BOARD self, PICKED_ITEMS_LIST * aModifiedZonesList, ZONE_CONTAINER modified_area) -> bool

        bool
        BOARD::OnAreaPolygonModified(PICKED_ITEMS_LIST *aModifiedZonesList,
        ZONE_CONTAINER *modified_area)

        Function OnAreaPolygonModified Process an area that has been modified,
        by normalizing its polygon and merging the intersecting polygons for
        any other areas on the same net.

        This may change the number and order of copper areas in the net.

        Parameters:
        -----------

        aModifiedZonesList:  = a PICKED_ITEMS_LIST * where to store deleted or
        added areas (useful in undo commands can be NULL

        modified_area:  = area to test

        true if some areas modified
        """
        return _pcbnew.BOARD_OnAreaPolygonModified(self, *args)

   def CombineAllAreasInNet(self, *args):
        """
        CombineAllAreasInNet(BOARD self, PICKED_ITEMS_LIST * aDeletedList, int aNetCode, bool aUseLocalFlags) -> bool

        bool
        BOARD::CombineAllAreasInNet(PICKED_ITEMS_LIST *aDeletedList, int
        aNetCode, bool aUseLocalFlags)

        Function CombineAllAreasInNet Checks all copper areas in net for
        intersections, combining them if found.

        Parameters:
        -----------

        aDeletedList:  = a PICKED_ITEMS_LIST * where to store deleted areas
        (useful in undo commands can be NULL

        aNetCode:  = net to consider

        aUseLocalFlags:  : if true, don't check areas if both local flags are
        0 Sets local flag = 1 for any areas modified

        true if some areas modified
        """
        return _pcbnew.BOARD_CombineAllAreasInNet(self, *args)

   def RemoveArea(self, *args):
        """
        RemoveArea(BOARD self, PICKED_ITEMS_LIST * aDeletedList, ZONE_CONTAINER area_to_remove)

        void
        BOARD::RemoveArea(PICKED_ITEMS_LIST *aDeletedList, ZONE_CONTAINER
        *area_to_remove)

        Function RemoveArea remove copper area from net, and put it in a
        deleted list (if exists)

        Parameters:
        -----------

        aDeletedList:  = a PICKED_ITEMS_LIST * where to store deleted areas
        (useful in undo commands can be NULL

        area_to_remove:  = area to delete or put in deleted list
        """
        return _pcbnew.BOARD_RemoveArea(self, *args)

   def TestAreaIntersections(self, *args):
        """
        TestAreaIntersections(BOARD self, ZONE_CONTAINER area_to_test) -> bool

        bool
        BOARD::TestAreaIntersections(ZONE_CONTAINER *area_to_test)

        Function TestAreaIntersections Check for intersection of a given
        copper area with other areas in same net.

        Parameters:
        -----------

        area_to_test:  = area to compare to all other areas in the same net
        """
        return _pcbnew.BOARD_TestAreaIntersections(self, *args)

   def TestAreaIntersection(self, *args):
        """
        TestAreaIntersection(BOARD self, ZONE_CONTAINER area_ref, ZONE_CONTAINER area_to_test) -> bool

        bool
        BOARD::TestAreaIntersection(ZONE_CONTAINER *area_ref, ZONE_CONTAINER
        *area_to_test)

        Function TestAreaIntersection Test for intersection of 2 copper areas
        area_to_test must be after area_ref in m_ZoneDescriptorList.

        Parameters:
        -----------

        area_ref:  = area reference

        area_to_test:  = area to compare for intersection calculations

        : false if no intersection, true if intersection
        """
        return _pcbnew.BOARD_TestAreaIntersection(self, *args)

   def CombineAreas(self, *args):
        """
        CombineAreas(BOARD self, PICKED_ITEMS_LIST * aDeletedList, ZONE_CONTAINER area_ref, ZONE_CONTAINER area_to_combine) -> bool

        bool
        BOARD::CombineAreas(PICKED_ITEMS_LIST *aDeletedList, ZONE_CONTAINER
        *area_ref, ZONE_CONTAINER *area_to_combine)

        Function CombineAreas If possible, combine 2 copper areas.

        Parameters:
        -----------

        aDeletedList:  = a PICKED_ITEMS_LIST * where to store deleted areas
        (useful for undo).

        area_ref:  = the main area (zone)

        area_to_combine:  = the zone that can be merged with area_ref area_ref
        must be BEFORE area_to_combine area_to_combine will be deleted, if
        areas are combined

        : true if area_to_combine is combined with area_ref (and therefore be
        deleted)
        """
        return _pcbnew.BOARD_CombineAreas(self, *args)

   def Test_Drc_Areas_Outlines_To_Areas_Outlines(self, *args):
        """
        Test_Drc_Areas_Outlines_To_Areas_Outlines(BOARD self, ZONE_CONTAINER aArea_To_Examine, bool aCreate_Markers) -> int

        int
        BOARD::Test_Drc_Areas_Outlines_To_Areas_Outlines(ZONE_CONTAINER
        *aArea_To_Examine, bool aCreate_Markers)

        Function Test_Drc_Areas_Outlines_To_Areas_Outlines tests area outlines
        for DRC: Tests areas inside other areas.

        Tests areas too close.

        Parameters:
        -----------

        aArea_To_Examine:  area to compare with other areas, or if NULL then
        all areas are compared to all others.

        aCreate_Markers:  if true create DRC markers. False: do not creates
        anything

        errors count
        """
        return _pcbnew.BOARD_Test_Drc_Areas_Outlines_To_Areas_Outlines(self, *args)

   def Test_Connections_To_Copper_Areas(self, *args):
        """
        Test_Connections_To_Copper_Areas(BOARD self, int aNetcode=-1)
        Test_Connections_To_Copper_Areas(BOARD self)

        void
        BOARD::Test_Connections_To_Copper_Areas(int aNetcode=-1)

        Function Test_Connection_To_Copper_Areas init .m_ZoneSubnet parameter
        in tracks and pads according to the connections to areas found.

        Parameters:
        -----------

        aNetcode:  = netcode to analyze. if -1, analyze all nets

        aNetcode:  = netcode to analyse. if -1, analyse all nets
        """
        return _pcbnew.BOARD_Test_Connections_To_Copper_Areas(self, *args)

   def GetViaByPosition(self, *args):
        """
        GetViaByPosition(BOARD self, wxPoint aPosition, LAYER_ID aLayer=UNDEFINED_LAYER) -> VIA
        GetViaByPosition(BOARD self, wxPoint aPosition) -> VIA

        VIA *
        BOARD::GetViaByPosition(const wxPoint &aPosition, LAYER_ID
        aLayer=UNDEFINED_LAYER) const

        Function GetViaByPosition finds the first via at aPosition on aLayer.

        This function does not use the normal hit test to locate a via which
        which tests if a position is within the via's bounding box. It tests
        for the actual locate of the via.

        Parameters:
        -----------

        aPosition:  The wxPoint to HitTest() against.

        aLayer:  The layer to search. Use -1 for a don't care.

        VIA* A point a to the VIA object if found, else NULL.
        """
        return _pcbnew.BOARD_GetViaByPosition(self, *args)

   def GetPadFast(self, *args):
        """
        GetPadFast(BOARD self, wxPoint aPosition, LSET aLayerMask) -> D_PAD

        D_PAD *
        BOARD::GetPadFast(const wxPoint &aPosition, LSET aLayerMask)

        Function GetPadFast return pad found at aPosition on aLayerMask using
        the fast search method.

        The fast search method only works if the pad list has already been
        built.

        Parameters:
        -----------

        aPosition:  A wxPoint object containing the position to hit test.

        aLayerMask:  A layer or layers to mask the hit test.

        A pointer to a D_PAD object if found or NULL if not found.
        """
        return _pcbnew.BOARD_GetPadFast(self, *args)

   def GetPad(self, *args):
        """
        GetPad(BOARD self, unsigned int aIndex) -> D_PAD
        GetPad(BOARD self, wxPoint aPosition, LSET aLayerMask) -> D_PAD
        GetPad(BOARD self, wxPoint aPosition) -> D_PAD
        GetPad(BOARD self, TRACK aTrace, ENDPOINT_T aEndPoint) -> D_PAD
        GetPad(BOARD self, std::vector< D_PAD *,std::allocator< D_PAD * > > & aPadList, wxPoint aPosition, LSET aLayerMask) -> D_PAD

        D_PAD *
        BOARD::GetPad(std::vector< D_PAD * > &aPadList, const wxPoint
        &aPosition, LSET aLayerMask)

        Function GetPad locates the pad connected at aPosition on aLayer
        starting at list position aPad.

        This function uses a fast search in this sorted pad list and it is
        faster than GetPadFast(). This list is a sorted pad list must be built
        before calling this function.

        The normal pad list is sorted by increasing netcodes.

        Parameters:
        -----------

        aPadList:  = the list of pads candidates (a std::vector<D_PAD*>)

        aPosition:  A wxPoint object containing the position to test.

        aLayerMask:  A layer or layers to mask the hit test.

        a D_PAD object pointer to the connected pad.
        """
        return _pcbnew.BOARD_GetPad(self, *args)

   def GetSortedPadListByXthenYCoord(self, *args):
        """
        GetSortedPadListByXthenYCoord(BOARD self, std::vector< D_PAD *,std::allocator< D_PAD * > > & aVector, int aNetCode=-1)
        GetSortedPadListByXthenYCoord(BOARD self, std::vector< D_PAD *,std::allocator< D_PAD * > > & aVector)

        void
        BOARD::GetSortedPadListByXthenYCoord(std::vector< D_PAD * > &aVector,
        int aNetCode=-1)

        Function GetSortedPadListByXthenYCoord first empties then fills the
        vector with all pads and sorts them by increasing x coordinate, and
        for increasing y coordinate for same values of x coordinates.

        The vector only holds pointers to the pads and those pointers are only
        references to pads which are owned by the BOARD through other links.

        Parameters:
        -----------

        aVector:  Where to put the pad pointers.

        aNetCode:  = the netcode filter: = -1 to build the full pad list. = a
        given netcode to build the pad list relative to the given net
        """
        return _pcbnew.BOARD_GetSortedPadListByXthenYCoord(self, *args)

   def GetTrack(self, *args):
        """
        GetTrack(BOARD self, TRACK aTrace, wxPoint aPosition, LSET aLayerMask) -> TRACK

        TRACK * BOARD::GetTrack(TRACK
        *aTrace, const wxPoint &aPosition, LSET aLayerMask) const

        Function GetTrack find the segment of aTrace at aPosition on aLayer if
        Layer is visible.

        Traces that are flagged as deleted or busy are ignored.

        Parameters:
        -----------

        aTrace:  A pointer to the TRACK object to search.

        aPosition:  A wxPoint object containing the position to test.

        aLayerMask:  A layer or layers to mask the hit test. Use -1 to ignore
        layer mask.

        A TRACK object pointer if found otherwise NULL.
        """
        return _pcbnew.BOARD_GetTrack(self, *args)

   def MarkTrace(self, *args):
        """
        MarkTrace(BOARD self, TRACK aTrace, int * aCount, double * aTraceLength, double * aInPackageLength, bool aReorder) -> TRACK

        TRACK *
        BOARD::MarkTrace(TRACK *aTrace, int *aCount, double *aTraceLength,
        double *aInPackageLength, bool aReorder)

        Function MarkTrace marks a chain of trace segments, connected to
        aTrace.

        Each segment is marked by setting the BUSY bit into m_Flags.
        Electrical continuity is detected by walking each segment, and finally
        the segments are rearranged into a contiguous chain within the given
        list.

        Parameters:
        -----------

        aTrace:  The segment within a list of trace segments to test.

        aCount:  A pointer to an integer where to return the number of marked
        segments.

        aTraceLength:  A pointer to an double where to return the length of
        the trace.

        aInPackageLength:  A pointer to an double where to return the extra
        lengths inside integrated circuits from the pads connected to this
        track to the die (if any).

        aReorder:  true for reorder the interesting segments (useful for track
        edition/deletion) in this case the flag BUSY is set (the user is
        responsible of flag clearing). False for no reorder : useful when we
        want just calculate the track length in this case, flags are reset

        TRACK* The first in the chain of interesting segments.
        """
        return _pcbnew.BOARD_MarkTrace(self, *args)

   def GetFootprint(self, *args):
        """
        GetFootprint(BOARD self, wxPoint aPosition, LAYER_ID aActiveLayer, bool aVisibleOnly, bool aIgnoreLocked=False) -> MODULE
        GetFootprint(BOARD self, wxPoint aPosition, LAYER_ID aActiveLayer, bool aVisibleOnly) -> MODULE

        MODULE *
        BOARD::GetFootprint(const wxPoint &aPosition, LAYER_ID aActiveLayer,
        bool aVisibleOnly, bool aIgnoreLocked=false)

        Function GetFootprint get a footprint by its bounding rectangle at
        aPosition on aLayer.

        If more than one footprint is at aPosition, then the closest footprint
        on the active layer is returned. The distance is calculated via
        manhattan distance from the center of the bounding rectangle to
        aPosition.

        Parameters:
        -----------

        aPosition:  A wxPoint object containing the position to test.

        aActiveLayer:  Layer to test.

        aVisibleOnly:  Search only the visible layers if true.

        aIgnoreLocked:  Ignore locked modules when true.

        MODULE* The best module or NULL if none.
        """
        return _pcbnew.BOARD_GetFootprint(self, *args)

   def GetLockPoint(self, *args):
        """
        GetLockPoint(BOARD self, wxPoint aPosition, LSET aLayerMask) -> BOARD_CONNECTED_ITEM

        BOARD_CONNECTED_ITEM *
        BOARD::GetLockPoint(const wxPoint &aPosition, LSET aLayerMask)

        Function GetLockPoint returns the item at the "attachment" point at
        the end of a trace at aPosition on aLayerMask.

        This may be a PAD or another trace segment.

        Parameters:
        -----------

        aPosition:  A wxPoint object containing the position to test.

        aLayerMask:  A layer or layers to mask the hit test. Use -1 to ignore
        layer mask.

        A pointer to a BOARD_ITEM object if found otherwise NULL.
        """
        return _pcbnew.BOARD_GetLockPoint(self, *args)

   def CreateLockPoint(self, *args):
        """
        CreateLockPoint(BOARD self, wxPoint aPosition, TRACK aSegment, PICKED_ITEMS_LIST * aList) -> TRACK

        TRACK *
        BOARD::CreateLockPoint(wxPoint &aPosition, TRACK *aSegment,
        PICKED_ITEMS_LIST *aList)

        Function CreateLockPoint creates an intermediate point on aSegment and
        break it into two segments at aPosition.

        The new segment starts from aPosition and ends at the end point of
        aSegment. The original segment now ends at aPosition.

        Parameters:
        -----------

        aPosition:  A wxPoint object containing the position to test and the
        new segment start position if the return value is not NULL.

        aSegment:  The trace segment to create the lock point on.

        aList:  The pick list to add the created items to.

        NULL if no new point was created or a pointer to a TRACK ojbect of the
        created segment. If aSegment points to a via the exact value of
        aPosition and a pointer to the via are returned.
        """
        return _pcbnew.BOARD_CreateLockPoint(self, *args)

   def GetModules(self):             return self.m_Modules
   def GetDrawings(self):            return self.m_Drawings
   def GetTracks(self):              return self.m_Track
   def GetFullRatsnest(self):        return self.m_FullRatsnest

   def Save(self,filename):
        return SaveBoard(filename,self,IO_MGR.KICAD)






   def Add(self,item):
        item.thisown=0
        self.AddNative(item)

   def GetNetClasses(self):
        return self.GetDesignSettings().m_NetClasses

   def GetCurrentNetClassName(self):
        return self.GetDesignSettings().m_CurrentNetClassName

   def GetViasDimensionsList(self):
        return self.GetDesignSettings().m_ViasDimensionsList

   def GetTrackWidthList(self):
        return self.GetDesignSettings().m_TrackWidthList

BOARD_swigregister = _pcbnew.BOARD_swigregister
BOARD_swigregister(BOARD)

def BOARD_ClassOf(*args):
  """BOARD_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.BOARD_ClassOf(*args)
ADD_APPEND = _pcbnew.ADD_APPEND

def BOARD_GetStandardLayerName(*args):
  """BOARD_GetStandardLayerName(LAYER_ID aLayerId) -> wxString const"""
  return _pcbnew.BOARD_GetStandardLayerName(*args)

MOD_DEFAULT = _pcbnew.MOD_DEFAULT
MOD_CMS = _pcbnew.MOD_CMS
MOD_VIRTUAL = _pcbnew.MOD_VIRTUAL
class MODULE(BOARD_ITEM):
    """C++ includes: class_module.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MODULE, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MODULE, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(MODULE self, BOARD parent) -> MODULE
        __init__(MODULE self, MODULE aModule) -> MODULE

        MODULE::MODULE(const MODULE
        &aModule)
        """
        this = _pcbnew.new_MODULE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_MODULE
    __del__ = lambda self : None;
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.MODULE_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
   def Next(self):
        """
        Next(MODULE self) -> MODULE

        MODULE* MODULE::Next() const
        """
        return _pcbnew.MODULE_Next(self)

   def Back(self):
        """
        Back(MODULE self) -> MODULE

        MODULE* MODULE::Back() const
        """
        return _pcbnew.MODULE_Back(self)

   def Copy(self, *args):
        """
        Copy(MODULE self, MODULE Module)

        void MODULE::Copy(MODULE
        *Module)
        """
        return _pcbnew.MODULE_Copy(self, *args)

   def AddChild(self, *args):
        """
        AddChild(MODULE self, BOARD_ITEM aBoardItem, bool doAppend=True)
        AddChild(MODULE self, BOARD_ITEM aBoardItem)

        void MODULE::Add(BOARD_ITEM
        *aBoardItem, bool doAppend=true)
        """
        return _pcbnew.MODULE_AddChild(self, *args)

   def DeleteChild(self, *args):
        """
        DeleteChild(MODULE self, BOARD_ITEM aBoardItem)

        void MODULE::Delete(BOARD_ITEM
        *aBoardItem)

        Function Delete removes the given single item from this MODULE and
        deletes its memory.

        Parameters:
        -----------

        aBoardItem:  The item to remove from this module and delete
        """
        return _pcbnew.MODULE_DeleteChild(self, *args)

   def RemoveChild(self, *args):
        """
        RemoveChild(MODULE self, BOARD_ITEM aBoardItem) -> BOARD_ITEM

        BOARD_ITEM *
        MODULE::Remove(BOARD_ITEM *aBoardItem)

        Function Remove removes aBoardItem from this MODULE and returns it to
        caller without deleting it.

        Parameters:
        -----------

        aBoardItem:  The item to remove from this module.

        BOARD_ITEM* aBoardItem which was passed in.
        """
        return _pcbnew.MODULE_RemoveChild(self, *args)

   def CalculateBoundingBox(self):
        """
        CalculateBoundingBox(MODULE self)

        void
        MODULE::CalculateBoundingBox()

        Function CalculateBoundingBox calculates the bounding box in board
        coordinates.
        """
        return _pcbnew.MODULE_CalculateBoundingBox(self)

   def GetFootprintRect(self):
        """
        GetFootprintRect(MODULE self) -> EDA_RECT

        EDA_RECT
        MODULE::GetFootprintRect() const

        Function GetFootprintRect() Returns the area of the module footprint
        excluding any text.

        EDA_RECT - The rectangle containing the footprint.
        """
        return _pcbnew.MODULE_GetFootprintRect(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(MODULE self) -> EDA_RECT

        const EDA_RECT
        MODULE::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.MODULE_GetBoundingBox(self)

   def Pads(self, *args):
        """
        Pads(MODULE self) -> PAD_List
        Pads(MODULE self) -> PAD_List

        const DLIST<D_PAD>&
        MODULE::Pads() const
        """
        return _pcbnew.MODULE_Pads(self, *args)

   def GraphicalItems(self, *args):
        """
        GraphicalItems(MODULE self) -> BOARD_ITEM_List
        GraphicalItems(MODULE self) -> BOARD_ITEM_List

        const
        DLIST<BOARD_ITEM>& MODULE::GraphicalItems() const
        """
        return _pcbnew.MODULE_GraphicalItems(self, *args)

   def Models(self, *args):
        """
        Models(MODULE self) -> DLIST< S3D_MASTER >
        Models(MODULE self) -> DLIST< S3D_MASTER > const &

        const DLIST<S3D_MASTER>&
        MODULE::Models() const
        """
        return _pcbnew.MODULE_Models(self, *args)

   def SetPosition(self, *args):
        """
        SetPosition(MODULE self, wxPoint aPos)

        void
        MODULE::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.MODULE_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(MODULE self) -> wxPoint

        const wxPoint&
        MODULE::GetPosition() const
        """
        return _pcbnew.MODULE_GetPosition(self)

   def SetOrientation(self, *args):
        """
        SetOrientation(MODULE self, double newangle)

        void
        MODULE::SetOrientation(double newangle)
        """
        return _pcbnew.MODULE_SetOrientation(self, *args)

   def GetOrientation(self):
        """
        GetOrientation(MODULE self) -> double

        double
        MODULE::GetOrientation() const
        """
        return _pcbnew.MODULE_GetOrientation(self)

   def GetFPID(self):
        """
        GetFPID(MODULE self) -> FPID

        const FPID& MODULE::GetFPID()
        const
        """
        return _pcbnew.MODULE_GetFPID(self)

   def SetFPID(self, *args):
        """
        SetFPID(MODULE self, FPID aFPID)

        void MODULE::SetFPID(const
        FPID &aFPID)
        """
        return _pcbnew.MODULE_SetFPID(self, *args)

   def GetDescription(self):
        """
        GetDescription(MODULE self) -> wxString const &

        const wxString&
        MODULE::GetDescription() const
        """
        return _pcbnew.MODULE_GetDescription(self)

   def SetDescription(self, *args):
        """
        SetDescription(MODULE self, wxString const & aDoc)

        void
        MODULE::SetDescription(const wxString &aDoc)
        """
        return _pcbnew.MODULE_SetDescription(self, *args)

   def GetKeywords(self):
        """
        GetKeywords(MODULE self) -> wxString const &

        const wxString&
        MODULE::GetKeywords() const
        """
        return _pcbnew.MODULE_GetKeywords(self)

   def SetKeywords(self, *args):
        """
        SetKeywords(MODULE self, wxString const & aKeywords)

        void
        MODULE::SetKeywords(const wxString &aKeywords)
        """
        return _pcbnew.MODULE_SetKeywords(self, *args)

   def GetPath(self):
        """
        GetPath(MODULE self) -> wxString const &

        const wxString&
        MODULE::GetPath() const
        """
        return _pcbnew.MODULE_GetPath(self)

   def SetPath(self, *args):
        """
        SetPath(MODULE self, wxString const & aPath)

        void MODULE::SetPath(const
        wxString &aPath)
        """
        return _pcbnew.MODULE_SetPath(self, *args)

   def GetLocalSolderMaskMargin(self):
        """
        GetLocalSolderMaskMargin(MODULE self) -> int

        int
        MODULE::GetLocalSolderMaskMargin() const
        """
        return _pcbnew.MODULE_GetLocalSolderMaskMargin(self)

   def SetLocalSolderMaskMargin(self, *args):
        """
        SetLocalSolderMaskMargin(MODULE self, int aMargin)

        void
        MODULE::SetLocalSolderMaskMargin(int aMargin)
        """
        return _pcbnew.MODULE_SetLocalSolderMaskMargin(self, *args)

   def GetLocalClearance(self):
        """
        GetLocalClearance(MODULE self) -> int

        int
        MODULE::GetLocalClearance() const
        """
        return _pcbnew.MODULE_GetLocalClearance(self)

   def SetLocalClearance(self, *args):
        """
        SetLocalClearance(MODULE self, int aClearance)

        void
        MODULE::SetLocalClearance(int aClearance)
        """
        return _pcbnew.MODULE_SetLocalClearance(self, *args)

   def GetLocalSolderPasteMargin(self):
        """
        GetLocalSolderPasteMargin(MODULE self) -> int

        int
        MODULE::GetLocalSolderPasteMargin() const
        """
        return _pcbnew.MODULE_GetLocalSolderPasteMargin(self)

   def SetLocalSolderPasteMargin(self, *args):
        """
        SetLocalSolderPasteMargin(MODULE self, int aMargin)

        void
        MODULE::SetLocalSolderPasteMargin(int aMargin)
        """
        return _pcbnew.MODULE_SetLocalSolderPasteMargin(self, *args)

   def GetLocalSolderPasteMarginRatio(self):
        """
        GetLocalSolderPasteMarginRatio(MODULE self) -> double

        double
        MODULE::GetLocalSolderPasteMarginRatio() const
        """
        return _pcbnew.MODULE_GetLocalSolderPasteMarginRatio(self)

   def SetLocalSolderPasteMarginRatio(self, *args):
        """
        SetLocalSolderPasteMarginRatio(MODULE self, double aRatio)

        void
        MODULE::SetLocalSolderPasteMarginRatio(double aRatio)
        """
        return _pcbnew.MODULE_SetLocalSolderPasteMarginRatio(self, *args)

   def SetZoneConnection(self, *args):
        """
        SetZoneConnection(MODULE self, ZoneConnection aType)

        void
        MODULE::SetZoneConnection(ZoneConnection aType)
        """
        return _pcbnew.MODULE_SetZoneConnection(self, *args)

   def GetZoneConnection(self):
        """
        GetZoneConnection(MODULE self) -> ZoneConnection

        ZoneConnection
        MODULE::GetZoneConnection() const
        """
        return _pcbnew.MODULE_GetZoneConnection(self)

   def SetThermalWidth(self, *args):
        """
        SetThermalWidth(MODULE self, int aWidth)

        void
        MODULE::SetThermalWidth(int aWidth)
        """
        return _pcbnew.MODULE_SetThermalWidth(self, *args)

   def GetThermalWidth(self):
        """
        GetThermalWidth(MODULE self) -> int

        int
        MODULE::GetThermalWidth() const
        """
        return _pcbnew.MODULE_GetThermalWidth(self)

   def SetThermalGap(self, *args):
        """
        SetThermalGap(MODULE self, int aGap)

        void
        MODULE::SetThermalGap(int aGap)
        """
        return _pcbnew.MODULE_SetThermalGap(self, *args)

   def GetThermalGap(self):
        """
        GetThermalGap(MODULE self) -> int

        int
        MODULE::GetThermalGap() const
        """
        return _pcbnew.MODULE_GetThermalGap(self)

   def GetAttributes(self):
        """
        GetAttributes(MODULE self) -> int

        int
        MODULE::GetAttributes() const
        """
        return _pcbnew.MODULE_GetAttributes(self)

   def SetAttributes(self, *args):
        """
        SetAttributes(MODULE self, int aAttributes)

        void
        MODULE::SetAttributes(int aAttributes)
        """
        return _pcbnew.MODULE_SetAttributes(self, *args)

   def SetFlag(self, *args):
        """
        SetFlag(MODULE self, int aFlag)

        void MODULE::SetFlag(int
        aFlag)
        """
        return _pcbnew.MODULE_SetFlag(self, *args)

   def IncrementFlag(self):
        """
        IncrementFlag(MODULE self)

        void
        MODULE::IncrementFlag()
        """
        return _pcbnew.MODULE_IncrementFlag(self)

   def GetFlag(self):
        """
        GetFlag(MODULE self) -> int

        int MODULE::GetFlag() const

        """
        return _pcbnew.MODULE_GetFlag(self)

   def Move(self, *args):
        """
        Move(MODULE self, wxPoint aMoveVector)

        void MODULE::Move(const wxPoint
        &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.MODULE_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(MODULE self, wxPoint aRotCentre, double aAngle)

        void MODULE::Rotate(const
        wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.MODULE_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(MODULE self, wxPoint aCentre)

        void MODULE::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.

        Mirror the Y position
        """
        return _pcbnew.MODULE_Flip(self, *args)

   def MoveAnchorPosition(self, *args):
        """
        MoveAnchorPosition(MODULE self, wxPoint aMoveVector)

        void
        MODULE::MoveAnchorPosition(const wxPoint &aMoveVector)

        Function MoveAnchorPosition Move the reference point of the footprint
        It looks like a move footprint: the footprints elements (pads,
        outlines, edges .

        . ) are moved However: the footprint position is not modified.

        the relative (local) coordinates of these items are modified (a move
        footprint does not change these local coordinates, but changes the
        footprint position)
        """
        return _pcbnew.MODULE_MoveAnchorPosition(self, *args)

   def IsFlipped(self):
        """
        IsFlipped(MODULE self) -> bool

        bool MODULE::IsFlipped()
        const

        function IsFlipped

        true if the module is flipped, i.e. on the back side of the board
        """
        return _pcbnew.MODULE_IsFlipped(self)

   def IsLocked(self):
        """
        IsLocked(MODULE self) -> bool

        bool MODULE::IsLocked()
        const

        Function IsLocked.

        bool - true if the object is locked, else false
        """
        return _pcbnew.MODULE_IsLocked(self)

   def SetLocked(self, *args):
        """
        SetLocked(MODULE self, bool isLocked)

        void MODULE::SetLocked(bool
        isLocked)

        Function SetLocked sets the MODULE_is_LOCKED bit in the
        m_ModuleStatus.

        Parameters:
        -----------

        isLocked:  When true means turn on locked status, else unlock
        """
        return _pcbnew.MODULE_SetLocked(self, *args)

   def IsPlaced(self):
        """
        IsPlaced(MODULE self) -> bool

        bool MODULE::IsPlaced()
        const
        """
        return _pcbnew.MODULE_IsPlaced(self)

   def SetIsPlaced(self, *args):
        """
        SetIsPlaced(MODULE self, bool isPlaced)

        void
        MODULE::SetIsPlaced(bool isPlaced)
        """
        return _pcbnew.MODULE_SetIsPlaced(self, *args)

   def NeedsPlaced(self):
        """
        NeedsPlaced(MODULE self) -> bool

        bool
        MODULE::NeedsPlaced() const
        """
        return _pcbnew.MODULE_NeedsPlaced(self)

   def SetNeedsPlaced(self, *args):
        """
        SetNeedsPlaced(MODULE self, bool needsPlaced)

        void
        MODULE::SetNeedsPlaced(bool needsPlaced)
        """
        return _pcbnew.MODULE_SetNeedsPlaced(self, *args)

   def SetLastEditTime(self, *args):
        """
        SetLastEditTime(MODULE self, time_t aTime)
        SetLastEditTime(MODULE self)

        void
        MODULE::SetLastEditTime()
        """
        return _pcbnew.MODULE_SetLastEditTime(self, *args)

   def GetLastEditTime(self):
        """
        GetLastEditTime(MODULE self) -> time_t

        time_t
        MODULE::GetLastEditTime() const
        """
        return _pcbnew.MODULE_GetLastEditTime(self)

   def Draw(self, *args):
        """
        Draw(MODULE self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(MODULE self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void MODULE::Draw(EDA_DRAW_PANEL
        *aPanel, wxDC *aDC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw draws the footprint to the aDC.

        Parameters:
        -----------

        aPanel:  = draw panel, Used to know the clip box

        aDC:  = Current Device Context

        aDrawMode:  = GR_OR, GR_XOR..

        aOffset:  = draw offset (usually wxPoint(0,0)
        """
        return _pcbnew.MODULE_Draw(self, *args)

   def ReadAndInsert3DComponentShape(self, *args):
        """
        ReadAndInsert3DComponentShape(MODULE self, EDA_3D_CANVAS * glcanvas, bool aAllowNonTransparentObjects, bool aAllowTransparentObjects,
            bool aSideToLoad)

        void
        MODULE::ReadAndInsert3DComponentShape(EDA_3D_CANVAS *glcanvas, bool
        aAllowNonTransparentObjects, bool aAllowTransparentObjects, bool
        aSideToLoad)

        function ReadandInsert3DComponentShape read the 3D component shape(s)
        of the footprint (physical shape) and insert mesh in gl list

        Parameters:
        -----------

        glcanvas:  = the openGL canvas

        aAllowNonTransparentObjects:  = true to load non transparent objects

        aAllowTransparentObjects:  = true to load non transparent objects

        aSideToLoad:  = false will load not fliped, true will load fliped
        objects in openGL, transparent objects should be drawn after non
        transparent objects
        """
        return _pcbnew.MODULE_ReadAndInsert3DComponentShape(self, *args)

   def TransformPadsShapesWithClearanceToPolygon(self, *args):
        """
        TransformPadsShapesWithClearanceToPolygon(MODULE self, LAYER_ID aLayer, CPOLYGONS_LIST aCornerBuffer, int aInflateValue, int aCircleToSegmentsCount,
            double aCorrectionFactor)

        void
        MODULE::TransformPadsShapesWithClearanceToPolygon(LAYER_ID aLayer,
        CPOLYGONS_LIST &aCornerBuffer, int aInflateValue, int
        aCircleToSegmentsCount, double aCorrectionFactor)

        function TransformPadsShapesWithClearanceToPolygon generate pads
        shapes on layer aLayer as polygons, and adds these polygons to
        aCornerBuffer Useful to generate a polygonal representation of a
        footprint in 3D view and plot functions, when a full polygonal
        approach is needed

        Parameters:
        -----------

        aLayer:  = the current layer: pads on this layer are considered

        aCornerBuffer:  = the buffer to store polygons

        aInflateValue:  = an additionnal size to add to pad shapes
        aInflateValue = 0 to have the exact pad size

        aCircleToSegmentsCount:  = number of segments to generate a circle

        aCorrectionFactor:  = the correction to apply to a circle radius to
        approximate a circle by the polygon. if aCorrectionFactor = 1.0, the
        polygon is inside the circle the radius of circle approximated by
        segments is initial radius * aCorrectionFactor
        """
        return _pcbnew.MODULE_TransformPadsShapesWithClearanceToPolygon(self, *args)

   def TransformGraphicShapesWithClearanceToPolygonSet(self, *args):
        """
        TransformGraphicShapesWithClearanceToPolygonSet(MODULE self, LAYER_ID aLayer, CPOLYGONS_LIST aCornerBuffer, int aInflateValue, int aCircleToSegmentsCount,
            double aCorrectionFactor)

        void
        MODULE::TransformGraphicShapesWithClearanceToPolygonSet(LAYER_ID
        aLayer, CPOLYGONS_LIST &aCornerBuffer, int aInflateValue, int
        aCircleToSegmentsCount, double aCorrectionFactor)

        function TransformGraphicShapesWithClearanceToPolygonSet generate
        shapes of graphic items (outlines) on layer aLayer as polygons, and
        adds these polygons to aCornerBuffer Useful to generate a polygonal
        representation of a footprint in 3D view and plot functions, when a
        full polygonal approach is needed

        Parameters:
        -----------

        aLayer:  = the current layer: items on this layer are considered

        aCornerBuffer:  = the buffer to store polygons

        aInflateValue:  = a value to inflate shapes aInflateValue = 0 to have
        the exact shape size

        aCircleToSegmentsCount:  = number of segments to generate a circle

        aCorrectionFactor:  = the correction to apply to a circle radius to
        approximate a circle by the polygon. if aCorrectionFactor = 1.0, the
        polygon is inside the circle the radius of circle approximated by
        segments is initial radius * aCorrectionFactor
        """
        return _pcbnew.MODULE_TransformGraphicShapesWithClearanceToPolygonSet(self, *args)

   def DrawEdgesOnly(self, *args):
        """
        DrawEdgesOnly(MODULE self, EDA_DRAW_PANEL * panel, wxDC * DC, wxPoint offset, GR_DRAWMODE draw_mode)

        void
        MODULE::DrawEdgesOnly(EDA_DRAW_PANEL *panel, wxDC *DC, const wxPoint
        &offset, GR_DRAWMODE draw_mode)

        Function DrawEdgesOnly Draws the footprint edges only to the current
        Device Context.

        Parameters:
        -----------

        panel:  = The active Draw Panel (used to know the clip box)

        DC:  = current Device Context

        offset:  = draw offset (usually wxPoint(0,0)

        draw_mode:  = GR_OR, GR_XOR, GR_AND
        """
        return _pcbnew.MODULE_DrawEdgesOnly(self, *args)

   def DrawAncre(self, *args):
        """
        DrawAncre(MODULE self, EDA_DRAW_PANEL * panel, wxDC * DC, wxPoint offset, int dim_ancre, GR_DRAWMODE draw_mode)

        void
        MODULE::DrawAncre(EDA_DRAW_PANEL *panel, wxDC *DC, const wxPoint
        &offset, int dim_ancre, GR_DRAWMODE draw_mode)
        """
        return _pcbnew.MODULE_DrawAncre(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(MODULE self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        MODULE::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.MODULE_GetMsgPanelInfo(self, *args)

   def HitTest(self, *args):
        """
        HitTest(MODULE self, wxPoint aPosition) -> bool
        HitTest(MODULE self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(MODULE self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(MODULE self, EDA_RECT aRect) -> bool

        bool MODULE::HitTest(const
        EDA_RECT &aRect, bool aContained=true, int aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.MODULE_HitTest(self, *args)

   def GetReference(self):
        """
        GetReference(MODULE self) -> wxString const &

        const wxString&
        MODULE::GetReference() const

        Function GetReference.

        const wxString& - the reference designator text.
        """
        return _pcbnew.MODULE_GetReference(self)

   def SetReference(self, *args):
        """
        SetReference(MODULE self, wxString const & aReference)

        void
        MODULE::SetReference(const wxString &aReference)

        Function SetReference.

        Parameters:
        -----------

        aReference:  A reference to a wxString object containing the reference
        designator text.
        """
        return _pcbnew.MODULE_SetReference(self, *args)

   def GetValue(self):
        """
        GetValue(MODULE self) -> wxString const &

        const wxString&
        MODULE::GetValue() const

        Function GetValue.

        const wxString& - the value text.
        """
        return _pcbnew.MODULE_GetValue(self)

   def SetValue(self, *args):
        """
        SetValue(MODULE self, wxString const & aValue)

        void MODULE::SetValue(const
        wxString &aValue)

        Function SetValue.

        Parameters:
        -----------

        aValue:  A reference to a wxString object containing the value text.

        """
        return _pcbnew.MODULE_SetValue(self, *args)

   def Value(self, *args):
        """
        Value(MODULE self) -> TEXTE_MODULE
        Value(MODULE self) -> TEXTE_MODULE

        TEXTE_MODULE& MODULE::Value()
        const

        The const versions to keep the compiler happy.
        """
        return _pcbnew.MODULE_Value(self, *args)

   def Reference(self, *args):
        """
        Reference(MODULE self) -> TEXTE_MODULE
        Reference(MODULE self) -> TEXTE_MODULE

        TEXTE_MODULE&
        MODULE::Reference() const
        """
        return _pcbnew.MODULE_Reference(self, *args)

   def FindPadByName(self, *args):
        """
        FindPadByName(MODULE self, wxString const & aPadName) -> D_PAD

        D_PAD *
        MODULE::FindPadByName(const wxString &aPadName) const

        Function FindPadByName returns a D_PAD* with a matching name.

        Note that names may not be unique, depending on how the foot print was
        created.

        Parameters:
        -----------

        aPadName:  the pad name to find

        D_PAD* - The first matching name is returned, or NULL if not found.
        """
        return _pcbnew.MODULE_FindPadByName(self, *args)

   def GetPad(self, *args):
        """
        GetPad(MODULE self, wxPoint aPosition, LSET aLayerMask=LSET::AllLayersMask()) -> D_PAD
        GetPad(MODULE self, wxPoint aPosition) -> D_PAD

        D_PAD * MODULE::GetPad(const
        wxPoint &aPosition, LSET aLayerMask=LSET::AllLayersMask())

        Function GetPad get a pad at aPosition on aLayerMask in the footprint.

        Parameters:
        -----------

        aPosition:  A wxPoint object containing the position to hit test.

        aLayerMask:  A layer or layers to mask the hit test.

        A pointer to a D_PAD object if found otherwise NULL.
        """
        return _pcbnew.MODULE_GetPad(self, *args)

    DO_NOT_INCLUDE_NPTH = _pcbnew.MODULE_DO_NOT_INCLUDE_NPTH
    INCLUDE_NPTH = _pcbnew.MODULE_INCLUDE_NPTH
   def GetPadCount(self, *args):
        """
        GetPadCount(MODULE self, MODULE::INCLUDE_NPTH_T aIncludeNPTH=INCLUDE_NPTH) -> unsigned int
        GetPadCount(MODULE self) -> unsigned int

        unsigned
        MODULE::GetPadCount(INCLUDE_NPTH_T aIncludeNPTH=INCLUDE_NPTH) const

        GetPadCount returns the number of pads.

        Parameters:
        -----------

        aIncludeNPTH:  includes non-plated through holes when true. Does not
        include non- plated through holes when false.

        the number of pads according to aIncludeNPTH.
        """
        return _pcbnew.MODULE_GetPadCount(self, *args)

   def GetArea(self):
        """
        GetArea(MODULE self) -> double

        double MODULE::GetArea()
        const
        """
        return _pcbnew.MODULE_GetArea(self)

   def GetLink(self):
        """
        GetLink(MODULE self) -> time_t

        time_t MODULE::GetLink()
        const
        """
        return _pcbnew.MODULE_GetLink(self)

   def SetLink(self, *args):
        """
        SetLink(MODULE self, time_t aLink)

        void MODULE::SetLink(time_t
        aLink)
        """
        return _pcbnew.MODULE_SetLink(self, *args)

   def GetPlacementCost180(self):
        """
        GetPlacementCost180(MODULE self) -> int

        int
        MODULE::GetPlacementCost180() const
        """
        return _pcbnew.MODULE_GetPlacementCost180(self)

   def SetPlacementCost180(self, *args):
        """
        SetPlacementCost180(MODULE self, int aCost)

        void
        MODULE::SetPlacementCost180(int aCost)
        """
        return _pcbnew.MODULE_SetPlacementCost180(self, *args)

   def GetPlacementCost90(self):
        """
        GetPlacementCost90(MODULE self) -> int

        int
        MODULE::GetPlacementCost90() const
        """
        return _pcbnew.MODULE_GetPlacementCost90(self)

   def SetPlacementCost90(self, *args):
        """
        SetPlacementCost90(MODULE self, int aCost)

        void
        MODULE::SetPlacementCost90(int aCost)
        """
        return _pcbnew.MODULE_SetPlacementCost90(self, *args)

   def Add3DModel(self, *args):
        """
        Add3DModel(MODULE self, S3D_MASTER * a3DModel)

        void
        MODULE::Add3DModel(S3D_MASTER *a3DModel)

       Function Add3DModel adds a3DModel definition to the end of the 3D
        model list.

        Parameters:
        -----------

        a3DModel:  A pointer to a S3D_MASTER to add to the list.
        """
        return _pcbnew.MODULE_Add3DModel(self, *args)

   def Visit(self, *args):
        """
        Visit(MODULE self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        MODULE::Visit(INSPECTOR *inspector, const void *testData, const
        KICAD_T scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.MODULE_Visit(self, *args)

   def GetClass(self):
        """
        GetClass(MODULE self) -> wxString

        wxString MODULE::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.MODULE_GetClass(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(MODULE self) -> wxString

        wxString
        MODULE::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.MODULE_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(MODULE self) -> BITMAP_DEF

        BITMAP_DEF
        MODULE::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.MODULE_GetMenuImage(self)

   def Clone(self):
        """
        Clone(MODULE self) -> EDA_ITEM

        EDA_ITEM * MODULE::Clone()
        const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.MODULE_Clone(self)

   def RunOnChildren(self, *args):
        """
        RunOnChildren(MODULE self, boost::function< void (BOARD_ITEM *) > aFunction)

        void
        MODULE::RunOnChildren(boost::function< void(BOARD_ITEM *)> aFunction)

        Function RunOnChildren.

        Invokes a function on all BOARD_ITEMs that belong to the module (pads,
        drawings, texts).

        Parameters:
        -----------

        aFunction:  is the function to be invoked.
        """
        return _pcbnew.MODULE_RunOnChildren(self, *args)

   def ViewUpdate(self, *args):
        """
        ViewUpdate(MODULE self, int aUpdateFlags=KIGFX::VIEW_ITEM::ALL)
        ViewUpdate(MODULE self)

        void
        MODULE::ViewUpdate(int aUpdateFlags=KIGFX::VIEW_ITEM::ALL)
        """
        return _pcbnew.MODULE_ViewUpdate(self, *args)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(MODULE self, int [] aLayers, int & aCount)

        void
        MODULE::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.MODULE_ViewGetLayers(self, *args)

   def ViewGetLOD(self, *args):
        """
        ViewGetLOD(MODULE self, int aLayer) -> unsigned int

        unsigned int
        MODULE::ViewGetLOD(int aLayer) const
        """
        return _pcbnew.MODULE_ViewGetLOD(self, *args)

   def ViewBBox(self):
        """
        ViewBBox(MODULE self) -> BOX2I const

        const BOX2I
        MODULE::ViewBBox() const
        """
        return _pcbnew.MODULE_ViewBBox(self)

   def CopyNetlistSettings(self, *args):
        """
        CopyNetlistSettings(MODULE self, MODULE aModule)

        void
        MODULE::CopyNetlistSettings(MODULE *aModule)

        Function CopyNetlistSettings copies the netlist settings to aModule.

       The netlist settings are all of the MODULE settings not define by a
        MODULE in a netlist. These setting include position, orientation,
        local clearances, ets. The reference designator, value, path, and
        physical geometry settings are not copied.

        Parameters:
        -----------

        aModule:  is the MODULE to copy the settings to.
        """
        return _pcbnew.MODULE_CopyNetlistSettings(self, *args)

   def IsLibNameValid(*args):
        """IsLibNameValid(wxString const & aName) -> bool"""
        return _pcbnew.MODULE_IsLibNameValid(*args)

    if _newclass:IsLibNameValid = staticmethod(IsLibNameValid)
    __swig_getmethods__["IsLibNameValid"] = lambda x: IsLibNameValid
   def StringLibNameInvalidChars(*args):
        """StringLibNameInvalidChars(bool aUserReadable) -> wxChar const *"""
        return _pcbnew.MODULE_StringLibNameInvalidChars(*args)

    if _newclass:StringLibNameInvalidChars = staticmethod(StringLibNameInvalidChars)
    __swig_getmethods__["StringLibNameInvalidChars"] = lambda x: StringLibNameInvalidChars
   def SetInitialComments(self, *args):
        """
        SetInitialComments(MODULE self, wxArrayString * aInitialComments)

        void
        MODULE::SetInitialComments(wxArrayString *aInitialComments)

        Function SetInitialComments takes ownership of caller's heap allocated
        aInitialComments block.

        The comments are single line strings already containing the
        s-expression comments with optional leading whitespace and then a '#'
        character followed by optional single line text (text with no line
        endings, not even one). This block of single line comments will be
        output upfront of any generated s-expression text in the
        PCBIO::Format() function.

        Note that a block of single line comments constitutes a multiline
        block of single line comments. That is, the block is made of
        consecutive single line comments.

        Parameters:
        -----------

        aInitialComments:  is a heap allocated wxArrayString or NULL, which
        the caller gives up ownership of over to this MODULE.
        """
        return _pcbnew.MODULE_SetInitialComments(self, *args)

   def GetInitialComments(self):
        """
        GetInitialComments(MODULE self) -> wxArrayString const *

        const
        wxArrayString* MODULE::GetInitialComments() const

        Return the initial comments block or NULL if none, without transfer of
        ownership.
        """
        return _pcbnew.MODULE_GetInitialComments(self)

   def Add(self,item):

        itemC = item.Cast()

        if type(itemC) is D_PAD:
            item.thisown=0
            self.Pads().PushBack(itemC)
        elif type(itemC) in [ TEXTE_PCB, DIMENSION, TEXTE_MODULE, DRAWSEGMENT,EDGE_MODULE]:
            item.thisown = 0
            self.GraphicalItems().PushBack(item)

MODULE_swigregister = _pcbnew.MODULE_swigregister
MODULE_swigregister(MODULE)

def MODULE_ClassOf(*args):
  """MODULE_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.MODULE_ClassOf(*args)
MODULE_is_LOCKED = _pcbnew.MODULE_is_LOCKED
MODULE_is_PLACED = _pcbnew.MODULE_is_PLACED
MODULE_to_PLACE = _pcbnew.MODULE_to_PLACE

def MODULE_IsLibNameValid(*args):
  """MODULE_IsLibNameValid(wxString const & aName) -> bool"""
  return _pcbnew.MODULE_IsLibNameValid(*args)

def MODULE_StringLibNameInvalidChars(*args):
  """MODULE_StringLibNameInvalidChars(bool aUserReadable) -> wxChar const *"""
  return _pcbnew.MODULE_StringLibNameInvalidChars(*args)

VIA_THROUGH = _pcbnew.VIA_THROUGH
VIA_BLIND_BURIED = _pcbnew.VIA_BLIND_BURIED
VIA_MICROVIA = _pcbnew.VIA_MICROVIA
VIA_NOT_DEFINED = _pcbnew.VIA_NOT_DEFINED
UNDEFINED_DRILL_DIAMETER = _pcbnew.UNDEFINED_DRILL_DIAMETER
MIN_VIA_DRAW_SIZE = _pcbnew.MIN_VIA_DRAW_SIZE

def GetTrack(*args):
  """GetTrack(TRACK aStartTrace, TRACK aEndTrace, wxPoint aPosition, LSET aLayerMask) -> TRACK"""
  return _pcbnew.GetTrack(*args)
class TRACK(BOARD_CONNECTED_ITEM):
    """C++ includes: class_track.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_CONNECTED_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TRACK, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_CONNECTED_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TRACK, name)
    __repr__ = _swig_repr
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.TRACK_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
    __swig_setmethods__["start"] = _pcbnew.TRACK_start_set
    __swig_getmethods__["start"] = _pcbnew.TRACK_start_get
    if _newclass:start = _swig_property(_pcbnew.TRACK_start_get, _pcbnew.TRACK_start_set)
    __swig_setmethods__["end"] = _pcbnew.TRACK_end_set
    __swig_getmethods__["end"] = _pcbnew.TRACK_end_get
    if _newclass:end = _swig_property(_pcbnew.TRACK_end_get, _pcbnew.TRACK_end_set)
    __swig_setmethods__["m_Param"] = _pcbnew.TRACK_m_Param_set
    __swig_getmethods__["m_Param"] = _pcbnew.TRACK_m_Param_get
    if _newclass:m_Param = _swig_property(_pcbnew.TRACK_m_Param_get, _pcbnew.TRACK_m_Param_set)
   def __init__(self, *args):
        """
        __init__(TRACK self, BOARD_ITEM aParent, KICAD_T idtype=PCB_TRACE_T) -> TRACK
        __init__(TRACK self, BOARD_ITEM aParent) -> TRACK

        TRACK::TRACK(BOARD_ITEM
        *aParent, KICAD_T idtype=PCB_TRACE_T)
        """
        this = _pcbnew.new_TRACK(*args)
        try: self.this.append(this)
        except: self.this = this
   def Next(self):
        """
        Next(TRACK self) -> TRACK

        TRACK* TRACK::Next() const
        """
        return _pcbnew.TRACK_Next(self)

   def Back(self):
        """
        Back(TRACK self) -> TRACK

        TRACK* TRACK::Back() const
        """
        return _pcbnew.TRACK_Back(self)

   def Move(self, *args):
        """
        Move(TRACK self, wxPoint aMoveVector)

        virtual void TRACK::Move(const
        wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.TRACK_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(TRACK self, wxPoint aRotCentre, double aAngle)

        void TRACK::Rotate(const
        wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.TRACK_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(TRACK self, wxPoint aCentre)

        void TRACK::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.TRACK_Flip(self, *args)

   def SetPosition(self, *args):
        """
        SetPosition(TRACK self, wxPoint aPos)

        void
        TRACK::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.TRACK_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(TRACK self) -> wxPoint

        const wxPoint&
        TRACK::GetPosition() const
        """
        return _pcbnew.TRACK_GetPosition(self)

   def SetWidth(self, *args):
        """
        SetWidth(TRACK self, int aWidth)

        void TRACK::SetWidth(int
        aWidth)
        """
        return _pcbnew.TRACK_SetWidth(self, *args)

   def GetWidth(self):
        """
        GetWidth(TRACK self) -> int

        int TRACK::GetWidth() const

        """
        return _pcbnew.TRACK_GetWidth(self)

   def SetEnd(self, *args):
        """
        SetEnd(TRACK self, wxPoint aEnd)

        void TRACK::SetEnd(const
        wxPoint &aEnd)
        """
        return _pcbnew.TRACK_SetEnd(self, *args)

   def GetEnd(self):
        """
        GetEnd(TRACK self) -> wxPoint

        const wxPoint& TRACK::GetEnd()
        const
        """
        return _pcbnew.TRACK_GetEnd(self)

   def SetStart(self, *args):
        """
        SetStart(TRACK self, wxPoint aStart)

        void TRACK::SetStart(const
        wxPoint &aStart)
        """
        return _pcbnew.TRACK_SetStart(self, *args)

   def GetStart(self):
        """
        GetStart(TRACK self) -> wxPoint

        const wxPoint&
        TRACK::GetStart() const
        """
        return _pcbnew.TRACK_GetStart(self)

   def GetEndPoint(self, *args):
        """
        GetEndPoint(TRACK self, ENDPOINT_T aEndPoint) -> wxPoint

        const wxPoint&
        TRACK::GetEndPoint(ENDPOINT_T aEndPoint) const

        Return the selected endpoint (start or end)
        """
        return _pcbnew.TRACK_GetEndPoint(self, *args)

   def GetBoundingBox(self):
        """
        GetBoundingBox(TRACK self) -> EDA_RECT

        const EDA_RECT
        TRACK::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.TRACK_GetBoundingBox(self)

   def GetBestInsertPoint(self, *args):
        """
        GetBestInsertPoint(TRACK self, BOARD aPcb) -> TRACK

        TRACK *
        TRACK::GetBestInsertPoint(BOARD *aPcb)

        Function GetBestInsertPoint searches the "best" insertion point
        within the track linked list.

        The best point is the begging of the corresponding net code section.
        (The BOARD::m_Track and BOARD::m_Zone lists are sorted by netcode.)

        Parameters:
        -----------

        aPcb:  The BOARD to search for the insertion point.

        TRACK* - the item found in the linked list (or NULL if no track)
        """
        return _pcbnew.TRACK_GetBestInsertPoint(self, *args)

   def GetStartNetCode(self, *args):
        """
        GetStartNetCode(TRACK self, int NetCode) -> TRACK

        TRACK *
        TRACK::GetStartNetCode(int NetCode)
        """
        return _pcbnew.TRACK_GetStartNetCode(self, *args)

   def GetEndNetCode(self, *args):
        """
        GetEndNetCode(TRACK self, int NetCode) -> TRACK

        TRACK *
        TRACK::GetEndNetCode(int NetCode)
        """
        return _pcbnew.TRACK_GetEndNetCode(self, *args)

   def GetLength(self):
        """
        GetLength(TRACK self) -> double

        double TRACK::GetLength()
        const

        Function GetLength returns the length of the track using the
        hypotenuse calculation.

        double - the length of the track
        """
        return _pcbnew.TRACK_GetLength(self)

   def Draw(self, *args):
        """
        Draw(TRACK self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(TRACK self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void TRACK::Draw(EDA_DRAW_PANEL
        *panel, wxDC *DC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.TRACK_Draw(self, *args)

   def TransformShapeWithClearanceToPolygon(self, *args):
        """
        TransformShapeWithClearanceToPolygon(TRACK self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount, double aCorrectionFactor)

        void TRACK::TransformShapeWithClearanceToPolygon(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount,
        double aCorrectionFactor) const

        Function TransformShapeWithClearanceToPolygon Convert the track shape
        to a closed polygon Used in filling zones calculations Circles (vias)
        and arcs (ends of tracks) are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the pad

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approximated by segment bigger or
        equal to the real clearance value (usually near from 1.0)
        """
        return _pcbnew.TRACK_TransformShapeWithClearanceToPolygon(self, *args)

   def GetLayerSet(self):
        """
        GetLayerSet(TRACK self) -> LSET

        LSET TRACK::GetLayerSet()
        const

        Function GetLayerMask returns a "layer mask", which is a bitmap of
        all layers on which the TRACK segment or VIA physically resides.

        int - a layer mask, see pcbstruct.h's LAYER_BACK, etc.
        """
        return _pcbnew.TRACK_GetLayerSet(self)

   def IsPointOnEnds(self, *args):
        """
        IsPointOnEnds(TRACK self, wxPoint point, int min_dist=0) -> STATUS_FLAGS
        IsPointOnEnds(TRACK self, wxPoint point) -> STATUS_FLAGS

        STATUS_FLAGS
        TRACK::IsPointOnEnds(const wxPoint &point, int min_dist=0)

        Function IsPointOnEnds returns STARTPOINT if point if near (dist =
        min_dist) start point, ENDPOINT if point if near (dist = min_dist) end
        point,STARTPOINT|ENDPOINT if point if near (dist = min_dist) both
        ends, or 0 if none of the above.

        if min_dist < 0: min_dist = track_width/2
        """
        return _pcbnew.TRACK_IsPointOnEnds(self, *args)

   def IsNull(self):
        """
        IsNull(TRACK self) -> bool

        bool TRACK::IsNull()

        Function IsNull returns true if segment length is zero.
        """
        return _pcbnew.TRACK_IsNull(self)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(TRACK self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        TRACK::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.TRACK_GetMsgPanelInfo(self, *args)

   def ShowWidth(self):
        """
        ShowWidth(TRACK self) -> wxString

        wxString TRACK::ShowWidth()
        const

        Function ShowWidth returns the width of the track in displayable user
        units.
        """
        return _pcbnew.TRACK_ShowWidth(self)

   def Visit(self, *args):
        """
        Visit(TRACK self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        TRACK::Visit(INSPECTOR *inspector, const void *testData, const KICAD_T
        scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.TRACK_Visit(self, *args)

   def HitTest(self, *args):
        """
        HitTest(TRACK self, wxPoint aPosition) -> bool
        HitTest(TRACK self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(TRACK self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(TRACK self, EDA_RECT aRect) -> bool

        bool TRACK::HitTest(const
        EDA_RECT &aRect, bool aContained=true, int aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.TRACK_HitTest(self, *args)

   def GetVia(self, *args):
        """
        GetVia(TRACK self, wxPoint aPosition, LAYER_ID aLayer=UNDEFINED_LAYER) -> VIA
        GetVia(TRACK self, wxPoint aPosition) -> VIA
        GetVia(TRACK self, TRACK aEndTrace, wxPoint aPosition, LSET aLayerMask) -> VIA

        VIA * TRACK::GetVia(TRACK
        *aEndTrace, const wxPoint &aPosition, LSET aLayerMask)

        Function GetVia finds the first VIA object at aPosition on aLayer
        starting at the trace and ending at aEndTrace.

        Parameters:
        -----------

        aEndTrace:  Pointer to the last TRACK object to end search.

        aPosition:  The wxPoint to HitTest() against.

        aLayerMask:  The layers to match, pass -1 for a don't care.

        A pointer to a VIA object if found, else NULL.
        """
        return _pcbnew.TRACK_GetVia(self, *args)

   def GetTrack(self, *args):
        """
        GetTrack(TRACK self, TRACK aStartTrace, TRACK aEndTrace, ENDPOINT_T aEndPoint, bool aSameNetOnly, bool aSequential) -> TRACK

        TRACK * TRACK::GetTrack(TRACK
        *aStartTrace, TRACK *aEndTrace, ENDPOINT_T aEndPoint, bool
        aSameNetOnly, bool aSequential)

        Function GetTrack return the trace segment connected to the segment at
        aEndPoint from aStartTrace to aEndTrace.

        Parameters:
        -----------

        aStartTrace:  A pointer to the TRACK object to begin searching.

        aEndTrace:  A pointer to the TRACK object to stop the search. A NULL
        value searches to the end of the list.

        aEndPoint:  The start or end point of the segment to test against.

        aSameNetOnly:  if true stop searching when the netcode changes

        aSequential:  If true, forces a forward sequential search, which is
       restartable; the default search can be faster but the position of the
        returned track in the list is unpredictable

        A TRACK object pointer if found otherwise NULL.
        """
        return _pcbnew.TRACK_GetTrack(self, *args)

   def GetEndSegments(self, *args):
        """
        GetEndSegments(TRACK self, int NbSegm, TRACK ** StartTrack, TRACK ** EndTrack) -> int

        int
        TRACK::GetEndSegments(int NbSegm, TRACK **StartTrack, TRACK
        **EndTrack)

        Function GetEndSegments get the segments connected to the end point of
        the track.

        return 1 if OK, 0 when a track is a closed loop and the beginning and
        the end of the track in *StartTrack and *EndTrack Modify *StartTrack
        en *EndTrack : (*StartTrack)->m_Start coordinate is the beginning of
        the track (*EndTrack)->m_End coordinate is the end of the track
        Segments connected must be consecutive in list
        """
        return _pcbnew.TRACK_GetEndSegments(self, *args)

   def GetClass(self):
        """
        GetClass(TRACK self) -> wxString

        wxString TRACK::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.TRACK_GetClass(self)

   def GetClearance(self, aItem=None):
        """
        GetClearance(TRACK self, BOARD_CONNECTED_ITEM aItem=None) -> int
        GetClearance(TRACK self) -> int

        int
        TRACK::GetClearance(BOARD_CONNECTED_ITEM *aItem=NULL) const

        Function GetClearance returns the clearance in internal units.

        If aItem is not NULL then the returned clearance is the greater of
        this object's clearance and aItem's clearance. If aItem is NULL, then
        this objects clearance is returned.

        Parameters:
        -----------

        aItem:  is another BOARD_CONNECTED_ITEM or NULL

        int - the clearance in internal units.
        """
        return _pcbnew.TRACK_GetClearance(self, aItem)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(TRACK self) -> wxString

        wxString
        TRACK::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.TRACK_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(TRACK self) -> BITMAP_DEF

        virtual BITMAP_DEF
        TRACK::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.TRACK_GetMenuImage(self)

   def Clone(self):
        """
        Clone(TRACK self) -> EDA_ITEM

        EDA_ITEM * TRACK::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.TRACK_Clone(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(TRACK self, int [] aLayers, int & aCount)

        void
        TRACK::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.TRACK_ViewGetLayers(self, *args)

   def ViewGetLOD(self, *args):
        """
        ViewGetLOD(TRACK self, int aLayer) -> unsigned int

        unsigned int
        TRACK::ViewGetLOD(int aLayer) const
        """
        return _pcbnew.TRACK_ViewGetLOD(self, *args)

    __swig_destroy__ = _pcbnew.delete_TRACK
    __del__ = lambda self : None;
TRACK_swigregister = _pcbnew.TRACK_swigregister
TRACK_swigregister(TRACK)

def TRACK_ClassOf(*args):
  """TRACK_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.TRACK_ClassOf(*args)

class SEGZONE(TRACK):
    """C++ includes: class_track.h """
    __swig_setmethods__ = {}
    for _s in [TRACK]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SEGZONE, name, value)
    __swig_getmethods__ = {}
    for _s in [TRACK]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SEGZONE, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(SEGZONE self, BOARD_ITEM aParent) -> SEGZONE

        SEGZONE::SEGZONE(BOARD_ITEM
        *aParent)
        """
        this = _pcbnew.new_SEGZONE(*args)
        try: self.this.append(this)
        except: self.this = this
   def GetClass(self):
        """
        GetClass(SEGZONE self) -> wxString

        wxString
        SEGZONE::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.SEGZONE_GetClass(self)

   def Next(self):
        """
        Next(SEGZONE self) -> SEGZONE

        SEGZONE* SEGZONE::Next() const

        """
        return _pcbnew.SEGZONE_Next(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(SEGZONE self) -> wxString

        wxString
        SEGZONE::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.SEGZONE_GetSelectMenuText(self)

   def Draw(self, *args):
        """
        Draw(SEGZONE self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(SEGZONE self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        SEGZONE::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE aDrawMode,
        const wxPoint &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.SEGZONE_Draw(self, *args)

   def GetMenuImage(self):
        """
        GetMenuImage(SEGZONE self) -> BITMAP_DEF

        BITMAP_DEF
        SEGZONE::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.SEGZONE_GetMenuImage(self)

   def Clone(self):
        """
        Clone(SEGZONE self) -> EDA_ITEM

        EDA_ITEM * SEGZONE::Clone()
        const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.SEGZONE_Clone(self)

    __swig_destroy__ = _pcbnew.delete_SEGZONE
    __del__ = lambda self : None;
SEGZONE_swigregister = _pcbnew.SEGZONE_swigregister
SEGZONE_swigregister(SEGZONE)

class VIA(TRACK):
    """C++ includes: class_track.h """
    __swig_setmethods__ = {}
    for _s in [TRACK]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VIA, name, value)
    __swig_getmethods__ = {}
    for _s in [TRACK]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, VIA, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(VIA self, BOARD_ITEM aParent) -> VIA

        VIA::VIA(BOARD_ITEM *aParent)
        """
        this = _pcbnew.new_VIA(*args)
        try: self.this.append(this)
        except: self.this = this
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.VIA_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
   def Draw(self, *args):
        """
        Draw(VIA self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(VIA self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void VIA::Draw(EDA_DRAW_PANEL
        *panel, wxDC *DC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.VIA_Draw(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(VIA self, LAYER_ID aLayer) -> bool

        bool VIA::IsOnLayer(LAYER_ID
        aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.VIA_IsOnLayer(self, *args)

   def GetLayerSet(self):
        """
        GetLayerSet(VIA self) -> LSET

        LSET VIA::GetLayerSet()
        const

        Function GetLayerMask returns a "layer mask", which is a bitmap of
        all layers on which the TRACK segment or VIA physically resides.

        int - a layer mask, see pcbstruct.h's LAYER_BACK, etc.
        """
        return _pcbnew.VIA_GetLayerSet(self)

   def SetLayerPair(self, *args):
        """
        SetLayerPair(VIA self, LAYER_ID aTopLayer, LAYER_ID aBottomLayer)

        void
        VIA::SetLayerPair(LAYER_ID aTopLayer, LAYER_ID aBottomLayer)

        Function SetLayerPair For a via m_Layer contains the top layer, the
        other layer is in m_BottomLayer.

        Parameters:
        -----------

        aTopLayer:  = first layer connected by the via

        aBottomLayer:  = last layer connected by the via
        """
        return _pcbnew.VIA_SetLayerPair(self, *args)

   def LayerPair(self, *args):
        """
        LayerPair(VIA self, LAYER_ID * top_layer, LAYER_ID * bottom_layer)

        void VIA::LayerPair(LAYER_ID
        *top_layer, LAYER_ID *bottom_layer) const

        Function LayerPair Return the 2 layers used by the via (the via
        actually uses all layers between these 2 layers)

        Parameters:
        -----------

        top_layer:  = pointer to the first layer (can be null)

        bottom_layer:  = pointer to the last layer (can be null)
        """
        return _pcbnew.VIA_LayerPair(self, *args)

   def GetPosition(self):
        """
        GetPosition(VIA self) -> wxPoint

        const wxPoint&
        VIA::GetPosition() const
        """
        return _pcbnew.VIA_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(VIA self, wxPoint aPoint)

        void VIA::SetPosition(const
        wxPoint &aPoint)
        """
        return _pcbnew.VIA_SetPosition(self, *args)

   def HitTest(self, *args):
        """
        HitTest(VIA self, wxPoint aPosition) -> bool
        HitTest(VIA self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(VIA self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(VIA self, EDA_RECT aRect) -> bool

        bool VIA::HitTest(const EDA_RECT
        &aRect, bool aContained=true, int aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.VIA_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(VIA self) -> wxString

        wxString VIA::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.VIA_GetClass(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(VIA self) -> wxString

        wxString
        VIA::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.VIA_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(VIA self) -> BITMAP_DEF

        BITMAP_DEF
        VIA::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.VIA_GetMenuImage(self)

   def Clone(self):
        """
        Clone(VIA self) -> EDA_ITEM

        EDA_ITEM * VIA::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.VIA_Clone(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(VIA self, int [] aLayers, int & aCount)

        void
        VIA::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.VIA_ViewGetLayers(self, *args)

   def Flip(self, *args):
        """
        Flip(VIA self, wxPoint aCentre)

        void VIA::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.VIA_Flip(self, *args)

   def GetViaType(self):
        """
        GetViaType(VIA self) -> VIATYPE_T

        VIATYPE_T VIA::GetViaType()
        const
        """
        return _pcbnew.VIA_GetViaType(self)

   def SetViaType(self, *args):
        """
        SetViaType(VIA self, VIATYPE_T aViaType)

        void
        VIA::SetViaType(VIATYPE_T aViaType)
        """
        return _pcbnew.VIA_SetViaType(self, *args)

   def SetDrill(self, *args):
        """
        SetDrill(VIA self, int aDrill)

        void VIA::SetDrill(int aDrill)

        Function SetDrill sets the drill value for vias.

        Parameters:
        -----------

        aDrill:  is the new drill diameter
        """
        return _pcbnew.VIA_SetDrill(self, *args)

   def GetDrill(self):
        """
        GetDrill(VIA self) -> int

        int VIA::GetDrill() const

        Function GetDrill returns the local drill setting for this VIA.

        If you want the calculated value, use GetDrillValue() instead.
        """
        return _pcbnew.VIA_GetDrill(self)

   def GetDrillValue(self):
        """
        GetDrillValue(VIA self) -> int

        int VIA::GetDrillValue()
        const

        Function GetDrillValue "calculates" the drill value for vias
       (m-Drill if > 0, or default drill value for the board.

        real drill_value
        """
        return _pcbnew.VIA_GetDrillValue(self)

   def SetDrillDefault(self):
        """
        SetDrillDefault(VIA self)

        void
        VIA::SetDrillDefault()

       Function SetDrillDefault sets the drill value for vias to the default
        value UNDEFINED_DRILL_DIAMETER.
        """
        return _pcbnew.VIA_SetDrillDefault(self)

   def IsDrillDefault(self):
        """
        IsDrillDefault(VIA self) -> bool

        bool
        VIA::IsDrillDefault() const

        Function IsDrillDefault.

       true if the drill value is default value (-1)
        """
        return _pcbnew.VIA_IsDrillDefault(self)

    __swig_destroy__ = _pcbnew.delete_VIA
    __del__ = lambda self : None;
VIA_swigregister = _pcbnew.VIA_swigregister
VIA_swigregister(VIA)

def VIA_ClassOf(*args):
  """VIA_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.VIA_ClassOf(*args)


def GetFirstVia(*args):
  """
    GetFirstVia(TRACK aTrk, TRACK aStopPoint=None) -> VIA
    GetFirstVia(TRACK aTrk) -> VIA
    """
  return _pcbnew.GetFirstVia(*args)
class SEGMENT(_object):
    """Proxy of C++ SEGMENT class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SEGMENT, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SEGMENT, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_Start"] = _pcbnew.SEGMENT_m_Start_set
    __swig_getmethods__["m_Start"] = _pcbnew.SEGMENT_m_Start_get
    if _newclass:m_Start = _swig_property(_pcbnew.SEGMENT_m_Start_get, _pcbnew.SEGMENT_m_Start_set)
    __swig_setmethods__["m_End"] = _pcbnew.SEGMENT_m_End_set
    __swig_getmethods__["m_End"] = _pcbnew.SEGMENT_m_End_get
    if _newclass:m_End = _swig_property(_pcbnew.SEGMENT_m_End_get, _pcbnew.SEGMENT_m_End_set)
   def __init__(self, *args):
        """
        __init__(SEGMENT self) -> SEGMENT
        __init__(SEGMENT self, wxPoint aStart, wxPoint aEnd) -> SEGMENT
        """
        this = _pcbnew.new_SEGMENT(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_SEGMENT
    __del__ = lambda self : None;
SEGMENT_swigregister = _pcbnew.SEGMENT_swigregister
SEGMENT_swigregister(SEGMENT)

class ZONE_CONTAINER(BOARD_CONNECTED_ITEM):
    """
   Class ZONE_CONTAINER handles a list of polygons defining a copper
    zone.

    A zone is described by a main polygon, a time stamp, a layer, and a
    net name. Other polygons inside the main polygon are holes in the
    zone.

    C++ includes: class_zone.h
    """
    __swig_setmethods__ = {}
    for _s in [BOARD_CONNECTED_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZONE_CONTAINER, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_CONNECTED_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, ZONE_CONTAINER, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(ZONE_CONTAINER self, BOARD parent) -> ZONE_CONTAINER
        __init__(ZONE_CONTAINER self, ZONE_CONTAINER aZone) -> ZONE_CONTAINER

        ZONE_CONTAINER::ZONE_CONTAINER(const ZONE_CONTAINER &aZone)
        """
        this = _pcbnew.new_ZONE_CONTAINER(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_ZONE_CONTAINER
    __del__ = lambda self : None;
   def GetPosition(self):
        """
        GetPosition(ZONE_CONTAINER self) -> wxPoint

        const wxPoint &
        ZONE_CONTAINER::GetPosition() const

        Function GetPosition.

        a wxPoint, position of the first point of the outline
        """
        return _pcbnew.ZONE_CONTAINER_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(ZONE_CONTAINER self, wxPoint aPos)

        void
        ZONE_CONTAINER::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.ZONE_CONTAINER_SetPosition(self, *args)

   def SetPriority(self, *args):
        """
        SetPriority(ZONE_CONTAINER self, unsigned int aPriority)

        void
        ZONE_CONTAINER::SetPriority(unsigned aPriority)

        Function SetPriority.

        Parameters:
        -----------

        aPriority:  = the priority level
        """
        return _pcbnew.ZONE_CONTAINER_SetPriority(self, *args)

   def GetPriority(self):
        """
        GetPriority(ZONE_CONTAINER self) -> unsigned int

        unsigned
        ZONE_CONTAINER::GetPriority() const

        Function GetPriority.

        the priority level of this zone
        """
        return _pcbnew.ZONE_CONTAINER_GetPriority(self)

   def Copy(self, *args):
        """
        Copy(ZONE_CONTAINER self, ZONE_CONTAINER src)

        void
        ZONE_CONTAINER::Copy(ZONE_CONTAINER *src)

        Function copy copy useful data from the source.

        flags and linked list pointers are NOT copied
        """
        return _pcbnew.ZONE_CONTAINER_Copy(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(ZONE_CONTAINER self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        ZONE_CONTAINER::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.ZONE_CONTAINER_GetMsgPanelInfo(self, *args)

   def Draw(self, *args):
        """
        Draw(ZONE_CONTAINER self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(ZONE_CONTAINER self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        ZONE_CONTAINER::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset=ZeroOffset)

        Function Draw Draws the zone outline.

        Parameters:
        -----------

        panel:  = current Draw Panel

        DC:  = current Device Context

        aDrawMode:  = GR_OR, GR_XOR, GR_COPY ..

        offset:  = Draw offset (usually wxPoint(0,0))
        """
        return _pcbnew.ZONE_CONTAINER_Draw(self, *args)

   def DrawFilledArea(self, *args):
        """
        DrawFilledArea(ZONE_CONTAINER self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        DrawFilledArea(ZONE_CONTAINER self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        ZONE_CONTAINER::DrawFilledArea(EDA_DRAW_PANEL *panel, wxDC *DC,
        GR_DRAWMODE aDrawMode, const wxPoint &offset=ZeroOffset)

        Function DrawDrawFilledArea Draws the filled area for this zone
        (polygon list .m_FilledPolysList)

        Parameters:
        -----------

        panel:  = current Draw Panel

        DC:  = current Device Context

        offset:  = Draw offset (usually wxPoint(0,0))

        aDrawMode:  = GR_OR, GR_XOR, GR_COPY ..
        """
        return _pcbnew.ZONE_CONTAINER_DrawFilledArea(self, *args)

   def DrawWhileCreateOutline(self, *args):
        """
        DrawWhileCreateOutline(ZONE_CONTAINER self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE draw_mode=GR_OR)
        DrawWhileCreateOutline(ZONE_CONTAINER self, EDA_DRAW_PANEL * panel, wxDC * DC)

        void
        ZONE_CONTAINER::DrawWhileCreateOutline(EDA_DRAW_PANEL *panel, wxDC
        *DC, GR_DRAWMODE draw_mode=GR_OR)

        Function DrawWhileCreateOutline Draws the zone outline when it is
        created.

        The moving edges are in XOR graphic mode, old segment in draw_mode
        graphic mode (usually GR_OR). The closing edge has its own shape.

        Parameters:
        -----------

        panel:  = current Draw Panel

        DC:  = current Device Context

        draw_mode:  = draw mode: OR, XOR ..
        """
        return _pcbnew.ZONE_CONTAINER_DrawWhileCreateOutline(self, *args)

   def GetBoundingBox(self):
        """
        GetBoundingBox(ZONE_CONTAINER self) -> EDA_RECT

        const EDA_RECT
        ZONE_CONTAINER::GetBoundingBox() const

        Function GetBoundingBox (virtual)

        an EDA_RECT that is the bounding box of the zone outline
        """
        return _pcbnew.ZONE_CONTAINER_GetBoundingBox(self)

   def GetClearance(self, aItem=None):
        """
        GetClearance(ZONE_CONTAINER self, BOARD_CONNECTED_ITEM aItem=None) -> int
        GetClearance(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetClearance(BOARD_CONNECTED_ITEM *aItem=NULL) const

        Function GetClearance returns the clearance in 1/10000 inches.

        If aItem is not NULL then the returned clearance is the greater of
        this object's NETCLASS clearance and aItem's NETCLASS clearance. If
        aItem is NULL, then this objects clearance is returned.

        Parameters:
        -----------

        aItem:  is another BOARD_CONNECTED_ITEM or NULL

        int - the clearance in 1/10000 inches.
        """
        return _pcbnew.ZONE_CONTAINER_GetClearance(self, aItem)

   def TestForCopperIslandAndRemoveInsulatedIslands(self, *args):
        """
        TestForCopperIslandAndRemoveInsulatedIslands(ZONE_CONTAINER self, BOARD aPcb)

        void
        ZONE_CONTAINER::TestForCopperIslandAndRemoveInsulatedIslands(BOARD
        *aPcb)

        Function TestForCopperIslandAndRemoveInsulatedIslands Remove insulated
        copper islands found in m_FilledPolysList.

        Parameters:
        -----------

        aPcb:  = the board to analyze
        """
        return _pcbnew.ZONE_CONTAINER_TestForCopperIslandAndRemoveInsulatedIslands(self, *args)

   def CalculateSubAreaBoundaryBox(self, *args):
        """
        CalculateSubAreaBoundaryBox(ZONE_CONTAINER self, int aIndexStart, int aIndexEnd) -> EDA_RECT

        EDA_RECT ZONE_CONTAINER::CalculateSubAreaBoundaryBox(int aIndexStart,
        int aIndexEnd)

        Function CalculateSubAreaBoundaryBox Calculates the bounding box of a
        a filled area ( list of CPolyPt ) use m_FilledPolysList as list of
        CPolyPt (that are the corners of one or more polygons or filled areas
        )

        an EDA_RECT as bounding box

        Parameters:
        -----------

        aIndexStart:  = index of the first corner of a polygon (filled area)
        in m_FilledPolysList

        aIndexEnd:  = index of the last corner of a polygon in
        m_FilledPolysList
        """
        return _pcbnew.ZONE_CONTAINER_CalculateSubAreaBoundaryBox(self, *args)

   def IsOnCopperLayer(self):
        """
        IsOnCopperLayer(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::IsOnCopperLayer() const

        Function IsOnCopperLayer.

        true if this zone is on a copper layer, false if on a technical layer

        """
        return _pcbnew.ZONE_CONTAINER_IsOnCopperLayer(self)

   def SetFillMode(self, *args):
        """
        SetFillMode(ZONE_CONTAINER self, int aFillMode)

        void
        ZONE_CONTAINER::SetFillMode(int aFillMode)

        How to fill areas: 0 = use filled polygons, 1 => fill with segments.

        """
        return _pcbnew.ZONE_CONTAINER_SetFillMode(self, *args)

   def GetFillMode(self):
        """
        GetFillMode(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetFillMode() const
        """
        return _pcbnew.ZONE_CONTAINER_GetFillMode(self)

   def SetThermalReliefGap(self, *args):
        """
        SetThermalReliefGap(ZONE_CONTAINER self, int aThermalReliefGap)

        void
        ZONE_CONTAINER::SetThermalReliefGap(int aThermalReliefGap)
        """
        return _pcbnew.ZONE_CONTAINER_SetThermalReliefGap(self, *args)

   def GetThermalReliefGap(self, aPad=None):
        """
        GetThermalReliefGap(ZONE_CONTAINER self, D_PAD aPad=None) -> int
        GetThermalReliefGap(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetThermalReliefGap(D_PAD *aPad=NULL) const
        """
        return _pcbnew.ZONE_CONTAINER_GetThermalReliefGap(self, aPad)

   def SetThermalReliefCopperBridge(self, *args):
        """
        SetThermalReliefCopperBridge(ZONE_CONTAINER self, int aThermalReliefCopperBridge)

        void ZONE_CONTAINER::SetThermalReliefCopperBridge(int
        aThermalReliefCopperBridge)
        """
        return _pcbnew.ZONE_CONTAINER_SetThermalReliefCopperBridge(self, *args)

   def GetThermalReliefCopperBridge(self, aPad=None):
        """
        GetThermalReliefCopperBridge(ZONE_CONTAINER self, D_PAD aPad=None) -> int
        GetThermalReliefCopperBridge(ZONE_CONTAINER self) -> int

        int ZONE_CONTAINER::GetThermalReliefCopperBridge(D_PAD *aPad=NULL)
        const
        """
        return _pcbnew.ZONE_CONTAINER_GetThermalReliefCopperBridge(self, aPad)

   def SetArcSegmentCount(self, *args):
        """
        SetArcSegmentCount(ZONE_CONTAINER self, int aArcSegCount)

        void
        ZONE_CONTAINER::SetArcSegmentCount(int aArcSegCount)
        """
        return _pcbnew.ZONE_CONTAINER_SetArcSegmentCount(self, *args)

   def GetArcSegmentCount(self):
        """
        GetArcSegmentCount(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetArcSegmentCount() const
        """
        return _pcbnew.ZONE_CONTAINER_GetArcSegmentCount(self)

   def IsFilled(self):
        """
        IsFilled(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::IsFilled() const
        """
        return _pcbnew.ZONE_CONTAINER_IsFilled(self)

   def SetIsFilled(self, *args):
        """
        SetIsFilled(ZONE_CONTAINER self, bool isFilled)

        void
        ZONE_CONTAINER::SetIsFilled(bool isFilled)
        """
        return _pcbnew.ZONE_CONTAINER_SetIsFilled(self, *args)

   def GetZoneClearance(self):
        """
        GetZoneClearance(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetZoneClearance() const
        """
        return _pcbnew.ZONE_CONTAINER_GetZoneClearance(self)

   def SetZoneClearance(self, *args):
        """
        SetZoneClearance(ZONE_CONTAINER self, int aZoneClearance)

        void
        ZONE_CONTAINER::SetZoneClearance(int aZoneClearance)
        """
        return _pcbnew.ZONE_CONTAINER_SetZoneClearance(self, *args)

   def GetPadConnection(self, aPad=None):
        """
        GetPadConnection(ZONE_CONTAINER self, D_PAD aPad=None) -> ZoneConnection
        GetPadConnection(ZONE_CONTAINER self) -> ZoneConnection

        ZoneConnection ZONE_CONTAINER::GetPadConnection(D_PAD *aPad=NULL)
        const
        """
        return _pcbnew.ZONE_CONTAINER_GetPadConnection(self, aPad)

   def SetPadConnection(self, *args):
        """
        SetPadConnection(ZONE_CONTAINER self, ZoneConnection aPadConnection)

        void
        ZONE_CONTAINER::SetPadConnection(ZoneConnection aPadConnection)
        """
        return _pcbnew.ZONE_CONTAINER_SetPadConnection(self, *args)

   def GetMinThickness(self):
        """
        GetMinThickness(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetMinThickness() const
        """
        return _pcbnew.ZONE_CONTAINER_GetMinThickness(self)

   def SetMinThickness(self, *args):
        """
        SetMinThickness(ZONE_CONTAINER self, int aMinThickness)

        void
        ZONE_CONTAINER::SetMinThickness(int aMinThickness)
        """
        return _pcbnew.ZONE_CONTAINER_SetMinThickness(self, *args)

   def GetSelectedCorner(self):
        """
        GetSelectedCorner(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetSelectedCorner() const
        """
        return _pcbnew.ZONE_CONTAINER_GetSelectedCorner(self)

   def SetSelectedCorner(self, *args):
        """
        SetSelectedCorner(ZONE_CONTAINER self, int aCorner)
        SetSelectedCorner(ZONE_CONTAINER self, wxPoint aPosition)

        void
        ZONE_CONTAINER::SetSelectedCorner(const wxPoint &aPosition)
        """
        return _pcbnew.ZONE_CONTAINER_SetSelectedCorner(self, *args)

   def GetLocalFlags(self):
        """
        GetLocalFlags(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetLocalFlags() const
        """
        return _pcbnew.ZONE_CONTAINER_GetLocalFlags(self)

   def SetLocalFlags(self, *args):
        """
        SetLocalFlags(ZONE_CONTAINER self, int aFlags)

        void
        ZONE_CONTAINER::SetLocalFlags(int aFlags)
        """
        return _pcbnew.ZONE_CONTAINER_SetLocalFlags(self, *args)

   def FillSegments(self, *args):
        """
        FillSegments(ZONE_CONTAINER self) -> std::vector< SEGMENT,std::allocator< SEGMENT > >
        FillSegments(ZONE_CONTAINER self) -> std::vector< SEGMENT,std::allocator< SEGMENT > > const &

        const
        std::vector<SEGMENT>& ZONE_CONTAINER::FillSegments() const
        """
        return _pcbnew.ZONE_CONTAINER_FillSegments(self, *args)

   def Outline(self, *args):
        """
        Outline(ZONE_CONTAINER self) -> CPolyLine
        Outline(ZONE_CONTAINER self) -> CPolyLine

        const CPolyLine*
        ZONE_CONTAINER::Outline() const
        """
        return _pcbnew.ZONE_CONTAINER_Outline(self, *args)

   def SetOutline(self, *args):
        """
        SetOutline(ZONE_CONTAINER self, CPolyLine aOutline)

        void
        ZONE_CONTAINER::SetOutline(CPolyLine *aOutline)
        """
        return _pcbnew.ZONE_CONTAINER_SetOutline(self, *args)

   def HitTestInsideZone(self, *args):
        """
        HitTestInsideZone(ZONE_CONTAINER self, wxPoint aPosition) -> bool

        bool
        ZONE_CONTAINER::HitTestInsideZone(const wxPoint &aPosition) const

        Function HitTest tests if a point is inside the zone area, i.e.

        inside the main outline and outside holes.

        Parameters:
        -----------

        aPosition:  : the wxPoint to test

        bool - true if a hit, else false
        """
        return _pcbnew.ZONE_CONTAINER_HitTestInsideZone(self, *args)

   def HitTestFilledArea(self, *args):
        """
        HitTestFilledArea(ZONE_CONTAINER self, wxPoint aRefPos) -> bool

        bool
        ZONE_CONTAINER::HitTestFilledArea(const wxPoint &aRefPos) const

        Function HitTestFilledArea tests if the given wxPoint is within the
        bounds of a filled area of this zone.

        Parameters:
        -----------

        aRefPos:  A wxPoint to test

        bool - true if a hit, else false
        """
        return _pcbnew.ZONE_CONTAINER_HitTestFilledArea(self, *args)

   def TransformSolidAreasShapesToPolygonSet(self, *args):
        """
        TransformSolidAreasShapesToPolygonSet(ZONE_CONTAINER self, CPOLYGONS_LIST aCornerBuffer, int aCircleToSegmentsCount, double aCorrectionFactor)

        void
        ZONE_CONTAINER::TransformSolidAreasShapesToPolygonSet(CPOLYGONS_LIST
        &aCornerBuffer, int aCircleToSegmentsCount, double aCorrectionFactor)

        Function TransformSolidAreasShapesToPolygonSet Convert solid areas
        full shapes to polygon set (the full shape is the polygon area with a
        thick outline) Used in 3D view Arcs (ends of segments) are
        approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygons

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to arcs radius to
        roughly keep arc radius when approximated by segments
        """
        return _pcbnew.ZONE_CONTAINER_TransformSolidAreasShapesToPolygonSet(self, *args)

   def BuildFilledSolidAreasPolygons(self, *args):
        """
        BuildFilledSolidAreasPolygons(ZONE_CONTAINER self, BOARD aPcb, CPOLYGONS_LIST aOutlineBuffer=None) -> bool
        BuildFilledSolidAreasPolygons(ZONE_CONTAINER self, BOARD aPcb) -> bool

        bool ZONE_CONTAINER::BuildFilledSolidAreasPolygons(BOARD *aPcb,
        CPOLYGONS_LIST *aOutlineBuffer=NULL)

        Function BuildFilledSolidAreasPolygons Build the filled solid areas
        data from real outlines (stored in m_Poly) The solid areas can be more
        than one on copper layers, and do not have holes ( holes are linked by
        overlapping segments to the main outline) in order to have drawable
        (and plottable) filled polygons.

        true if OK, false if the solid polygons cannot be built

        Parameters:
        -----------

        aPcb:  the current board (can be NULL for non copper zones)

        aCornerBuffer:  A reference to a buffer to store polygon corners, or
        NULL if NULL (default: m_FilledPolysList is used to store solid areas
        polygons.

        on copper layers, tracks and other items shapes of other nets are
        removed from solid areas if not null: Only the zone outline (with
        holes, if any) is stored in aOutlineBuffer with holes linked.
        Therefore only one polygon is created

        When aOutlineBuffer is not null, his function calls
        AddClearanceAreasPolygonsToPolysList() to add holes for pads and
        tracks and other items not in net.
        """
        return _pcbnew.ZONE_CONTAINER_BuildFilledSolidAreasPolygons(self, *args)

   def CopyPolygonsFromKiPolygonListToFilledPolysList(self, *args):
        """
        CopyPolygonsFromKiPolygonListToFilledPolysList(ZONE_CONTAINER self, KI_POLYGON_SET & aKiPolyList)

        void
        ZONE_CONTAINER::CopyPolygonsFromKiPolygonListToFilledPolysList(KI_POLY
        GON_SET &aKiPolyList)

        Function CopyPolygonsFromKiPolygonListToFilledPolysList Copy polygons
        stored in aKiPolyList to m_FilledPolysList The previous
        m_FilledPolysList contents is replaced.

        Parameters:
        -----------

        aKiPolyList:  = a KI_POLYGON_SET containing polygons.
        """
        return _pcbnew.ZONE_CONTAINER_CopyPolygonsFromKiPolygonListToFilledPolysList(self, *args)

   def CopyPolygonsFromClipperPathsToFilledPolysList(self, *args):
        """
        CopyPolygonsFromClipperPathsToFilledPolysList(ZONE_CONTAINER self, ClipperLib::Paths & aClipperPolyList)

        void Z
        ONE_CONTAINER::CopyPolygonsFromClipperPathsToFilledPolysList(ClipperLi
        b::Paths &aClipperPolyList)

        Function CopyPolygonsFromClipperPathsToFilledPolysList Copy polygons
        stored in aKiPolyList to m_FilledPolysList The previous
        m_FilledPolysList contents is replaced.

        Parameters:
        -----------

        aClipperPolyList:  = a ClipperLib::Paths containing polygons.
        """
        return _pcbnew.ZONE_CONTAINER_CopyPolygonsFromClipperPathsToFilledPolysList(self, *args)

   def CopyPolygonsFromFilledPolysListToKiPolygonList(self, *args):
        """
        CopyPolygonsFromFilledPolysListToKiPolygonList(ZONE_CONTAINER self, KI_POLYGON_SET & aKiPolyList)

        void
        ZONE_CONTAINER::CopyPolygonsFromFilledPolysListToKiPolygonList(KI_POLY
        GON_SET &aKiPolyList)

        Function CopyPolygonsFromFilledPolysListToKiPolygonList Copy polygons
        from m_FilledPolysList to aKiPolyList.

        Parameters:
        -----------

        aKiPolyList:  = a KI_POLYGON_SET to fill by polygons.
        """
        return _pcbnew.ZONE_CONTAINER_CopyPolygonsFromFilledPolysListToKiPolygonList(self, *args)

   def AddClearanceAreasPolygonsToPolysList(self, *args):
        """
        AddClearanceAreasPolygonsToPolysList(ZONE_CONTAINER self, BOARD aPcb)

        void
        ZONE_CONTAINER::AddClearanceAreasPolygonsToPolysList(BOARD *aPcb)

        Function AddClearanceAreasPolygonsToPolysList Add non copper areas
        polygons (pads and tracks with clearance) to a filled copper area used
        in BuildFilledSolidAreasPolygons when calculating filled areas in a
        zone Non copper areas are pads and track and their clearance area The
        filled copper area must be computed before
        BuildFilledSolidAreasPolygons() call this function just after creating
        the filled copper area polygon (without clearance areas.

        Function AddClearanceAreasPolygonsToPolysList Supports a min thickness
        area constraint.

        Parameters:
        -----------

        aPcb:  the current board

        Add non copper areas polygons (pads and tracks with clearance) to the
        filled copper area found in BuildFilledPolysListData after calculating
        filled areas in a zone Non filled copper areas are pads and track and
        their clearance areas The filled copper area must be computed just
        before. BuildFilledPolysListData() call this function just after
        creating the filled copper area polygon (without clearance areas) to
        do that this function: 1 - Creates the main outline (zone outline)
        using a correction to shrink the resulting area with
        m_ZoneMinThickness/2 value. The result is areas with a margin of
        m_ZoneMinThickness/2 When drawing outline with segments having a
        thickness of m_ZoneMinThickness, the outlines will match exactly the
        initial outlines 3 - Add all non filled areas (pads, tracks) in group
        B with a clearance of m_Clearance + m_ZoneMinThickness/2 in a buffer
        If Thermal shapes are wanted, add non filled area, in order to create
        these thermal shapes 4 - calculates the polygon A - B 5 - put
        resulting list of polygons (filled areas) in m_FilledPolysList This
        zone contains pads with the same net. 6 - Remove insulated copper
        islands 7 - If Thermal shapes are wanted, remove unconnected stubs in
        thermal shapes: creates a buffer of polygons corresponding to stubs to
        remove sub them to the filled areas. Remove new insulated copper
        islands
        """
        return _pcbnew.ZONE_CONTAINER_AddClearanceAreasPolygonsToPolysList(self, *args)

   def TransformOutlinesShapeWithClearanceToPolygon(self, *args):
        """
        TransformOutlinesShapeWithClearanceToPolygon(ZONE_CONTAINER self, CPOLYGONS_LIST aCornerBuffer, int aMinClearanceValue, bool aUseNetClearance)

        void ZO
        NE_CONTAINER::TransformOutlinesShapeWithClearanceToPolygon(CPOLYGONS_L
        IST &aCornerBuffer, int aMinClearanceValue, bool aUseNetClearance)

        Function TransformOutlinesShapeWithClearanceToPolygon Convert the
        outlines shape to a polygon with no holes inflated (optional) by max(
        aClearanceValue, the zone clearance) (holes are linked to external
        outline by overlapping segments) Used in filling zones calculations
        Circles (vias) and arcs (ends of tracks) are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aMinClearanceValue:  = the min clearance around outlines

        aUseNetClearance:  = true to use a clearance which is the max value
        between aMinClearanceValue and the net clearance false to use
        aMinClearanceValue only if both aMinClearanceValue = 0 and
        aUseNetClearance = false: create the zone outline polygon.
        """
        return _pcbnew.ZONE_CONTAINER_TransformOutlinesShapeWithClearanceToPolygon(self, *args)

   def HitTestForCorner(self, *args):
        """
        HitTestForCorner(ZONE_CONTAINER self, wxPoint refPos) -> int

        int
        ZONE_CONTAINER::HitTestForCorner(const wxPoint &refPos) const

        Function HitTestForCorner tests if the given wxPoint near a corner Set
        m_CornerSelection to -1 if nothing found, or index of corner.

        true if found

        Parameters:
        -----------

        refPos:  : A wxPoint to test
        """
        return _pcbnew.ZONE_CONTAINER_HitTestForCorner(self, *args)

   def HitTestForEdge(self, *args):
        """
        HitTestForEdge(ZONE_CONTAINER self, wxPoint refPos) -> int

        int
        ZONE_CONTAINER::HitTestForEdge(const wxPoint &refPos) const

        Function HitTestForEdge tests if the given wxPoint is near a segment
       defined by 2 corners.

        Set m_CornerSelection to -1 if nothing found, or index of the starting
        corner of vertice true if found

        Parameters:
        -----------

        refPos:  : A wxPoint to test
        """
        return _pcbnew.ZONE_CONTAINER_HitTestForEdge(self, *args)

   def HitTest(self, *args):
        """
        HitTest(ZONE_CONTAINER self, wxPoint aPosition) -> bool
        HitTest(ZONE_CONTAINER self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(ZONE_CONTAINER self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(ZONE_CONTAINER self, EDA_RECT aRect) -> bool

        bool
        ZONE_CONTAINER::HitTest(const EDA_RECT &aRect, bool aContained=true,
        int aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.ZONE_CONTAINER_HitTest(self, *args)

   def FillZoneAreasWithSegments(self):
        """
        FillZoneAreasWithSegments(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::FillZoneAreasWithSegments()

        Function FillZoneAreasWithSegments Fill sub areas in a zone with
        segments with m_ZoneMinThickness width A scan is made line per line,
        on the whole filled areas, with a step of m_ZoneMinThickness.

        all intersecting points with the horizontal infinite line and polygons
        to fill are calculated a list of SEGZONE items is built, line per line
        number of segments created
        """
        return _pcbnew.ZONE_CONTAINER_FillZoneAreasWithSegments(self)

   def UnFill(self):
        """
        UnFill(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::UnFill()

        Function UnFill Removes the zone filling.

        true if a previous filling is removed, false if no change (when no
        filling found)
        """
        return _pcbnew.ZONE_CONTAINER_UnFill(self)

   def Move(self, *args):
        """
        Move(ZONE_CONTAINER self, wxPoint offset)

        void
        ZONE_CONTAINER::Move(const wxPoint &offset)

        Function Move Move the outlines.

        Parameters:
        -----------

        offset:  = moving vector
        """
        return _pcbnew.ZONE_CONTAINER_Move(self, *args)

   def MoveEdge(self, *args):
        """
        MoveEdge(ZONE_CONTAINER self, wxPoint offset, int aEdge)

        void
        ZONE_CONTAINER::MoveEdge(const wxPoint &offset, int aEdge)

        Function MoveEdge Move the outline Edge.

        Parameters:
        -----------

        offset:  = moving vector

        aEdge:  = start point of the outline edge
        """
        return _pcbnew.ZONE_CONTAINER_MoveEdge(self, *args)

   def Rotate(self, *args):
        """
        Rotate(ZONE_CONTAINER self, wxPoint centre, double angle)

        void
        ZONE_CONTAINER::Rotate(const wxPoint &centre, double angle)

        Function Rotate Move the outlines.

        Parameters:
        -----------

        centre:  = rot centre

        angle:  = in 0.1 degree
        """
        return _pcbnew.ZONE_CONTAINER_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(ZONE_CONTAINER self, wxPoint aCentre)

        void
        ZONE_CONTAINER::Flip(const wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object (like Mirror() but changes
        layer)

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.ZONE_CONTAINER_Flip(self, *args)

   def Mirror(self, *args):
        """
        Mirror(ZONE_CONTAINER self, wxPoint mirror_ref)

        void
        ZONE_CONTAINER::Mirror(const wxPoint &mirror_ref)

        Function Mirror Mirror the outlines , relative to a given horizontal
        axis the layer is not changed.

        Parameters:
        -----------

        mirror_ref:  = vertical axis position
        """
        return _pcbnew.ZONE_CONTAINER_Mirror(self, *args)

   def GetClass(self):
        """
        GetClass(ZONE_CONTAINER self) -> wxString

        wxString
        ZONE_CONTAINER::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.ZONE_CONTAINER_GetClass(self)

   def GetNumCorners(self):
        """
        GetNumCorners(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetNumCorners(void) const

        Access to m_Poly parameters.
        """
        return _pcbnew.ZONE_CONTAINER_GetNumCorners(self)

   def RemoveAllContours(self):
        """
        RemoveAllContours(ZONE_CONTAINER self)

        void
        ZONE_CONTAINER::RemoveAllContours(void)
        """
        return _pcbnew.ZONE_CONTAINER_RemoveAllContours(self)

   def GetCornerPosition(self, *args):
        """
        GetCornerPosition(ZONE_CONTAINER self, int aCornerIndex) -> wxPoint

        const
        wxPoint& ZONE_CONTAINER::GetCornerPosition(int aCornerIndex) const
        """
        return _pcbnew.ZONE_CONTAINER_GetCornerPosition(self, *args)

   def SetCornerPosition(self, *args):
        """
        SetCornerPosition(ZONE_CONTAINER self, int aCornerIndex, wxPoint new_pos)

        void
        ZONE_CONTAINER::SetCornerPosition(int aCornerIndex, wxPoint new_pos)

        """
        return _pcbnew.ZONE_CONTAINER_SetCornerPosition(self, *args)

   def AppendCorner(self, *args):
        """
        AppendCorner(ZONE_CONTAINER self, wxPoint position)

        void
        ZONE_CONTAINER::AppendCorner(wxPoint position)
        """
        return _pcbnew.ZONE_CONTAINER_AppendCorner(self, *args)

   def GetHatchStyle(self):
        """
        GetHatchStyle(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetHatchStyle() const
        """
        return _pcbnew.ZONE_CONTAINER_GetHatchStyle(self)

   def SetHatchStyle(self, *args):
        """
        SetHatchStyle(ZONE_CONTAINER self, CPolyLine::HATCH_STYLE aStyle)

        void
        ZONE_CONTAINER::SetHatchStyle(CPolyLine::HATCH_STYLE aStyle)
        """
        return _pcbnew.ZONE_CONTAINER_SetHatchStyle(self, *args)

   def IsSame(self, *args):
        """
        IsSame(ZONE_CONTAINER self, ZONE_CONTAINER aZoneToCompare) -> bool

        bool
        ZONE_CONTAINER::IsSame(const ZONE_CONTAINER &aZoneToCompare)

        Function IsSame tests if 2 zones are equivalent: 2 zones are
        equivalent if they have same parameters and same outlines info,
        filling is not taken into account.

        Function IsSame test is 2 zones are equivalent: 2 zones are equivalent
        if they have same parameters and same outlines info relative to
        filling is not take in account.

        Parameters:
        -----------

        aZoneToCompare:  = zone to compare with "this"
        """
        return _pcbnew.ZONE_CONTAINER_IsSame(self, *args)

   def ClearFilledPolysList(self):
        """
        ClearFilledPolysList(ZONE_CONTAINER self)

        void
        ZONE_CONTAINER::ClearFilledPolysList()

        Function ClearFilledPolysList clears the list of filled polygons.
        """
        return _pcbnew.ZONE_CONTAINER_ClearFilledPolysList(self)

   def GetFilledPolysList(self):
        """
        GetFilledPolysList(ZONE_CONTAINER self) -> CPOLYGONS_LIST

        const
        CPOLYGONS_LIST& ZONE_CONTAINER::GetFilledPolysList() const

        Function GetFilledPolysList returns a reference to the list of filled
        polygons.

        Reference to the list of filled polygons.
        """
        return _pcbnew.ZONE_CONTAINER_GetFilledPolysList(self)

   def AddFilledPolysList(self, *args):
        """
        AddFilledPolysList(ZONE_CONTAINER self, CPOLYGONS_LIST aPolysList)

        void
        ZONE_CONTAINER::AddFilledPolysList(CPOLYGONS_LIST &aPolysList)

        Function AddFilledPolysList sets the list of filled polygons.
        """
        return _pcbnew.ZONE_CONTAINER_AddFilledPolysList(self, *args)

   def GetSmoothedPoly(self):
        """
        GetSmoothedPoly(ZONE_CONTAINER self) -> CPolyLine

        CPolyLine*
        ZONE_CONTAINER::GetSmoothedPoly() const

        Function GetSmoothedPoly returns a pointer to the corner-smoothed
        version of m_Poly if it exists, otherwise it returns m_Poly.

        CPolyLine* - pointer to the polygon.
        """
        return _pcbnew.ZONE_CONTAINER_GetSmoothedPoly(self)

   def SetCornerSmoothingType(self, *args):
        """
        SetCornerSmoothingType(ZONE_CONTAINER self, int aType)

        void
        ZONE_CONTAINER::SetCornerSmoothingType(int aType)
        """
        return _pcbnew.ZONE_CONTAINER_SetCornerSmoothingType(self, *args)

   def GetCornerSmoothingType(self):
        """
        GetCornerSmoothingType(ZONE_CONTAINER self) -> int

        int
        ZONE_CONTAINER::GetCornerSmoothingType() const
        """
        return _pcbnew.ZONE_CONTAINER_GetCornerSmoothingType(self)

   def SetCornerRadius(self, *args):
        """
        SetCornerRadius(ZONE_CONTAINER self, unsigned int aRadius)

        void
        ZONE_CONTAINER::SetCornerRadius(unsigned int aRadius)
        """
        return _pcbnew.ZONE_CONTAINER_SetCornerRadius(self, *args)

   def GetCornerRadius(self):
        """
        GetCornerRadius(ZONE_CONTAINER self) -> unsigned int

        unsigned int
        ZONE_CONTAINER::GetCornerRadius() const
        """
        return _pcbnew.ZONE_CONTAINER_GetCornerRadius(self)

   def AddPolygon(self, *args):
        """
        AddPolygon(ZONE_CONTAINER self, std::vector< wxPoint,std::allocator< wxPoint > > & aPolygon)

        void
        ZONE_CONTAINER::AddPolygon(std::vector< wxPoint > &aPolygon)
        """
        return _pcbnew.ZONE_CONTAINER_AddPolygon(self, *args)

   def AddFilledPolygon(self, *args):
        """
        AddFilledPolygon(ZONE_CONTAINER self, CPOLYGONS_LIST aPolygon)

        void
        ZONE_CONTAINER::AddFilledPolygon(CPOLYGONS_LIST &aPolygon)
        """
        return _pcbnew.ZONE_CONTAINER_AddFilledPolygon(self, *args)

   def AddFillSegments(self, *args):
        """
        AddFillSegments(ZONE_CONTAINER self, std::vector< SEGMENT,std::allocator< SEGMENT > > & aSegments)

        void
        ZONE_CONTAINER::AddFillSegments(std::vector< SEGMENT > &aSegments)
        """
        return _pcbnew.ZONE_CONTAINER_AddFillSegments(self, *args)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(ZONE_CONTAINER self) -> wxString

        wxString
        ZONE_CONTAINER::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.ZONE_CONTAINER_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(ZONE_CONTAINER self) -> BITMAP_DEF

        virtual
        BITMAP_DEF ZONE_CONTAINER::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.ZONE_CONTAINER_GetMenuImage(self)

   def Clone(self):
        """
        Clone(ZONE_CONTAINER self) -> EDA_ITEM

        EDA_ITEM *
        ZONE_CONTAINER::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.ZONE_CONTAINER_Clone(self)

   def GetIsKeepout(self):
        """
        GetIsKeepout(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::GetIsKeepout() const

        Accessors to parameters used in Keepout zones:
        """
        return _pcbnew.ZONE_CONTAINER_GetIsKeepout(self)

   def GetDoNotAllowCopperPour(self):
        """
        GetDoNotAllowCopperPour(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::GetDoNotAllowCopperPour() const
        """
        return _pcbnew.ZONE_CONTAINER_GetDoNotAllowCopperPour(self)

   def GetDoNotAllowVias(self):
        """
        GetDoNotAllowVias(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::GetDoNotAllowVias() const
        """
        return _pcbnew.ZONE_CONTAINER_GetDoNotAllowVias(self)

   def GetDoNotAllowTracks(self):
        """
        GetDoNotAllowTracks(ZONE_CONTAINER self) -> bool

        bool
        ZONE_CONTAINER::GetDoNotAllowTracks() const
        """
        return _pcbnew.ZONE_CONTAINER_GetDoNotAllowTracks(self)

   def SetIsKeepout(self, *args):
        """
        SetIsKeepout(ZONE_CONTAINER self, bool aEnable)

        void
        ZONE_CONTAINER::SetIsKeepout(bool aEnable)
        """
        return _pcbnew.ZONE_CONTAINER_SetIsKeepout(self, *args)

   def SetDoNotAllowCopperPour(self, *args):
        """
        SetDoNotAllowCopperPour(ZONE_CONTAINER self, bool aEnable)

        void
        ZONE_CONTAINER::SetDoNotAllowCopperPour(bool aEnable)
        """
        return _pcbnew.ZONE_CONTAINER_SetDoNotAllowCopperPour(self, *args)

   def SetDoNotAllowVias(self, *args):
        """
        SetDoNotAllowVias(ZONE_CONTAINER self, bool aEnable)

        void
        ZONE_CONTAINER::SetDoNotAllowVias(bool aEnable)
        """
        return _pcbnew.ZONE_CONTAINER_SetDoNotAllowVias(self, *args)

   def SetDoNotAllowTracks(self, *args):
        """
        SetDoNotAllowTracks(ZONE_CONTAINER self, bool aEnable)

        void
        ZONE_CONTAINER::SetDoNotAllowTracks(bool aEnable)
        """
        return _pcbnew.ZONE_CONTAINER_SetDoNotAllowTracks(self, *args)

ZONE_CONTAINER_swigregister = _pcbnew.ZONE_CONTAINER_swigregister
ZONE_CONTAINER_swigregister(ZONE_CONTAINER)

F_Cu = _pcbnew.F_Cu
In1_Cu = _pcbnew.In1_Cu
In2_Cu = _pcbnew.In2_Cu
In3_Cu = _pcbnew.In3_Cu
In4_Cu = _pcbnew.In4_Cu
In5_Cu = _pcbnew.In5_Cu
In6_Cu = _pcbnew.In6_Cu
In7_Cu = _pcbnew.In7_Cu
In8_Cu = _pcbnew.In8_Cu
In9_Cu = _pcbnew.In9_Cu
In10_Cu = _pcbnew.In10_Cu
In11_Cu = _pcbnew.In11_Cu
In12_Cu = _pcbnew.In12_Cu
In13_Cu = _pcbnew.In13_Cu
In14_Cu = _pcbnew.In14_Cu
In15_Cu = _pcbnew.In15_Cu
In16_Cu = _pcbnew.In16_Cu
In17_Cu = _pcbnew.In17_Cu
In18_Cu = _pcbnew.In18_Cu
In19_Cu = _pcbnew.In19_Cu
In20_Cu = _pcbnew.In20_Cu
In21_Cu = _pcbnew.In21_Cu
In22_Cu = _pcbnew.In22_Cu
In23_Cu = _pcbnew.In23_Cu
In24_Cu = _pcbnew.In24_Cu
In25_Cu = _pcbnew.In25_Cu
In26_Cu = _pcbnew.In26_Cu
In27_Cu = _pcbnew.In27_Cu
In28_Cu = _pcbnew.In28_Cu
In29_Cu = _pcbnew.In29_Cu
In30_Cu = _pcbnew.In30_Cu
B_Cu = _pcbnew.B_Cu
B_Adhes = _pcbnew.B_Adhes
F_Adhes = _pcbnew.F_Adhes
B_Paste = _pcbnew.B_Paste
F_Paste = _pcbnew.F_Paste
B_SilkS = _pcbnew.B_SilkS
F_SilkS = _pcbnew.F_SilkS
B_Mask = _pcbnew.B_Mask
F_Mask = _pcbnew.F_Mask
Dwgs_User = _pcbnew.Dwgs_User
Cmts_User = _pcbnew.Cmts_User
Eco1_User = _pcbnew.Eco1_User
Eco2_User = _pcbnew.Eco2_User
Edge_Cuts = _pcbnew.Edge_Cuts
Margin = _pcbnew.Margin
B_CrtYd = _pcbnew.B_CrtYd
F_CrtYd = _pcbnew.F_CrtYd
B_Fab = _pcbnew.B_Fab
F_Fab = _pcbnew.F_Fab
LAYER_ID_COUNT = _pcbnew.LAYER_ID_COUNT
class LSEQ(_object):
    """
    Class LSEQ is a sequence (and therefore also a set) of LAYER_IDs.

    A sequence provides a certain order.

    It can also be used as an iterator:  for( LSEQ cu_stack =
    aSet.CuStack();  cu_stack;  ++cu_stack )  { layer_id = *cu_stack;
    :      things to do with layer_id;  }



    C++ includes: layers_id_colors_and_visibility.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LSEQ, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LSEQ, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(LSEQ self) -> LSEQ

        LSEQ::LSEQ(InputIterator start,
        InputIterator end)
        """
        this = _pcbnew.new_LSEQ()
        try: self.this.append(this)
        except: self.this = this
   def Rewind(self):
        """
        Rewind(LSEQ self)

        void LSEQ::Rewind()
        """
        return _pcbnew.LSEQ_Rewind(self)

   def __nonzero__(self):
        return _pcbnew.LSEQ___nonzero__(self)
    __bool__ = __nonzero__


   def __ref__(self):
        """__ref__(LSEQ self) -> LAYER_ID"""
        return _pcbnew.LSEQ___ref__(self)

    __swig_destroy__ = _pcbnew.delete_LSEQ
    __del__ = lambda self : None;
LSEQ_swigregister = _pcbnew.LSEQ_swigregister
LSEQ_swigregister(LSEQ)

class LSET(_object):
    """
    Class LSET is a set of LAYER_IDs.

    It can be converted to numerous purpose LSEQs using the various member
    functions, most of which are based on Seq(). The advantage of
    converting to LSEQ using purposeful code, is it removes any dependency
    on order/sequence inherent in this set.

    C++ includes: layers_id_colors_and_visibility.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LSET, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LSET, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(LSET self) -> LSET
        __init__(LSET self, BASE_SET const & aOther) -> LSET
        __init__(LSET self, LAYER_ID aLayer) -> LSET
        __init__(LSET self, LAYER_ID const * aArray, unsigned int aCount) -> LSET
        __init__(LSET self, unsigned int aIdCount, LAYER_ID aFirst) -> LSET

        LSET::LSET(unsigned aIdCount,
        LAYER_ID aFirst,...)

        Constructor LSET( unsigned, LAYER_ID, ...) takes one or more LAYER_IDs
        in the argument list to construct the set.

        Typically only used in static construction.

        Parameters:
        -----------

        aIdCount:  is the number of LAYER_IDs which follow.

        aFirst:  is the first included in aIdCount and must always be present,
        and can be followed by any number of additional LAYER_IDs so long as
        aIdCount accurately reflects the count.
        """
        this = _pcbnew.new_LSET(*args)
        try: self.this.append(this)
        except: self.this = this
   def Name(*args):
        """Name(LAYER_ID aLayerId) -> wxChar const *"""
        return _pcbnew.LSET_Name(*args)

    if _newclass:Name = staticmethod(Name)
    __swig_getmethods__["Name"] = lambda x: Name
   def InternalCuMask():
        """InternalCuMask() -> LSET"""
        return _pcbnew.LSET_InternalCuMask()

    if _newclass:InternalCuMask = staticmethod(InternalCuMask)
    __swig_getmethods__["InternalCuMask"] = lambda x: InternalCuMask
   def AllCuMask(*args):
        """
        AllCuMask(int aCuLayerCount=(B_Cu-F_Cu+1)) -> LSET
        AllCuMask() -> LSET
        """
        return _pcbnew.LSET_AllCuMask(*args)

    if _newclass:AllCuMask = staticmethod(AllCuMask)
    __swig_getmethods__["AllCuMask"] = lambda x: AllCuMask
   def AllNonCuMask():
        """AllNonCuMask() -> LSET"""
        return _pcbnew.LSET_AllNonCuMask()

    if _newclass:AllNonCuMask = staticmethod(AllNonCuMask)
    __swig_getmethods__["AllNonCuMask"] = lambda x: AllNonCuMask
   def AllLayersMask():
        """AllLayersMask() -> LSET"""
        return _pcbnew.LSET_AllLayersMask()

    if _newclass:AllLayersMask = staticmethod(AllLayersMask)
    __swig_getmethods__["AllLayersMask"] = lambda x: AllLayersMask
   def FrontTechMask():
        """FrontTechMask() -> LSET"""
        return _pcbnew.LSET_FrontTechMask()

    if _newclass:FrontTechMask = staticmethod(FrontTechMask)
    __swig_getmethods__["FrontTechMask"] = lambda x: FrontTechMask
   def BackTechMask():
        """BackTechMask() -> LSET"""
        return _pcbnew.LSET_BackTechMask()

    if _newclass:BackTechMask = staticmethod(BackTechMask)
    __swig_getmethods__["BackTechMask"] = lambda x: BackTechMask
   def AllTechMask():
        """AllTechMask() -> LSET"""
        return _pcbnew.LSET_AllTechMask()

    if _newclass:AllTechMask = staticmethod(AllTechMask)
    __swig_getmethods__["AllTechMask"] = lambda x: AllTechMask
   def FrontMask():
        """FrontMask() -> LSET"""
        return _pcbnew.LSET_FrontMask()

    if _newclass:FrontMask = staticmethod(FrontMask)
    __swig_getmethods__["FrontMask"] = lambda x: FrontMask
   def BackMask():
        """BackMask() -> LSET"""
        return _pcbnew.LSET_BackMask()

    if _newclass:BackMask = staticmethod(BackMask)
    __swig_getmethods__["BackMask"] = lambda x: BackMask
   def UserMask():
        """UserMask() -> LSET"""
        return _pcbnew.LSET_UserMask()

    if _newclass:UserMask = staticmethod(UserMask)
    __swig_getmethods__["UserMask"] = lambda x: UserMask
   def CuStack(self):
        """
        CuStack(LSET self) -> LSEQ

        LSEQ LSET::CuStack() const

        Function CuStack returns a sequence of copper layers in starting from
        the front/top and extending to the back/bottom.

        This specific sequence is depended upon in numerous places.
        """
        return _pcbnew.LSET_CuStack(self)

   def Technicals(self, *args):
        """
        Technicals(LSET self, LSET aSubToOmit=LSET()) -> LSEQ
        Technicals(LSET self) -> LSEQ

        LSEQ LSET::Technicals(LSET
        aSubToOmit=LSET()) const

        Function Technicals returns a sequence of technical layers.

        A sequence provides a certain order.

        Parameters:
        -----------

       aSubToOmit:  is the subset of the techical layers to omit, defaults to
        none.
        """
        return _pcbnew.LSET_Technicals(self, *args)

   def Users(self):
        """
        Users(LSET self) -> LSEQ

        LSEQ LSET::Users() const

        *_User layers.
        """
        return _pcbnew.LSET_Users(self)

   def UIOrder(self):
        """
        UIOrder(LSET self) -> LSEQ

        LSEQ LSET::UIOrder() const
        """
        return _pcbnew.LSET_UIOrder(self)

   def Seq(self, *args):
        """
        Seq(LSET self, LAYER_ID const * aWishListSequence, unsigned int aCount) -> LSEQ
        Seq(LSET self) -> LSEQ

        LSEQ LSET::Seq() const

        Function Seq returns a LSEQ from this LSET in ascending LAYER_ID
        order.

        Each LSEQ element will be in the same sequence as in LAYER_ID and only
        present in the resultant LSEQ if present in this set. Therefore the
        sequence is subject to change, use it only when enumeration and not
        order is important.
        """
        return _pcbnew.LSET_Seq(self, *args)

   def SeqStackupBottom2Top(self):
        """
        SeqStackupBottom2Top(LSET self) -> LSEQ

        LSEQ
        LSET::SeqStackupBottom2Top() const

        Function SeqStackBottom2Top returns the sequence that is typical for a
        bottom-to-top stack-up.

        For instance, to plot multiple layers in a single image, the top
        layers output last.
        """
        return _pcbnew.LSET_SeqStackupBottom2Top(self)

   def FmtHex(self):
        """
        FmtHex(LSET self) -> std::string

        std::string LSET::FmtHex() const

        Function FmtHex returns a hex string showing contents of this LSEQ.
        """
        return _pcbnew.LSET_FmtHex(self)

   def ParseHex(self, *args):
        """
        ParseHex(LSET self, char const * aStart, int aCount) -> int

        int LSET::ParseHex(const char
        *aStart, int aCount)

        Function ParseHex understands the output of FmtHex() and replaces this
        set's values with those given in the input string.

        Parsing stops at the first non hex ASCII byte, except that marker
        bytes output from FmtHex are not terminators. int - number of bytes
        consumed
        """
        return _pcbnew.LSET_ParseHex(self, *args)

   def FmtBin(self):
        """
        FmtBin(LSET self) -> std::string

        std::string LSET::FmtBin() const

        Function FmtBin returns a binary string showing contents of this LSEQ.

        """
        return _pcbnew.LSET_FmtBin(self)

   def ExtractLayer(self):
        """
        ExtractLayer(LSET self) -> LAYER_ID

        LAYER_ID
        LSET::ExtractLayer() const

        Find the first set LAYER_ID.

        Returns UNDEFINED_LAYER if more than one is set or UNSELECTED_LAYER if
        none is set.
        """
        return _pcbnew.LSET_ExtractLayer(self)

    __swig_destroy__ = _pcbnew.delete_LSET
    __del__ = lambda self : None;
LSET_swigregister = _pcbnew.LSET_swigregister
LSET_swigregister(LSET)

def LSET_Name(*args):
  """LSET_Name(LAYER_ID aLayerId) -> wxChar const *"""
  return _pcbnew.LSET_Name(*args)

def LSET_InternalCuMask():
  """LSET_InternalCuMask() -> LSET"""
  return _pcbnew.LSET_InternalCuMask()

def LSET_AllCuMask(*args):
  """
    AllCuMask(int aCuLayerCount=(B_Cu-F_Cu+1)) -> LSET
    LSET_AllCuMask() -> LSET
    """
  return _pcbnew.LSET_AllCuMask(*args)

def LSET_AllNonCuMask():
  """LSET_AllNonCuMask() -> LSET"""
  return _pcbnew.LSET_AllNonCuMask()

def LSET_AllLayersMask():
  """LSET_AllLayersMask() -> LSET"""
  return _pcbnew.LSET_AllLayersMask()

def LSET_FrontTechMask():
  """LSET_FrontTechMask() -> LSET"""
  return _pcbnew.LSET_FrontTechMask()

def LSET_BackTechMask():
  """LSET_BackTechMask() -> LSET"""
  return _pcbnew.LSET_BackTechMask()

def LSET_AllTechMask():
  """LSET_AllTechMask() -> LSET"""
  return _pcbnew.LSET_AllTechMask()

def LSET_FrontMask():
  """LSET_FrontMask() -> LSET"""
  return _pcbnew.LSET_FrontMask()

def LSET_BackMask():
  """LSET_BackMask() -> LSET"""
  return _pcbnew.LSET_BackMask()

def LSET_UserMask():
  """LSET_UserMask() -> LSET"""
  return _pcbnew.LSET_UserMask()

VIAS_VISIBLE = _pcbnew.VIAS_VISIBLE
VIA_MICROVIA_VISIBLE = _pcbnew.VIA_MICROVIA_VISIBLE
VIA_BBLIND_VISIBLE = _pcbnew.VIA_BBLIND_VISIBLE
VIA_THROUGH_VISIBLE = _pcbnew.VIA_THROUGH_VISIBLE
NON_PLATED_VISIBLE = _pcbnew.NON_PLATED_VISIBLE
MOD_TEXT_FR_VISIBLE = _pcbnew.MOD_TEXT_FR_VISIBLE
MOD_TEXT_BK_VISIBLE = _pcbnew.MOD_TEXT_BK_VISIBLE
MOD_TEXT_INVISIBLE = _pcbnew.MOD_TEXT_INVISIBLE
ANCHOR_VISIBLE = _pcbnew.ANCHOR_VISIBLE
PAD_FR_VISIBLE = _pcbnew.PAD_FR_VISIBLE
PAD_BK_VISIBLE = _pcbnew.PAD_BK_VISIBLE
RATSNEST_VISIBLE = _pcbnew.RATSNEST_VISIBLE
GRID_VISIBLE = _pcbnew.GRID_VISIBLE
NO_CONNECTS_VISIBLE = _pcbnew.NO_CONNECTS_VISIBLE
MOD_FR_VISIBLE = _pcbnew.MOD_FR_VISIBLE
MOD_BK_VISIBLE = _pcbnew.MOD_BK_VISIBLE
MOD_VALUES_VISIBLE = _pcbnew.MOD_VALUES_VISIBLE
MOD_REFERENCES_VISIBLE = _pcbnew.MOD_REFERENCES_VISIBLE
TRACKS_VISIBLE = _pcbnew.TRACKS_VISIBLE
PADS_VISIBLE = _pcbnew.PADS_VISIBLE
PADS_HOLES_VISIBLE = _pcbnew.PADS_HOLES_VISIBLE
VIAS_HOLES_VISIBLE = _pcbnew.VIAS_HOLES_VISIBLE
DRC_VISIBLE = _pcbnew.DRC_VISIBLE
WORKSHEET = _pcbnew.WORKSHEET
GP_OVERLAY = _pcbnew.GP_OVERLAY
END_PCB_VISIBLE_LIST = _pcbnew.END_PCB_VISIBLE_LIST
PAD_FR_NETNAMES_VISIBLE = _pcbnew.PAD_FR_NETNAMES_VISIBLE
PAD_BK_NETNAMES_VISIBLE = _pcbnew.PAD_BK_NETNAMES_VISIBLE
PADS_NETNAMES_VISIBLE = _pcbnew.PADS_NETNAMES_VISIBLE
END_NETNAMES_VISIBLE_LIST = _pcbnew.END_NETNAMES_VISIBLE_LIST

def IsValidLayer(*args):
  """IsValidLayer(LAYER_NUM aLayerId) -> bool"""
  return _pcbnew.IsValidLayer(*args)

def IsPcbLayer(*args):
  """IsPcbLayer(LAYER_NUM aLayer) -> bool"""
  return _pcbnew.IsPcbLayer(*args)

def IsCopperLayer(*args):
  """IsCopperLayer(LAYER_NUM aLayerId) -> bool"""
  return _pcbnew.IsCopperLayer(*args)

def IsNonCopperLayer(*args):
  """IsNonCopperLayer(LAYER_NUM aLayerId) -> bool"""
  return _pcbnew.IsNonCopperLayer(*args)

def IsUserLayer(*args):
  """IsUserLayer(LAYER_ID aLayerId) -> bool"""
  return _pcbnew.IsUserLayer(*args)

def IsFrontLayer(*args):
  """IsFrontLayer(LAYER_ID aLayerId) -> bool"""
  return _pcbnew.IsFrontLayer(*args)

def IsBackLayer(*args):
  """IsBackLayer(LAYER_ID aLayerId) -> bool"""
  return _pcbnew.IsBackLayer(*args)

def FlipLayer(*args):
  """FlipLayer(LAYER_ID oldlayer) -> LAYER_ID"""
  return _pcbnew.FlipLayer(*args)

def FlipLayerMask(*args):
  """FlipLayerMask(LSET aMask) -> LSET"""
  return _pcbnew.FlipLayerMask(*args)

def LayerMaskDescribe(*args):
  """LayerMaskDescribe(BOARD aBoard, LSET aMask) -> wxString"""
  return _pcbnew.LayerMaskDescribe(*args)

def GetNetnameLayer(*args):
  """GetNetnameLayer(int aLayer) -> int"""
  return _pcbnew.GetNetnameLayer(*args)

def IsNetnameLayer(*args):
  """IsNetnameLayer(LAYER_NUM aLayer) -> bool"""
  return _pcbnew.IsNetnameLayer(*args)

def ToLAYER_ID(*args):
  """ToLAYER_ID(int aLayer) -> LAYER_ID"""
  return _pcbnew.ToLAYER_ID(*args)
class PAD_DRAWINFO(_object):
    """C++ includes: class_pad.h """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PAD_DRAWINFO, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PAD_DRAWINFO, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_DrawPanel"] = _pcbnew.PAD_DRAWINFO_m_DrawPanel_set
    __swig_getmethods__["m_DrawPanel"] = _pcbnew.PAD_DRAWINFO_m_DrawPanel_get
    if _newclass:m_DrawPanel = _swig_property(_pcbnew.PAD_DRAWINFO_m_DrawPanel_get, _pcbnew.PAD_DRAWINFO_m_DrawPanel_set)
    __swig_setmethods__["m_DrawMode"] = _pcbnew.PAD_DRAWINFO_m_DrawMode_set
    __swig_getmethods__["m_DrawMode"] = _pcbnew.PAD_DRAWINFO_m_DrawMode_get
    if _newclass:m_DrawMode = _swig_property(_pcbnew.PAD_DRAWINFO_m_DrawMode_get, _pcbnew.PAD_DRAWINFO_m_DrawMode_set)
    __swig_setmethods__["m_Color"] = _pcbnew.PAD_DRAWINFO_m_Color_set
    __swig_getmethods__["m_Color"] = _pcbnew.PAD_DRAWINFO_m_Color_get
    if _newclass:m_Color = _swig_property(_pcbnew.PAD_DRAWINFO_m_Color_get, _pcbnew.PAD_DRAWINFO_m_Color_set)
    __swig_setmethods__["m_HoleColor"] = _pcbnew.PAD_DRAWINFO_m_HoleColor_set
    __swig_getmethods__["m_HoleColor"] = _pcbnew.PAD_DRAWINFO_m_HoleColor_get
    if _newclass:m_HoleColor = _swig_property(_pcbnew.PAD_DRAWINFO_m_HoleColor_get, _pcbnew.PAD_DRAWINFO_m_HoleColor_set)
    __swig_setmethods__["m_NPHoleColor"] = _pcbnew.PAD_DRAWINFO_m_NPHoleColor_set
    __swig_getmethods__["m_NPHoleColor"] = _pcbnew.PAD_DRAWINFO_m_NPHoleColor_get
    if _newclass:m_NPHoleColor = _swig_property(_pcbnew.PAD_DRAWINFO_m_NPHoleColor_get, _pcbnew.PAD_DRAWINFO_m_NPHoleColor_set)
    __swig_setmethods__["m_PadClearance"] = _pcbnew.PAD_DRAWINFO_m_PadClearance_set
    __swig_getmethods__["m_PadClearance"] = _pcbnew.PAD_DRAWINFO_m_PadClearance_get
    if _newclass:m_PadClearance = _swig_property(_pcbnew.PAD_DRAWINFO_m_PadClearance_get, _pcbnew.PAD_DRAWINFO_m_PadClearance_set)
    __swig_setmethods__["m_Mask_margin"] = _pcbnew.PAD_DRAWINFO_m_Mask_margin_set
    __swig_getmethods__["m_Mask_margin"] = _pcbnew.PAD_DRAWINFO_m_Mask_margin_get
    if _newclass:m_Mask_margin = _swig_property(_pcbnew.PAD_DRAWINFO_m_Mask_margin_get, _pcbnew.PAD_DRAWINFO_m_Mask_margin_set)
    __swig_setmethods__["m_Display_padnum"] = _pcbnew.PAD_DRAWINFO_m_Display_padnum_set
    __swig_getmethods__["m_Display_padnum"] = _pcbnew.PAD_DRAWINFO_m_Display_padnum_get
    if _newclass:m_Display_padnum = _swig_property(_pcbnew.PAD_DRAWINFO_m_Display_padnum_get, _pcbnew.PAD_DRAWINFO_m_Display_padnum_set)
    __swig_setmethods__["m_Display_netname"] = _pcbnew.PAD_DRAWINFO_m_Display_netname_set
    __swig_getmethods__["m_Display_netname"] = _pcbnew.PAD_DRAWINFO_m_Display_netname_get
    if _newclass:m_Display_netname = _swig_property(_pcbnew.PAD_DRAWINFO_m_Display_netname_get, _pcbnew.PAD_DRAWINFO_m_Display_netname_set)
    __swig_setmethods__["m_ShowPadFilled"] = _pcbnew.PAD_DRAWINFO_m_ShowPadFilled_set
    __swig_getmethods__["m_ShowPadFilled"] = _pcbnew.PAD_DRAWINFO_m_ShowPadFilled_get
    if _newclass:m_ShowPadFilled = _swig_property(_pcbnew.PAD_DRAWINFO_m_ShowPadFilled_get, _pcbnew.PAD_DRAWINFO_m_ShowPadFilled_set)
    __swig_setmethods__["m_ShowNCMark"] = _pcbnew.PAD_DRAWINFO_m_ShowNCMark_set
    __swig_getmethods__["m_ShowNCMark"] = _pcbnew.PAD_DRAWINFO_m_ShowNCMark_get
    if _newclass:m_ShowNCMark = _swig_property(_pcbnew.PAD_DRAWINFO_m_ShowNCMark_get, _pcbnew.PAD_DRAWINFO_m_ShowNCMark_set)
    __swig_setmethods__["m_ShowNotPlatedHole"] = _pcbnew.PAD_DRAWINFO_m_ShowNotPlatedHole_set
    __swig_getmethods__["m_ShowNotPlatedHole"] = _pcbnew.PAD_DRAWINFO_m_ShowNotPlatedHole_get
    if _newclass:m_ShowNotPlatedHole = _swig_property(_pcbnew.PAD_DRAWINFO_m_ShowNotPlatedHole_get, _pcbnew.PAD_DRAWINFO_m_ShowNotPlatedHole_set)
    __swig_setmethods__["m_IsPrinting"] = _pcbnew.PAD_DRAWINFO_m_IsPrinting_set
    __swig_getmethods__["m_IsPrinting"] = _pcbnew.PAD_DRAWINFO_m_IsPrinting_get
    if _newclass:m_IsPrinting = _swig_property(_pcbnew.PAD_DRAWINFO_m_IsPrinting_get, _pcbnew.PAD_DRAWINFO_m_IsPrinting_set)
    __swig_setmethods__["m_Offset"] = _pcbnew.PAD_DRAWINFO_m_Offset_set
    __swig_getmethods__["m_Offset"] = _pcbnew.PAD_DRAWINFO_m_Offset_get
    if _newclass:m_Offset = _swig_property(_pcbnew.PAD_DRAWINFO_m_Offset_get, _pcbnew.PAD_DRAWINFO_m_Offset_set)
   def __init__(self):
        """
        __init__(PAD_DRAWINFO self) -> PAD_DRAWINFO

        PAD_DRAWINFO::PAD_DRAWINFO()
        """
        this = _pcbnew.new_PAD_DRAWINFO()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PAD_DRAWINFO
    __del__ = lambda self : None;
PAD_DRAWINFO_swigregister = _pcbnew.PAD_DRAWINFO_swigregister
PAD_DRAWINFO_swigregister(PAD_DRAWINFO)

class D_PAD(BOARD_CONNECTED_ITEM):
    """C++ includes: class_pad.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_CONNECTED_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, D_PAD, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_CONNECTED_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, D_PAD, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(D_PAD self, MODULE parent) -> D_PAD

        D_PAD::D_PAD(MODULE *parent)
        """
        this = _pcbnew.new_D_PAD(*args)
        try: self.this.append(this)
        except: self.this = this
   def StandardMask():
        """StandardMask() -> LSET"""
        return _pcbnew.D_PAD_StandardMask()

    if _newclass:StandardMask = staticmethod(StandardMask)
    __swig_getmethods__["StandardMask"] = lambda x: StandardMask
   def SMDMask():
        """SMDMask() -> LSET"""
        return _pcbnew.D_PAD_SMDMask()

    if _newclass:SMDMask = staticmethod(SMDMask)
    __swig_getmethods__["SMDMask"] = lambda x: SMDMask
   def ConnSMDMask():
        """ConnSMDMask() -> LSET"""
        return _pcbnew.D_PAD_ConnSMDMask()

    if _newclass:ConnSMDMask = staticmethod(ConnSMDMask)
    __swig_getmethods__["ConnSMDMask"] = lambda x: ConnSMDMask
   def UnplatedHoleMask():
        """UnplatedHoleMask() -> LSET"""
        return _pcbnew.D_PAD_UnplatedHoleMask()

    if _newclass:UnplatedHoleMask = staticmethod(UnplatedHoleMask)
    __swig_getmethods__["UnplatedHoleMask"] = lambda x: UnplatedHoleMask
   def Copy(self, *args):
        """
        Copy(D_PAD self, D_PAD source)

        void D_PAD::Copy(D_PAD *source)

        """
        return _pcbnew.D_PAD_Copy(self, *args)

   def Next(self):
        """
        Next(D_PAD self) -> D_PAD

        D_PAD* D_PAD::Next() const
        """
        return _pcbnew.D_PAD_Next(self)

   def GetParent(self):
        """
        GetParent(D_PAD self) -> MODULE

        MODULE* D_PAD::GetParent()
        const
        """
        return _pcbnew.D_PAD_GetParent(self)

   def SetPadName(self, *args):
        """
        SetPadName(D_PAD self, wxString const & name)

        void
        D_PAD::SetPadName(const wxString &name)
        """
        return _pcbnew.D_PAD_SetPadName(self, *args)

   def GetPadName(self):
        """
        GetPadName(D_PAD self) -> wxString const

        const wxString
        D_PAD::GetPadName() const
        """
        return _pcbnew.D_PAD_GetPadName(self)

   def PadNameEqual(self, *args):
        """
        PadNameEqual(D_PAD self, D_PAD other) -> bool

        bool
        D_PAD::PadNameEqual(const D_PAD *other) const
        """
        return _pcbnew.D_PAD_PadNameEqual(self, *args)

   def GetShape(self):
        """
        GetShape(D_PAD self) -> PAD_SHAPE_T

        PAD_SHAPE_T D_PAD::GetShape()
        const

        Function GetShape.

        the shape of this pad.
        """
        return _pcbnew.D_PAD_GetShape(self)

   def SetShape(self, *args):
        """
        SetShape(D_PAD self, PAD_SHAPE_T aShape)

        void
        D_PAD::SetShape(PAD_SHAPE_T aShape)
        """
        return _pcbnew.D_PAD_SetShape(self, *args)

   def SetPosition(self, *args):
        """
        SetPosition(D_PAD self, wxPoint aPos)

        void
        D_PAD::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.D_PAD_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(D_PAD self) -> wxPoint

        const wxPoint&
        D_PAD::GetPosition() const
        """
        return _pcbnew.D_PAD_GetPosition(self)

   def SetY(self, *args):
        """
        SetY(D_PAD self, int y)

        void D_PAD::SetY(int y)
        """
        return _pcbnew.D_PAD_SetY(self, *args)

   def SetX(self, *args):
        """
        SetX(D_PAD self, int x)

        void D_PAD::SetX(int x)
        """
        return _pcbnew.D_PAD_SetX(self, *args)

   def SetPos0(self, *args):
        """
        SetPos0(D_PAD self, wxPoint aPos)

        void D_PAD::SetPos0(const
        wxPoint &aPos)
        """
        return _pcbnew.D_PAD_SetPos0(self, *args)

   def GetPos0(self):
        """
        GetPos0(D_PAD self) -> wxPoint

        const wxPoint&
        D_PAD::GetPos0() const
        """
        return _pcbnew.D_PAD_GetPos0(self)

   def SetY0(self, *args):
        """
        SetY0(D_PAD self, int y)

        void D_PAD::SetY0(int y)
        """
        return _pcbnew.D_PAD_SetY0(self, *args)

   def SetX0(self, *args):
        """
        SetX0(D_PAD self, int x)

        void D_PAD::SetX0(int x)
        """
        return _pcbnew.D_PAD_SetX0(self, *args)

   def SetSize(self, *args):
        """
        SetSize(D_PAD self, wxSize aSize)

        void D_PAD::SetSize(const
        wxSize &aSize)
        """
        return _pcbnew.D_PAD_SetSize(self, *args)

   def GetSize(self):
        """
        GetSize(D_PAD self) -> wxSize

        const wxSize& D_PAD::GetSize()
        const
        """
        return _pcbnew.D_PAD_GetSize(self)

   def SetDelta(self, *args):
        """
        SetDelta(D_PAD self, wxSize aSize)

        void D_PAD::SetDelta(const
        wxSize &aSize)
        """
        return _pcbnew.D_PAD_SetDelta(self, *args)

   def GetDelta(self):
        """
        GetDelta(D_PAD self) -> wxSize

        const wxSize&
        D_PAD::GetDelta() const
        """
        return _pcbnew.D_PAD_GetDelta(self)

   def SetDrillSize(self, *args):
        """
        SetDrillSize(D_PAD self, wxSize aSize)

        void
        D_PAD::SetDrillSize(const wxSize &aSize)
        """
        return _pcbnew.D_PAD_SetDrillSize(self, *args)

   def GetDrillSize(self):
        """
        GetDrillSize(D_PAD self) -> wxSize

        const wxSize&
        D_PAD::GetDrillSize() const
        """
        return _pcbnew.D_PAD_GetDrillSize(self)

   def SetOffset(self, *args):
        """
        SetOffset(D_PAD self, wxPoint aOffset)

        void D_PAD::SetOffset(const
        wxPoint &aOffset)
        """
        return _pcbnew.D_PAD_SetOffset(self, *args)

   def GetOffset(self):
        """
        GetOffset(D_PAD self) -> wxPoint

        const wxPoint&
        D_PAD::GetOffset() const
        """
        return _pcbnew.D_PAD_GetOffset(self)

   def Flip(self, *args):
        """
        Flip(D_PAD self, wxPoint aCentre)

        void D_PAD::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.D_PAD_Flip(self, *args)

   def SetOrientation(self, *args):
        """
        SetOrientation(D_PAD self, double aAngle)

        void
        D_PAD::SetOrientation(double aAngle)

        Function SetOrientation sets the rotation angle of the pad.

        Parameters:
        -----------

        aAngle:  is tenths of degrees, but will soon be degrees. If it is
        outside of 0 - 3600, then it will be normalized before being saved.
        """
        return _pcbnew.D_PAD_SetOrientation(self, *args)

   def GetOrientation(self):
        """
        GetOrientation(D_PAD self) -> double

        double
        D_PAD::GetOrientation() const

        Function GetOrientation returns the rotation angle of the pad in
        tenths of degrees, but soon degrees.
        """
        return _pcbnew.D_PAD_GetOrientation(self)

   def SetDrillShape(self, *args):
        """
        SetDrillShape(D_PAD self, PAD_DRILL_SHAPE_T aDrillShape)

        void
        D_PAD::SetDrillShape(PAD_DRILL_SHAPE_T aDrillShape)
        """
        return _pcbnew.D_PAD_SetDrillShape(self, *args)

   def GetDrillShape(self):
        """
        GetDrillShape(D_PAD self) -> PAD_DRILL_SHAPE_T

        PAD_DRILL_SHAPE_T
        D_PAD::GetDrillShape() const
        """
        return _pcbnew.D_PAD_GetDrillShape(self)

   def GetOblongDrillGeometry(self, *args):
        """
        GetOblongDrillGeometry(D_PAD self, wxPoint aStartPoint, wxPoint aEndPoint, int & aWidth)

        void
        D_PAD::GetOblongDrillGeometry(wxPoint &aStartPoint, wxPoint
        &aEndPoint, int &aWidth) const

        Function GetOblongDrillGeometry calculates the start point, end point
        and width of an equivalent segment which have the same position and
        width as the hole Usefull to plot/draw oblong holes like segments with
        rounded ends used in draw and plot functions.

        Parameters:
        -----------

        aStartPoint:  = first point of the equivalent segment, relative to the
        pad position.

        aEndPoint:  = second point of the equivalent segment, relative to the
        pad position.

        aWidth:  = width equivalent segment.
        """
        return _pcbnew.D_PAD_GetOblongDrillGeometry(self, *args)

   def SetLayerSet(self, *args):
        """
        SetLayerSet(D_PAD self, LSET aLayerMask)

        void
        D_PAD::SetLayerSet(LSET aLayerMask)
        """
        return _pcbnew.D_PAD_SetLayerSet(self, *args)

   def GetLayerSet(self):
        """
        GetLayerSet(D_PAD self) -> LSET

        LSET D_PAD::GetLayerSet()
        const
        """
        return _pcbnew.D_PAD_GetLayerSet(self)

   def SetAttribute(self, *args):
        """
        SetAttribute(D_PAD self, PAD_ATTR_T aAttribute)

        void
        D_PAD::SetAttribute(PAD_ATTR_T aAttribute)
        """
        return _pcbnew.D_PAD_SetAttribute(self, *args)

   def GetAttribute(self):
        """
        GetAttribute(D_PAD self) -> PAD_ATTR_T

        PAD_ATTR_T
        D_PAD::GetAttribute() const
        """
        return _pcbnew.D_PAD_GetAttribute(self)

   def SetPadToDieLength(self, *args):
        """
        SetPadToDieLength(D_PAD self, int aLength)

        void
        D_PAD::SetPadToDieLength(int aLength)
        """
        return _pcbnew.D_PAD_SetPadToDieLength(self, *args)

   def GetPadToDieLength(self):
        """
        GetPadToDieLength(D_PAD self) -> int

        int
        D_PAD::GetPadToDieLength() const
        """
        return _pcbnew.D_PAD_GetPadToDieLength(self)

   def GetLocalSolderMaskMargin(self):
        """
        GetLocalSolderMaskMargin(D_PAD self) -> int

        int
        D_PAD::GetLocalSolderMaskMargin() const
        """
        return _pcbnew.D_PAD_GetLocalSolderMaskMargin(self)

   def SetLocalSolderMaskMargin(self, *args):
        """
        SetLocalSolderMaskMargin(D_PAD self, int aMargin)

        void
        D_PAD::SetLocalSolderMaskMargin(int aMargin)
        """
        return _pcbnew.D_PAD_SetLocalSolderMaskMargin(self, *args)

   def GetLocalClearance(self):
        """
        GetLocalClearance(D_PAD self) -> int

        int
        D_PAD::GetLocalClearance() const
        """
        return _pcbnew.D_PAD_GetLocalClearance(self)

   def SetLocalClearance(self, *args):
        """
        SetLocalClearance(D_PAD self, int aClearance)

        void
        D_PAD::SetLocalClearance(int aClearance)
        """
        return _pcbnew.D_PAD_SetLocalClearance(self, *args)

   def GetLocalSolderPasteMargin(self):
        """
        GetLocalSolderPasteMargin(D_PAD self) -> int

        int
        D_PAD::GetLocalSolderPasteMargin() const
        """
        return _pcbnew.D_PAD_GetLocalSolderPasteMargin(self)

   def SetLocalSolderPasteMargin(self, *args):
        """
        SetLocalSolderPasteMargin(D_PAD self, int aMargin)

        void
        D_PAD::SetLocalSolderPasteMargin(int aMargin)
        """
        return _pcbnew.D_PAD_SetLocalSolderPasteMargin(self, *args)

   def GetLocalSolderPasteMarginRatio(self):
        """
        GetLocalSolderPasteMarginRatio(D_PAD self) -> double

        double
        D_PAD::GetLocalSolderPasteMarginRatio() const
        """
        return _pcbnew.D_PAD_GetLocalSolderPasteMarginRatio(self)

   def SetLocalSolderPasteMarginRatio(self, *args):
        """
        SetLocalSolderPasteMarginRatio(D_PAD self, double aRatio)

        void
        D_PAD::SetLocalSolderPasteMarginRatio(double aRatio)
        """
        return _pcbnew.D_PAD_SetLocalSolderPasteMarginRatio(self, *args)

   def TransformShapeWithClearanceToPolygon(self, *args):
        """
        TransformShapeWithClearanceToPolygon(D_PAD self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount, double aCorrectionFactor)

        void D_PAD::TransformShapeWithClearanceToPolygon(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount,
        double aCorrectionFactor) const

        Function TransformShapeWithClearanceToPolygon Convert the pad shape to
        a closed polygon Used in filling zones calculations Circles and arcs
        are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the pad

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approximated by segment bigger or
        equal to the real clearance value (usually near from 1.0)
        """
        return _pcbnew.D_PAD_TransformShapeWithClearanceToPolygon(self, *args)

   def GetClearance(self, aItem=None):
        """
        GetClearance(D_PAD self, BOARD_CONNECTED_ITEM aItem=None) -> int
        GetClearance(D_PAD self) -> int

        int
        D_PAD::GetClearance(BOARD_CONNECTED_ITEM *aItem=NULL) const

        Function GetClearance returns the clearance in internal units.

        If aItem is not NULL then the returned clearance is the greater of
        this object's clearance and aItem's clearance. If aItem is NULL, then
        this objects clearance is returned.

        Parameters:
        -----------

        aItem:  is another BOARD_CONNECTED_ITEM or NULL

        int - the clearance in internal units.
        """
        return _pcbnew.D_PAD_GetClearance(self, aItem)

   def GetSolderMaskMargin(self):
        """
        GetSolderMaskMargin(D_PAD self) -> int

        int
        D_PAD::GetSolderMaskMargin() const

        Function GetSolderMaskMargin.

        the margin for the solder mask layer usually > 0 (mask shape bigger
        than pad value is 1 - the local value 2 - if null, the parent
        footprint value 1 - if null, the global value
        """
        return _pcbnew.D_PAD_GetSolderMaskMargin(self)

   def GetSolderPasteMargin(self):
        """
        GetSolderPasteMargin(D_PAD self) -> wxSize

        wxSize
        D_PAD::GetSolderPasteMargin() const

        Function GetSolderPasteMargin.

        the margin for the solder mask layer usually < 0 (mask shape smaller
        than pad because the margin can be dependent on the pad size, the
        margin has a x and a y value value is 1 - the local value 2 - if null,
        the parent footprint value 1 - if null, the global value
        """
        return _pcbnew.D_PAD_GetSolderPasteMargin(self)

   def SetZoneConnection(self, *args):
        """
        SetZoneConnection(D_PAD self, ZoneConnection aType)

        void
        D_PAD::SetZoneConnection(ZoneConnection aType)
        """
        return _pcbnew.D_PAD_SetZoneConnection(self, *args)

   def GetZoneConnection(self):
        """
        GetZoneConnection(D_PAD self) -> ZoneConnection

        ZoneConnection
        D_PAD::GetZoneConnection() const
        """
        return _pcbnew.D_PAD_GetZoneConnection(self)

   def SetThermalWidth(self, *args):
        """
        SetThermalWidth(D_PAD self, int aWidth)

        void
        D_PAD::SetThermalWidth(int aWidth)
        """
        return _pcbnew.D_PAD_SetThermalWidth(self, *args)

   def GetThermalWidth(self):
        """
        GetThermalWidth(D_PAD self) -> int

        int
        D_PAD::GetThermalWidth() const
        """
        return _pcbnew.D_PAD_GetThermalWidth(self)

   def SetThermalGap(self, *args):
        """
        SetThermalGap(D_PAD self, int aGap)

        void
        D_PAD::SetThermalGap(int aGap)
        """
        return _pcbnew.D_PAD_SetThermalGap(self, *args)

   def GetThermalGap(self):
        """
        GetThermalGap(D_PAD self) -> int

        int
        D_PAD::GetThermalGap() const
        """
        return _pcbnew.D_PAD_GetThermalGap(self)

   def Draw(self, *args):
        """
        Draw(D_PAD self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(D_PAD self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void D_PAD::Draw(EDA_DRAW_PANEL
        *aPanel, wxDC *aDC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.D_PAD_Draw(self, *args)

   def DrawShape(self, *args):
        """
        DrawShape(D_PAD self, EDA_RECT aClipBox, wxDC * aDC, PAD_DRAWINFO aDrawInfo)

        void
        D_PAD::DrawShape(EDA_RECT *aClipBox, wxDC *aDC, PAD_DRAWINFO
        &aDrawInfo)

        Function DrawShape basic function to draw a pad.

        This function is used by Draw after calculation of parameters (color,
        ) final orientation transforms are set. It can also be called to draw
        a pad on any panel even if this panel is not a EDA_DRAW_PANEL for
        instance on a wxPanel inside the pad editor.
        """
        return _pcbnew.D_PAD_DrawShape(self, *args)

   def BuildPadPolygon(self, *args):
        """
        BuildPadPolygon(D_PAD self, wxPoint aCoord, wxSize aInflateValue, double aRotation)

        void
        D_PAD::BuildPadPolygon(wxPoint aCoord[4], wxSize aInflateValue, double
        aRotation) const

        Function BuildPadPolygon Has meaning only for polygonal pads
        (trapezoid and rectangular) Build the Corner list of the polygonal
        shape, depending on shape, extra size (clearance ...) and orientation.

        Parameters:
        -----------

        aCoord:  = a buffer to fill (4 corners).

        aInflateValue:  = wxSize: the clearance or margin value. value > 0:
       inflate, < 0 deflate

        aRotation:  = full rotation of the polygon
        """
        return _pcbnew.D_PAD_BuildPadPolygon(self, *args)

   def BuildPadShapePolygon(self, *args):
        """
        BuildPadShapePolygon(D_PAD self, CPOLYGONS_LIST aCornerBuffer, wxSize aInflateValue, int aSegmentsPerCircle, double aCorrectionFactor)

        void
        D_PAD::BuildPadShapePolygon(CPOLYGONS_LIST &aCornerBuffer, wxSize
        aInflateValue, int aSegmentsPerCircle, double aCorrectionFactor) const

        Function BuildPadShapePolygon Build the Corner list of the polygonal
        shape, depending on shape, extra size (clearance ...) pad and
        orientation This function is similar to
        TransformShapeWithClearanceToPolygon, but the difference is
        BuildPadShapePolygon creates a polygon shape exactly similar to pad
        shape, which a size inflated by aInflateValue and
        TransformShapeWithClearanceToPolygon creates a more complex shape (for
        instance a rectangular pad is converted in a rectangulr shape with
        ronded corners)

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to fill.

        aInflateValue:  = the clearance or margin value. value > 0: inflate, <
       0 deflate, = 0 : no change the clearance can have different values for
        x and y directions (relative to the pad)

        aSegmentsPerCircle:  = number of segments to approximate a circle
        (used for round and oblong shapes only (16 to 32 is a good value)

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep the pad size when the circle is approximated by segments
        """
        return _pcbnew.D_PAD_BuildPadShapePolygon(self, *args)

   def BuildPadDrillShapePolygon(self, *args):
        """
        BuildPadDrillShapePolygon(D_PAD self, CPOLYGONS_LIST aCornerBuffer, int aInflateValue, int aSegmentsPerCircle) -> bool

        bool
        D_PAD::BuildPadDrillShapePolygon(CPOLYGONS_LIST &aCornerBuffer, int
        aInflateValue, int aSegmentsPerCircle) const

        Function BuildPadDrillShapePolygon Build the Corner list of the
        polygonal drill shape, depending on shape pad hole and orientation.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to fill.

        aInflateValue:  = the clearance or margin value. value > 0: inflate, <
       0 deflate, = 0 : no change

        aSegmentsPerCircle:  = number of segments to approximate a circle
        (used for round and oblong shapes only(16 to 32 is a good value)

        false if the pad has no hole, true otherwise
        """
        return _pcbnew.D_PAD_BuildPadDrillShapePolygon(self, *args)

   def BuildSegmentFromOvalShape(self, *args):
        """
        BuildSegmentFromOvalShape(D_PAD self, wxPoint aSegStart, wxPoint aSegEnd, double aRotation, wxSize aMargin) -> int

        int
        D_PAD::BuildSegmentFromOvalShape(wxPoint &aSegStart, wxPoint &aSegEnd,
        double aRotation, const wxSize &aMargin) const

        Function BuildSegmentFromOvalShape Has meaning only for OVAL (and
        ROUND) pads Build an equivalent segment having the same shape as the
        OVAL shape, Useful in draw function and in DRC and HitTest functions,
        because segments are already well handled by track tests.

        Function BuildSegmentFromOvalShape Has meaning only for OVAL (and
        ROUND) pads.

        Parameters:
        -----------

        aSegStart:  = the starting point of the equivalent segment relative to
        the shape position.

        aSegEnd:  = the ending point of the equivalent segment, relative to
        the shape position

        aRotation:  = full rotation of the segment

        aRotation:  = full rotation of the segment

        aMargin:  = a margin around the shape (for instance mask margin)

        the width of the segment  Build an equivalent segment having the same
        shape as the OVAL shape, aSegStart and aSegEnd are the ending points
        of the equivalent segment of the shape aRotation is the asked rotation
        of the segment (usually m_Orient)
        """
        return _pcbnew.D_PAD_BuildSegmentFromOvalShape(self, *args)

   def StringPadName(self, *args):
        """
        StringPadName(D_PAD self, wxString & text)

        void
        D_PAD::StringPadName(wxString &text) const
        """
        return _pcbnew.D_PAD_StringPadName(self, *args)

   def GetBoundingRadius(self):
        """
        GetBoundingRadius(D_PAD self) -> int

        int
        D_PAD::GetBoundingRadius() const

        Function GetBoundingRadius returns the radius of a minimum sized
        circle which fully encloses this pad.
        """
        return _pcbnew.D_PAD_GetBoundingRadius(self)

   def ShapePos(self):
        """
        ShapePos(D_PAD self) -> wxPoint

        const wxPoint
        D_PAD::ShapePos() const
        """
        return _pcbnew.D_PAD_ShapePos(self)

   def GetSubRatsnest(self):
        """
        GetSubRatsnest(D_PAD self) -> int

        int
        D_PAD::GetSubRatsnest() const

        Function GetSubRatsnest.

        int - the netcode
        """
        return _pcbnew.D_PAD_GetSubRatsnest(self)

   def SetSubRatsnest(self, *args):
        """
        SetSubRatsnest(D_PAD self, int aSubRatsnest)

        void
        D_PAD::SetSubRatsnest(int aSubRatsnest)
        """
        return _pcbnew.D_PAD_SetSubRatsnest(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(D_PAD self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        D_PAD::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.D_PAD_GetMsgPanelInfo(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(D_PAD self, LAYER_ID aLayer) -> bool

        bool
        D_PAD::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.D_PAD_IsOnLayer(self, *args)

   def HitTest(self, *args):
        """
        HitTest(D_PAD self, wxPoint aPosition) -> bool

        virtual bool
        BOARD_ITEM::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Function HitTest tests if the aRect intersects or contains this object
        (depending on aContained).

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.D_PAD_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(D_PAD self) -> wxString

        wxString D_PAD::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.D_PAD_GetClass(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(D_PAD self) -> EDA_RECT

        const EDA_RECT
        D_PAD::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.D_PAD_GetBoundingBox(self)

   def SetDrawCoord(self):
        """
        SetDrawCoord(D_PAD self)

        void
        D_PAD::SetDrawCoord()

        Set absolute coordinates.
        """
        return _pcbnew.D_PAD_SetDrawCoord(self)

   def SetLocalCoord(self):
        """
        SetLocalCoord(D_PAD self)

        void
        D_PAD::SetLocalCoord()

        Set relative coordinates.
        """
        return _pcbnew.D_PAD_SetLocalCoord(self)

   def Compare(*args):
        """Compare(D_PAD padref, D_PAD padcmp) -> int"""
        return _pcbnew.D_PAD_Compare(*args)

    if _newclass:Compare = staticmethod(Compare)
    __swig_getmethods__["Compare"] = lambda x: Compare
   def Move(self, *args):
        """
        Move(D_PAD self, wxPoint aMoveVector)

        void D_PAD::Move(const wxPoint
        &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.D_PAD_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(D_PAD self, wxPoint aRotCentre, double aAngle)

        void D_PAD::Rotate(const
        wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.D_PAD_Rotate(self, *args)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(D_PAD self) -> wxString

        wxString
        D_PAD::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.D_PAD_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(D_PAD self) -> BITMAP_DEF

        BITMAP_DEF
        D_PAD::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.D_PAD_GetMenuImage(self)

   def ShowPadShape(self):
        """
        ShowPadShape(D_PAD self) -> wxString

        wxString
        D_PAD::ShowPadShape() const

        Function ShowPadShape.

        the name of the shape
        """
        return _pcbnew.D_PAD_ShowPadShape(self)

   def ShowPadAttr(self):
        """
        ShowPadAttr(D_PAD self) -> wxString

        wxString
        D_PAD::ShowPadAttr() const

        Function ShowPadAttr.

        the name of the pad type (attribute) : STD, SMD ...
        """
        return _pcbnew.D_PAD_ShowPadAttr(self)

   def AppendConfigs(self, *args):
        """
        AppendConfigs(D_PAD self, PARAM_CFG_ARRAY * aResult)

        void
        D_PAD::AppendConfigs(PARAM_CFG_ARRAY *aResult)

        Function AppendConfigs appends to aResult the configuration setting
        accessors which will later allow reading or writing of configuration
        file information directly into this object.
        """
        return _pcbnew.D_PAD_AppendConfigs(self, *args)

   def Clone(self):
        """
        Clone(D_PAD self) -> EDA_ITEM

        EDA_ITEM * D_PAD::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.D_PAD_Clone(self)

   def Duplicate(self):
        """
        Duplicate(D_PAD self) -> D_PAD

        D_PAD* D_PAD::Duplicate()
        const

        same as Clone, but returns a D_PAD item.

        Useful mainly for pythons scripts, because Clone (virtual function)
        returns an EDA_ITEM.
        """
        return _pcbnew.D_PAD_Duplicate(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(D_PAD self, int [] aLayers, int & aCount)

        void
        D_PAD::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.D_PAD_ViewGetLayers(self, *args)

   def ViewGetLOD(self, *args):
        """
        ViewGetLOD(D_PAD self, int aLayer) -> unsigned int

        unsigned int
        D_PAD::ViewGetLOD(int aLayer) const
        """
        return _pcbnew.D_PAD_ViewGetLOD(self, *args)

   def ViewBBox(self):
        """
        ViewBBox(D_PAD self) -> BOX2I const

        const BOX2I D_PAD::ViewBBox()
        const
        """
        return _pcbnew.D_PAD_ViewBBox(self)

   def CopyNetlistSettings(self, *args):
        """
        CopyNetlistSettings(D_PAD self, D_PAD aPad)

        void
        D_PAD::CopyNetlistSettings(D_PAD *aPad)

        Function CopyNetlistSettings copies the netlist settings to aPad.

       The netlist settings are all of the D_PAD settings not define by a
        D_PAD in a netlist. These setting include local clearances, net names,
        etc. The pad physical geometry settings are not copied.

        Parameters:
        -----------

        aPad:  is the D_PAD to copy the settings to.
        """
        return _pcbnew.D_PAD_CopyNetlistSettings(self, *args)

    __swig_destroy__ = _pcbnew.delete_D_PAD
    __del__ = lambda self : None;
D_PAD_swigregister = _pcbnew.D_PAD_swigregister
D_PAD_swigregister(D_PAD)

def D_PAD_StandardMask():
  """D_PAD_StandardMask() -> LSET"""
  return _pcbnew.D_PAD_StandardMask()

def D_PAD_SMDMask():
  """D_PAD_SMDMask() -> LSET"""
  return _pcbnew.D_PAD_SMDMask()

def D_PAD_ConnSMDMask():
  """D_PAD_ConnSMDMask() -> LSET"""
  return _pcbnew.D_PAD_ConnSMDMask()

def D_PAD_UnplatedHoleMask():
  """D_PAD_UnplatedHoleMask() -> LSET"""
  return _pcbnew.D_PAD_UnplatedHoleMask()

def D_PAD_Compare(*args):
  """D_PAD_Compare(D_PAD padref, D_PAD padcmp) -> int"""
  return _pcbnew.D_PAD_Compare(*args)

PAD_CIRCLE = _pcbnew.PAD_CIRCLE
PAD_ROUND = _pcbnew.PAD_ROUND
PAD_RECT = _pcbnew.PAD_RECT
PAD_OVAL = _pcbnew.PAD_OVAL
PAD_TRAPEZOID = _pcbnew.PAD_TRAPEZOID
PAD_DRILL_CIRCLE = _pcbnew.PAD_DRILL_CIRCLE
PAD_DRILL_OBLONG = _pcbnew.PAD_DRILL_OBLONG
PAD_STANDARD = _pcbnew.PAD_STANDARD
PAD_SMD = _pcbnew.PAD_SMD
PAD_CONN = _pcbnew.PAD_CONN
PAD_HOLE_NOT_PLATED = _pcbnew.PAD_HOLE_NOT_PLATED
CH_VISIBLE = _pcbnew.CH_VISIBLE
CH_UNROUTABLE = _pcbnew.CH_UNROUTABLE
CH_ROUTE_REQ = _pcbnew.CH_ROUTE_REQ
CH_ACTIF = _pcbnew.CH_ACTIF
LOCAL_RATSNEST_ITEM = _pcbnew.LOCAL_RATSNEST_ITEM
class RATSNEST_ITEM(_object):
    """
    Class RATSNEST_ITEM describes a ratsnest line: a straight line
    connecting 2 pads.

    C++ includes: class_netinfo.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RATSNEST_ITEM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RATSNEST_ITEM, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_Status"] = _pcbnew.RATSNEST_ITEM_m_Status_set
    __swig_getmethods__["m_Status"] = _pcbnew.RATSNEST_ITEM_m_Status_get
    if _newclass:m_Status = _swig_property(_pcbnew.RATSNEST_ITEM_m_Status_get, _pcbnew.RATSNEST_ITEM_m_Status_set)
    __swig_setmethods__["m_PadStart"] = _pcbnew.RATSNEST_ITEM_m_PadStart_set
    __swig_getmethods__["m_PadStart"] = _pcbnew.RATSNEST_ITEM_m_PadStart_get
    if _newclass:m_PadStart = _swig_property(_pcbnew.RATSNEST_ITEM_m_PadStart_get, _pcbnew.RATSNEST_ITEM_m_PadStart_set)
    __swig_setmethods__["m_PadEnd"] = _pcbnew.RATSNEST_ITEM_m_PadEnd_set
    __swig_getmethods__["m_PadEnd"] = _pcbnew.RATSNEST_ITEM_m_PadEnd_get
    if _newclass:m_PadEnd = _swig_property(_pcbnew.RATSNEST_ITEM_m_PadEnd_get, _pcbnew.RATSNEST_ITEM_m_PadEnd_set)
    __swig_setmethods__["m_Lenght"] = _pcbnew.RATSNEST_ITEM_m_Lenght_set
    __swig_getmethods__["m_Lenght"] = _pcbnew.RATSNEST_ITEM_m_Lenght_get
    if _newclass:m_Lenght = _swig_property(_pcbnew.RATSNEST_ITEM_m_Lenght_get, _pcbnew.RATSNEST_ITEM_m_Lenght_set)
   def __init__(self):
        """
        __init__(RATSNEST_ITEM self) -> RATSNEST_ITEM

        RATSNEST_ITEM::RATSNEST_ITEM()
        """
        this = _pcbnew.new_RATSNEST_ITEM()
        try: self.this.append(this)
        except: self.this = this
   def GetNet(self):
        """
        GetNet(RATSNEST_ITEM self) -> int

        int
        RATSNEST_ITEM::GetNet() const

        Function GetNet.

        int - the net code.
        """
        return _pcbnew.RATSNEST_ITEM_GetNet(self)

   def SetNet(self, *args):
        """
        SetNet(RATSNEST_ITEM self, int aNetCode)

        void
        RATSNEST_ITEM::SetNet(int aNetCode)
        """
        return _pcbnew.RATSNEST_ITEM_SetNet(self, *args)

   def IsVisible(self):
        """
        IsVisible(RATSNEST_ITEM self) -> bool

        bool
        RATSNEST_ITEM::IsVisible()
        """
        return _pcbnew.RATSNEST_ITEM_IsVisible(self)

   def IsActive(self):
        """
        IsActive(RATSNEST_ITEM self) -> bool

        bool
        RATSNEST_ITEM::IsActive()
        """
        return _pcbnew.RATSNEST_ITEM_IsActive(self)

   def IsLocal(self):
        """
        IsLocal(RATSNEST_ITEM self) -> bool

        bool
        RATSNEST_ITEM::IsLocal()
        """
        return _pcbnew.RATSNEST_ITEM_IsLocal(self)

   def Draw(self, *args):
        """
        Draw(RATSNEST_ITEM self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset)

        void
        RATSNEST_ITEM::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset)

        Function Draw.

        Function Draw Draws a line (a ratsnest) from the starting pad to the
        ending pad.
        """
        return _pcbnew.RATSNEST_ITEM_Draw(self, *args)

    __swig_destroy__ = _pcbnew.delete_RATSNEST_ITEM
    __del__ = lambda self : None;
RATSNEST_ITEM_swigregister = _pcbnew.RATSNEST_ITEM_swigregister
RATSNEST_ITEM_swigregister(RATSNEST_ITEM)

class NETINFO_MAPPING(_object):
    """
    C++ includes: class_netinfo.h

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NETINFO_MAPPING, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NETINFO_MAPPING, name)
    __repr__ = _swig_repr
   def SetBoard(self, *args):
        """
        SetBoard(NETINFO_MAPPING self, BOARD aBoard)

        void
        NETINFO_MAPPING::SetBoard(const BOARD *aBoard)

        Function SetBoard Sets a BOARD object that is used to prepare the net
        code map.
        """
        return _pcbnew.NETINFO_MAPPING_SetBoard(self, *args)

   def Update(self):
        """
        Update(NETINFO_MAPPING self)

        void
        NETINFO_MAPPING::Update()

        Function Update Prepares a mapping for net codes so they can be saved
        as consecutive numbers.

        To retrieve a mapped net code, use translateNet() function after
        calling this.
        """
        return _pcbnew.NETINFO_MAPPING_Update(self)

   def Translate(self, *args):
        """
        Translate(NETINFO_MAPPING self, int aNetCode) -> int

        int
        NETINFO_MAPPING::Translate(int aNetCode) const

        Function Translate Translates net number according to the map prepared
        by Update() function.

        It allows to have items stored with consecutive net codes.

        Parameters:
        -----------

        aNetCode:  is an old net code.

        Net code that follows the mapping.
        """
        return _pcbnew.NETINFO_MAPPING_Translate(self, *args)

   def GetSize(self):
        """
        GetSize(NETINFO_MAPPING self) -> int

        int
        NETINFO_MAPPING::GetSize() const

        Function GetSize.

        Number of mapped nets (i.e. not empty nets for a given BOARD object).

        """
        return _pcbnew.NETINFO_MAPPING_GetSize(self)

   def __init__(self):
        """
        __init__(NETINFO_MAPPING self) -> NETINFO_MAPPING

        C++ includes: class_netinfo.h

        """
        this = _pcbnew.new_NETINFO_MAPPING()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_NETINFO_MAPPING
    __del__ = lambda self : None;
NETINFO_MAPPING_swigregister = _pcbnew.NETINFO_MAPPING_swigregister
NETINFO_MAPPING_swigregister(NETINFO_MAPPING)

class NETINFO_LIST(_object):
    """
    Class NETINFO_LIST is a container class for NETINFO_ITEM elements,
    which are the nets.

    That makes this class a container for the nets.

    C++ includes: class_netinfo.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NETINFO_LIST, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NETINFO_LIST, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(NETINFO_LIST self, BOARD aParent) -> NETINFO_LIST

        NETINFO_LIST::NETINFO_LIST(BOARD *aParent)
        """
        this = _pcbnew.new_NETINFO_LIST(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_NETINFO_LIST
    __del__ = lambda self : None;
   def GetNetItem(self, *args):
        """
        GetNetItem(NETINFO_LIST self, int aNetCode) -> NETINFO_ITEM
        GetNetItem(NETINFO_LIST self, wxString const & aNetName) -> NETINFO_ITEM

        NETINFO_ITEM*
        NETINFO_LIST::GetNetItem(const wxString &aNetName) const

        Function GetItem.

        Parameters:
        -----------

        aNetName:  = net name to identify a given NETINFO_ITEM

        NETINFO_ITEM* - by aNetName, or NULL if not found
        """
        return _pcbnew.NETINFO_LIST_GetNetItem(self, *args)

   def GetNetCount(self):
        """
        GetNetCount(NETINFO_LIST self) -> unsigned int

        unsigned
        NETINFO_LIST::GetNetCount() const

        Function GetNetCount.

        the number of nets ( always >= 1 ) because the first net is the "not
        connected" net and always exists
        """
        return _pcbnew.NETINFO_LIST_GetNetCount(self)

   def AppendNet(self, *args):
        """
        AppendNet(NETINFO_LIST self, NETINFO_ITEM aNewElement)

        void
        NETINFO_LIST::AppendNet(NETINFO_ITEM *aNewElement)

        Function Append adds aNewElement to the end of the list.

        Negative net code means it is going to be auto-assigned.
        """
        return _pcbnew.NETINFO_LIST_AppendNet(self, *args)

   def GetPadCount(self):
        """
        GetPadCount(NETINFO_LIST self) -> unsigned int

        unsigned
        NETINFO_LIST::GetPadCount() const

        Function GetPadCount.

        the number of pads in board
        """
        return _pcbnew.NETINFO_LIST_GetPadCount(self)

   def GetPad(self, *args):
        """
        GetPad(NETINFO_LIST self, unsigned int aIdx) -> D_PAD

        D_PAD*
        NETINFO_LIST::GetPad(unsigned aIdx) const

        Function GetPads returns a list of all the pads.

        The returned list is not sorted and contains pointers to PADS, but
        those pointers do not convey ownership of the respective PADs.
        std::vector<D_PAD*>& - a full list of pads std::vector<D_PAD*>&
        GetPads() { return m_PadsFullList; } Function GetPad

        the pad idx from m_PadsFullList
        """
        return _pcbnew.NETINFO_LIST_GetPad(self, *args)

    __swig_setmethods__["ORPHANED"] = _pcbnew.NETINFO_LIST_ORPHANED_set
    __swig_getmethods__["ORPHANED"] = _pcbnew.NETINFO_LIST_ORPHANED_get
    if _newclass:ORPHANED = _swig_property(_pcbnew.NETINFO_LIST_ORPHANED_get, _pcbnew.NETINFO_LIST_ORPHANED_set)
NETINFO_LIST_swigregister = _pcbnew.NETINFO_LIST_swigregister
NETINFO_LIST_swigregister(NETINFO_LIST)
NETINFO_LIST.UNCONNECTED = _pcbnew.cvar.NETINFO_LIST_UNCONNECTED

class NETINFO_ITEM(_object):
    """
    Class NETINFO_ITEM handles the data for a net.

    C++ includes: class_netinfo.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NETINFO_ITEM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NETINFO_ITEM, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_PadInNetList"] = _pcbnew.NETINFO_ITEM_m_PadInNetList_set
    __swig_getmethods__["m_PadInNetList"] = _pcbnew.NETINFO_ITEM_m_PadInNetList_get
    if _newclass:m_PadInNetList = _swig_property(_pcbnew.NETINFO_ITEM_m_PadInNetList_get, _pcbnew.NETINFO_ITEM_m_PadInNetList_set)
    __swig_setmethods__["m_RatsnestStartIdx"] = _pcbnew.NETINFO_ITEM_m_RatsnestStartIdx_set
    __swig_getmethods__["m_RatsnestStartIdx"] = _pcbnew.NETINFO_ITEM_m_RatsnestStartIdx_get
    if _newclass:m_RatsnestStartIdx = _swig_property(_pcbnew.NETINFO_ITEM_m_RatsnestStartIdx_get, _pcbnew.NETINFO_ITEM_m_RatsnestStartIdx_set)
    __swig_setmethods__["m_RatsnestEndIdx"] = _pcbnew.NETINFO_ITEM_m_RatsnestEndIdx_set
    __swig_getmethods__["m_RatsnestEndIdx"] = _pcbnew.NETINFO_ITEM_m_RatsnestEndIdx_get
    if _newclass:m_RatsnestEndIdx = _swig_property(_pcbnew.NETINFO_ITEM_m_RatsnestEndIdx_get, _pcbnew.NETINFO_ITEM_m_RatsnestEndIdx_set)
   def __init__(self, *args):
        """
        __init__(NETINFO_ITEM self, BOARD_ITEM aParent, wxString const & aNetName=wxEmptyString, int aNetCode=-1) -> NETINFO_ITEM
        __init__(NETINFO_ITEM self, BOARD_ITEM aParent, wxString const & aNetName=wxEmptyString) -> NETINFO_ITEM
        __init__(NETINFO_ITEM self, BOARD_ITEM aParent) -> NETINFO_ITEM

        NETINFO_ITEM::NETINFO_ITEM(BOARD_ITEM *aParent, const wxString
        &aNetName=wxEmptyString, int aNetCode=-1)

        NETINFO_ITEM class, to handle info on nets: netnames, net constraints.

        """
        this = _pcbnew.new_NETINFO_ITEM(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_NETINFO_ITEM
    __del__ = lambda self : None;
   def SetClass(self, *args):
        """
        SetClass(NETINFO_ITEM self, NETCLASSPTR aNetClass)

        void
        NETINFO_ITEM::SetClass(NETCLASSPTR aNetClass)

        Function SetClass sets aNetclass into this NET.
        """
        return _pcbnew.NETINFO_ITEM_SetClass(self, *args)

   def GetNetClass(self):
        """
        GetNetClass(NETINFO_ITEM self) -> NETCLASSPTR

        NETCLASSPTR
        NETINFO_ITEM::GetNetClass()
        """
        return _pcbnew.NETINFO_ITEM_GetNetClass(self)

   def GetClassName(self):
        """
        GetClassName(NETINFO_ITEM self) -> wxString const &

        const wxString&
        NETINFO_ITEM::GetClassName() const

        Function GetClassName returns the class name.
        """
        return _pcbnew.NETINFO_ITEM_GetClassName(self)

   def GetTrackWidth(self):
        """
        GetTrackWidth(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetTrackWidth()

        Function GetTrackWidth returns the width of tracks used to route this
        net.
        """
        return _pcbnew.NETINFO_ITEM_GetTrackWidth(self)

   def GetViaSize(self):
        """
        GetViaSize(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetViaSize()

        Function GetViaSize returns the size of vias used to route this net.

        """
        return _pcbnew.NETINFO_ITEM_GetViaSize(self)

   def GetMicroViaSize(self):
        """
        GetMicroViaSize(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetMicroViaSize()

        Function GetMicroViaSize returns the size of vias used to route this
        net.
        """
        return _pcbnew.NETINFO_ITEM_GetMicroViaSize(self)

   def GetViaDrillSize(self):
        """
        GetViaDrillSize(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetViaDrillSize()

        Function GetViaDrillSize returns the size of via drills used to route
        this net.
        """
        return _pcbnew.NETINFO_ITEM_GetViaDrillSize(self)

   def GetMicroViaDrillSize(self):
        """
        GetMicroViaDrillSize(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetMicroViaDrillSize()

        Function GetViaDrillSize returns the size of via drills used to route
        this net.
        """
        return _pcbnew.NETINFO_ITEM_GetMicroViaDrillSize(self)

   def GetClearance(self, *args):
        """
        GetClearance(NETINFO_ITEM self, BOARD_ITEM aBoardItem) -> int

        int
        NETINFO_ITEM::GetClearance(BOARD_ITEM *aBoardItem)

        Function GetClearance returns the clearance when routing near
        aBoardItem.
        """
        return _pcbnew.NETINFO_ITEM_GetClearance(self, *args)

   def Draw(self, *args):
        """
        Draw(NETINFO_ITEM self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset)

        void
        NETINFO_ITEM::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset)

        Function Draw.

        Function Draw (TODO)

        Todo we actually could show a NET, simply show all the tracks and a
        pads or net name on pad and vias
        """
        return _pcbnew.NETINFO_ITEM_Draw(self, *args)

   def GetNet(self):
        """
        GetNet(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetNet() const

        Function GetNet.

        int - the netcode
        """
        return _pcbnew.NETINFO_ITEM_GetNet(self)

   def GetNodesCount(self):
        """
        GetNodesCount(NETINFO_ITEM self) -> int

        int
        NETINFO_ITEM::GetNodesCount() const

        Function GetNodesCount.

        int - number of nodes in the net
        """
        return _pcbnew.NETINFO_ITEM_GetNodesCount(self)

   def GetNetname(self):
        """
        GetNetname(NETINFO_ITEM self) -> wxString const &

        const wxString&
        NETINFO_ITEM::GetNetname() const

        Function GetNetname.

        const wxString&, a reference to the full netname
        """
        return _pcbnew.NETINFO_ITEM_GetNetname(self)

   def GetShortNetname(self):
        """
        GetShortNetname(NETINFO_ITEM self) -> wxString const &

        const wxString&
        NETINFO_ITEM::GetShortNetname() const

        Function GetShortNetname.

        const wxString &, a reference to the short netname
        """
        return _pcbnew.NETINFO_ITEM_GetShortNetname(self)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(NETINFO_ITEM self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        NETINFO_ITEM::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo returns the information about the
        NETINFO_ITEM in aList to display in the message panel.

        Parameters:
        -----------

        aList:  is the list in which to place the status information.
        """
        return _pcbnew.NETINFO_ITEM_GetMsgPanelInfo(self, *args)

   def Clear(self):
        """
        Clear(NETINFO_ITEM self)

        void
        NETINFO_ITEM::Clear()

       Function Clear sets all fields to their defaults values.
        """
        return _pcbnew.NETINFO_ITEM_Clear(self)

NETINFO_ITEM_swigregister = _pcbnew.NETINFO_ITEM_swigregister
NETINFO_ITEM_swigregister(NETINFO_ITEM)

START_ON_PAD = _pcbnew.START_ON_PAD
END_ON_PAD = _pcbnew.END_ON_PAD
START_ON_TRACK = _pcbnew.START_ON_TRACK
END_ON_TRACK = _pcbnew.END_ON_TRACK
LISTE_PAD_OK = _pcbnew.LISTE_PAD_OK
LISTE_RATSNEST_ITEM_OK = _pcbnew.LISTE_RATSNEST_ITEM_OK
RATSNEST_ITEM_LOCAL_OK = _pcbnew.RATSNEST_ITEM_LOCAL_OK
CONNEXION_OK = _pcbnew.CONNEXION_OK
NET_CODES_OK = _pcbnew.NET_CODES_OK
DO_NOT_SHOW_GENERAL_RASTNEST = _pcbnew.DO_NOT_SHOW_GENERAL_RASTNEST
class TEXTE_PCB(BOARD_ITEM,EDA_TEXT):
    """C++ includes: class_pcb_text.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM,EDA_TEXT]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TEXTE_PCB, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM,EDA_TEXT]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TEXTE_PCB, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(TEXTE_PCB self, BOARD_ITEM parent) -> TEXTE_PCB

        TEXTE_PCB::TEXTE_PCB(BOARD_ITEM *parent)
        """
        this = _pcbnew.new_TEXTE_PCB(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_TEXTE_PCB
    __del__ = lambda self : None;
   def GetPosition(self):
        """
        GetPosition(TEXTE_PCB self) -> wxPoint

        virtual const wxPoint&
        TEXTE_PCB::GetPosition() const
        """
        return _pcbnew.TEXTE_PCB_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(TEXTE_PCB self, wxPoint aPos)

        virtual void
        TEXTE_PCB::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.TEXTE_PCB_SetPosition(self, *args)

   def Move(self, *args):
        """
        Move(TEXTE_PCB self, wxPoint aMoveVector)

        void TEXTE_PCB::Move(const
        wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.TEXTE_PCB_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(TEXTE_PCB self, wxPoint aRotCentre, double aAngle)

        void
        TEXTE_PCB::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.TEXTE_PCB_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(TEXTE_PCB self, wxPoint aCentre)

        void TEXTE_PCB::Flip(const
        wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.TEXTE_PCB_Flip(self, *args)

   def Copy(self, *args):
        """
        Copy(TEXTE_PCB self, TEXTE_PCB source)

        void
        TEXTE_PCB::Copy(TEXTE_PCB *source)
        """
        return _pcbnew.TEXTE_PCB_Copy(self, *args)

   def Draw(self, *args):
        """
        Draw(TEXTE_PCB self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(TEXTE_PCB self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void EDA_TEXT::Draw(EDA_RECT
        *aClipBox, wxDC *aDC, const wxPoint &aOffset, EDA_COLOR_T aColor,
        GR_DRAWMODE aDrawMode, EDA_DRAW_MODE_T aDisplay_mode=LINE, EDA_COLOR_T
        aAnchor_color=UNSPECIFIED_COLOR)

        Function Draw.

        Parameters:
        -----------

        aClipBox:  = the clipping rect, or NULL if no clipping

        aDC:  = the current Device Context

        aOffset:  = draw offset (usually (0,0))

        aColor:  = text color

        aDrawMode:  = GR_OR, GR_XOR.., -1 to use the current mode.

        aDisplay_mode:  = LINE, FILLED or SKETCH

        aAnchor_color:  = anchor color ( UNSPECIFIED = do not draw anchor ).

        """
        return _pcbnew.TEXTE_PCB_Draw(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(TEXTE_PCB self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        TEXTE_PCB::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.TEXTE_PCB_GetMsgPanelInfo(self, *args)

   def HitTest(self, *args):
        """
        HitTest(TEXTE_PCB self, wxPoint aPosition) -> bool
        HitTest(TEXTE_PCB self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(TEXTE_PCB self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(TEXTE_PCB self, EDA_RECT aRect) -> bool

        bool
        TEXTE_PCB::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.TEXTE_PCB_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(TEXTE_PCB self) -> wxString

        wxString
        TEXTE_PCB::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.TEXTE_PCB_GetClass(self)

   def TransformBoundingBoxWithClearanceToPolygon(self, *args):
        """
        TransformBoundingBoxWithClearanceToPolygon(TEXTE_PCB self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue)

        void
        TEXTE_PCB::TransformBoundingBoxWithClearanceToPolygon(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue) const

        Function TransformBoundingBoxWithClearanceToPolygon Convert the text
        bounding box to a rectangular polygon depending on the text
        orientation, the bounding box is not always horizontal or vertical
        Used in filling zones calculations Circles and arcs are approximated
        by segments.

        Function TransformBoundingBoxWithClearanceToPolygon Convert the text
        bounding box to a rectangular polygon Used in filling zones
        calculations Circles and arcs are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the text bounding box to the
        real clearance value (usually near from 1.0)

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the text bounding box
        """
        return _pcbnew.TEXTE_PCB_TransformBoundingBoxWithClearanceToPolygon(self, *args)

   def TransformShapeWithClearanceToPolygonSet(self, *args):
        """
        TransformShapeWithClearanceToPolygonSet(TEXTE_PCB self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount, double aCorrectionFactor)

        void
        TEXTE_PCB::TransformShapeWithClearanceToPolygonSet(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount,
        double aCorrectionFactor) const

        Function TransformShapeWithClearanceToPolygonSet Convert the text
        shape to a set of polygons (one by segment) Used in 3D viewer Circles
        and arcs are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the text

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approximated by segment bigger or
        equal to the real clearance value (usually near from 1.0)
        """
        return _pcbnew.TEXTE_PCB_TransformShapeWithClearanceToPolygonSet(self, *args)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(TEXTE_PCB self) -> wxString

        wxString
        TEXTE_PCB::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.TEXTE_PCB_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(TEXTE_PCB self) -> BITMAP_DEF

        BITMAP_DEF
        TEXTE_PCB::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.TEXTE_PCB_GetMenuImage(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(TEXTE_PCB self) -> EDA_RECT

        const EDA_RECT
        TEXTE_PCB::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.TEXTE_PCB_GetBoundingBox(self)

   def Clone(self):
        """
        Clone(TEXTE_PCB self) -> EDA_ITEM

        EDA_ITEM *
        TEXTE_PCB::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.TEXTE_PCB_Clone(self)

TEXTE_PCB_swigregister = _pcbnew.TEXTE_PCB_swigregister
TEXTE_PCB_swigregister(TEXTE_PCB)

class DIMENSION(BOARD_ITEM):
    """
    Class DIMENSION.

    For better understanding of the points that make a dimension:
    m_featureLineGO  m_featureLineDO        | |        |
    |        | |        |  m_arrowG2F      m_arrowD2F  |        | / \\ |
    m_crossBarO|/____________________________|m_crossBarF |\\ m_Text /|
    | \\ / | | m_arrowG1F m_arrowD1F | | | m_featureLineGF
    m_featureLineDF

    C++ includes: class_dimension.h
    """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DIMENSION, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DIMENSION, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_crossBarO"] = _pcbnew.DIMENSION_m_crossBarO_set
    __swig_getmethods__["m_crossBarO"] = _pcbnew.DIMENSION_m_crossBarO_get
    if _newclass:m_crossBarO = _swig_property(_pcbnew.DIMENSION_m_crossBarO_get, _pcbnew.DIMENSION_m_crossBarO_set)
    __swig_setmethods__["m_crossBarF"] = _pcbnew.DIMENSION_m_crossBarF_set
    __swig_getmethods__["m_crossBarF"] = _pcbnew.DIMENSION_m_crossBarF_get
    if _newclass:m_crossBarF = _swig_property(_pcbnew.DIMENSION_m_crossBarF_get, _pcbnew.DIMENSION_m_crossBarF_set)
    __swig_setmethods__["m_featureLineGO"] = _pcbnew.DIMENSION_m_featureLineGO_set
    __swig_getmethods__["m_featureLineGO"] = _pcbnew.DIMENSION_m_featureLineGO_get
    if _newclass:m_featureLineGO = _swig_property(_pcbnew.DIMENSION_m_featureLineGO_get, _pcbnew.DIMENSION_m_featureLineGO_set)
    __swig_setmethods__["m_featureLineGF"] = _pcbnew.DIMENSION_m_featureLineGF_set
    __swig_getmethods__["m_featureLineGF"] = _pcbnew.DIMENSION_m_featureLineGF_get
    if _newclass:m_featureLineGF = _swig_property(_pcbnew.DIMENSION_m_featureLineGF_get, _pcbnew.DIMENSION_m_featureLineGF_set)
    __swig_setmethods__["m_featureLineDO"] = _pcbnew.DIMENSION_m_featureLineDO_set
    __swig_getmethods__["m_featureLineDO"] = _pcbnew.DIMENSION_m_featureLineDO_get
    if _newclass:m_featureLineDO = _swig_property(_pcbnew.DIMENSION_m_featureLineDO_get, _pcbnew.DIMENSION_m_featureLineDO_set)
    __swig_setmethods__["m_featureLineDF"] = _pcbnew.DIMENSION_m_featureLineDF_set
    __swig_getmethods__["m_featureLineDF"] = _pcbnew.DIMENSION_m_featureLineDF_get
    if _newclass:m_featureLineDF = _swig_property(_pcbnew.DIMENSION_m_featureLineDF_get, _pcbnew.DIMENSION_m_featureLineDF_set)
    __swig_setmethods__["m_arrowD1F"] = _pcbnew.DIMENSION_m_arrowD1F_set
    __swig_getmethods__["m_arrowD1F"] = _pcbnew.DIMENSION_m_arrowD1F_get
    if _newclass:m_arrowD1F = _swig_property(_pcbnew.DIMENSION_m_arrowD1F_get, _pcbnew.DIMENSION_m_arrowD1F_set)
    __swig_setmethods__["m_arrowD2F"] = _pcbnew.DIMENSION_m_arrowD2F_set
    __swig_getmethods__["m_arrowD2F"] = _pcbnew.DIMENSION_m_arrowD2F_get
    if _newclass:m_arrowD2F = _swig_property(_pcbnew.DIMENSION_m_arrowD2F_get, _pcbnew.DIMENSION_m_arrowD2F_set)
    __swig_setmethods__["m_arrowG1F"] = _pcbnew.DIMENSION_m_arrowG1F_set
    __swig_getmethods__["m_arrowG1F"] = _pcbnew.DIMENSION_m_arrowG1F_get
    if _newclass:m_arrowG1F = _swig_property(_pcbnew.DIMENSION_m_arrowG1F_get, _pcbnew.DIMENSION_m_arrowG1F_set)
    __swig_setmethods__["m_arrowG2F"] = _pcbnew.DIMENSION_m_arrowG2F_set
    __swig_getmethods__["m_arrowG2F"] = _pcbnew.DIMENSION_m_arrowG2F_get
    if _newclass:m_arrowG2F = _swig_property(_pcbnew.DIMENSION_m_arrowG2F_get, _pcbnew.DIMENSION_m_arrowG2F_set)
   def __init__(self, *args):
        """
        __init__(DIMENSION self, BOARD_ITEM aParent) -> DIMENSION

        DIMENSION::DIMENSION(BOARD_ITEM *aParent)
        """
        this = _pcbnew.new_DIMENSION(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_DIMENSION
    __del__ = lambda self : None;
   def SetValue(self, *args):
        """
        SetValue(DIMENSION self, int aValue)

        void
        DIMENSION::SetValue(int aValue)
        """
        return _pcbnew.DIMENSION_SetValue(self, *args)

   def GetValue(self):
        """
        GetValue(DIMENSION self) -> int

        int DIMENSION::GetValue()
        const
        """
        return _pcbnew.DIMENSION_GetValue(self)

   def GetPosition(self):
        """
        GetPosition(DIMENSION self) -> wxPoint

        const wxPoint &
        DIMENSION::GetPosition() const
        """
        return _pcbnew.DIMENSION_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(DIMENSION self, wxPoint aPos)

        void
        DIMENSION::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.DIMENSION_SetPosition(self, *args)

   def SetTextSize(self, *args):
        """
        SetTextSize(DIMENSION self, wxSize aTextSize)

        void
        DIMENSION::SetTextSize(const wxSize &aTextSize)
        """
        return _pcbnew.DIMENSION_SetTextSize(self, *args)

   def SetLayer(self, *args):
        """
        SetLayer(DIMENSION self, LAYER_ID aLayer)

        void
        DIMENSION::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.DIMENSION_SetLayer(self, *args)

   def SetShape(self, *args):
        """
        SetShape(DIMENSION self, int aShape)

        void
        DIMENSION::SetShape(int aShape)
        """
        return _pcbnew.DIMENSION_SetShape(self, *args)

   def GetShape(self):
        """
        GetShape(DIMENSION self) -> int

        int DIMENSION::GetShape()
        const
        """
        return _pcbnew.DIMENSION_GetShape(self)

   def GetWidth(self):
        """
        GetWidth(DIMENSION self) -> int

        int DIMENSION::GetWidth()
        const
        """
        return _pcbnew.DIMENSION_GetWidth(self)

   def SetWidth(self, *args):
        """
        SetWidth(DIMENSION self, int aWidth)

        void
        DIMENSION::SetWidth(int aWidth)
        """
        return _pcbnew.DIMENSION_SetWidth(self, *args)

   def SetOrigin(self, *args):
        """
        SetOrigin(DIMENSION self, wxPoint aOrigin)

        void
        DIMENSION::SetOrigin(const wxPoint &aOrigin)

        Function SetOrigin Sets a new origin of the crossbar line.

        All remaining lines are adjusted after that.

        Parameters:
        -----------

        aOrigin:  is the new point to be used as the new origin of the
        crossbar line.
        """
        return _pcbnew.DIMENSION_SetOrigin(self, *args)

   def GetOrigin(self):
        """
        GetOrigin(DIMENSION self) -> wxPoint

        const wxPoint&
        DIMENSION::GetOrigin() const

        Function GetOrigin.

        Origin of the crossbar line.
        """
        return _pcbnew.DIMENSION_GetOrigin(self)

   def SetEnd(self, *args):
        """
        SetEnd(DIMENSION self, wxPoint aEnd)

        void
        DIMENSION::SetEnd(const wxPoint &aEnd)

        Function SetEnd Sets a new end of the crossbar line.

        All remaining lines are adjusted after that.

        Parameters:
        -----------

        aEnd:  is the new point to be used as the new end of the crossbar
        line.
        """
        return _pcbnew.DIMENSION_SetEnd(self, *args)

   def GetEnd(self):
        """
        GetEnd(DIMENSION self) -> wxPoint

        const wxPoint&
        DIMENSION::GetEnd()

        Function GetEnd.

        End of the crossbar line.
        """
        return _pcbnew.DIMENSION_GetEnd(self)

   def SetHeight(self, *args):
        """
        SetHeight(DIMENSION self, int aHeight)

        void
        DIMENSION::SetHeight(int aHeight)

        Function SetHeight Sets the length of feature lines.

        Parameters:
        -----------

        aHeight:  is the new height.
        """
        return _pcbnew.DIMENSION_SetHeight(self, *args)

   def GetHeight(self):
        """
        GetHeight(DIMENSION self) -> int

        int
        DIMENSION::GetHeight() const

        Function GetHeight Returns the length of feature lines.
        """
        return _pcbnew.DIMENSION_GetHeight(self)

   def UpdateHeight(self):
        """
        UpdateHeight(DIMENSION self)

        void
        DIMENSION::UpdateHeight()

        Function UpdateHeight Updates stored height basing on points
        coordinates.
        """
        return _pcbnew.DIMENSION_UpdateHeight(self)

   def GetAngle(self):
        """
        GetAngle(DIMENSION self) -> double

        double
        DIMENSION::GetAngle() const

        Function GetAngle Returns angle of the crossbar.

        Angle of the crossbar line expressed in radians.
        """
        return _pcbnew.DIMENSION_GetAngle(self)

   def AdjustDimensionDetails(self, aDoNotChangeText=False):
        """
        AdjustDimensionDetails(DIMENSION self, bool aDoNotChangeText=False)
        AdjustDimensionDetails(DIMENSION self)

        void
        DIMENSION::AdjustDimensionDetails(bool aDoNotChangeText=false)

        Function AdjustDimensionDetails Calculate coordinates of segments used
        to draw the dimension.

        Parameters:
        -----------

        aDoNotChangeText:  (bool) if false, the dimension text is initialized

        """
        return _pcbnew.DIMENSION_AdjustDimensionDetails(self, aDoNotChangeText)

   def SetText(self, *args):
        """
        SetText(DIMENSION self, wxString const & NewText)

        void
        DIMENSION::SetText(const wxString &NewText)
        """
        return _pcbnew.DIMENSION_SetText(self, *args)

   def GetText(self):
        """
        GetText(DIMENSION self) -> wxString const

        const wxString
        DIMENSION::GetText() const
        """
        return _pcbnew.DIMENSION_GetText(self)

   def Text(self, *args):
        """
        Text(DIMENSION self) -> TEXTE_PCB
        Text(DIMENSION self) -> TEXTE_PCB

        TEXTE_PCB& DIMENSION::Text()
        const
        """
        return _pcbnew.DIMENSION_Text(self, *args)

   def Copy(self, *args):
        """
        Copy(DIMENSION self, DIMENSION source)

        void
        DIMENSION::Copy(DIMENSION *source)
        """
        return _pcbnew.DIMENSION_Copy(self, *args)

   def Draw(self, *args):
        """
        Draw(DIMENSION self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aColorMode, wxPoint offset=)
        Draw(DIMENSION self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aColorMode)

        void
        DIMENSION::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aColorMode, const wxPoint &offset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.DIMENSION_Draw(self, *args)

   def Move(self, *args):
        """
        Move(DIMENSION self, wxPoint offset)

        void DIMENSION::Move(const
        wxPoint &offset)

        Function Move.

        Parameters:
        -----------

        offset:  : moving vector
        """
        return _pcbnew.DIMENSION_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(DIMENSION self, wxPoint aRotCentre, double aAngle)

        void
        DIMENSION::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.DIMENSION_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(DIMENSION self, wxPoint aCentre)

        void DIMENSION::Flip(const
        wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.DIMENSION_Flip(self, *args)

   def Mirror(self, *args):
        """
        Mirror(DIMENSION self, wxPoint axis_pos)

        void
        DIMENSION::Mirror(const wxPoint &axis_pos)

        Function Mirror Mirror the Dimension , relative to a given horizontal
        axis the text is not mirrored.

        only its position (and angle) is mirrored the layer is not changed

        Parameters:
        -----------

        axis_pos:  : vertical axis position
        """
        return _pcbnew.DIMENSION_Mirror(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(DIMENSION self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        DIMENSION::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.DIMENSION_GetMsgPanelInfo(self, *args)

   def HitTest(self, *args):
        """
        HitTest(DIMENSION self, wxPoint aPosition) -> bool
        HitTest(DIMENSION self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(DIMENSION self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(DIMENSION self, EDA_RECT aRect) -> bool

        bool
        DIMENSION::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.DIMENSION_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(DIMENSION self) -> wxString

        wxString
        DIMENSION::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.DIMENSION_GetClass(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(DIMENSION self) -> EDA_RECT

        const EDA_RECT
        DIMENSION::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.DIMENSION_GetBoundingBox(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(DIMENSION self) -> wxString

        wxString
        DIMENSION::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.DIMENSION_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(DIMENSION self) -> BITMAP_DEF

        BITMAP_DEF
        DIMENSION::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.DIMENSION_GetMenuImage(self)

   def Clone(self):
        """
        Clone(DIMENSION self) -> EDA_ITEM

        EDA_ITEM *
        DIMENSION::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.DIMENSION_Clone(self)

   def ViewBBox(self):
        """
        ViewBBox(DIMENSION self) -> BOX2I const

        const BOX2I
        DIMENSION::ViewBBox() const
        """
        return _pcbnew.DIMENSION_ViewBBox(self)

DIMENSION_swigregister = _pcbnew.DIMENSION_swigregister
DIMENSION_swigregister(DIMENSION)

class DRAWSEGMENT(BOARD_ITEM):
    """
    C++ includes: class_drawsegment.h

    """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DRAWSEGMENT, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DRAWSEGMENT, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(DRAWSEGMENT self, BOARD_ITEM aParent=None, KICAD_T idtype=PCB_LINE_T) -> DRAWSEGMENT
        __init__(DRAWSEGMENT self, BOARD_ITEM aParent=None) -> DRAWSEGMENT
        __init__(DRAWSEGMENT self) -> DRAWSEGMENT

        DRAWSEGMENT::DRAWSEGMENT(BOARD_ITEM *aParent=NULL, KICAD_T
        idtype=PCB_LINE_T)
        """
        this = _pcbnew.new_DRAWSEGMENT(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_DRAWSEGMENT
    __del__ = lambda self : None;
   def SetWidth(self, *args):
        """
        SetWidth(DRAWSEGMENT self, int aWidth)

        void
        DRAWSEGMENT::SetWidth(int aWidth)
        """
        return _pcbnew.DRAWSEGMENT_SetWidth(self, *args)

   def GetWidth(self):
        """
        GetWidth(DRAWSEGMENT self) -> int

        int
        DRAWSEGMENT::GetWidth() const
        """
        return _pcbnew.DRAWSEGMENT_GetWidth(self)

   def SetAngle(self, *args):
        """
        SetAngle(DRAWSEGMENT self, double aAngle)

        void
        DRAWSEGMENT::SetAngle(double aAngle)

        Function SetAngle sets the angle for arcs, and normalizes it within
        the range 0 - 360 degrees.

        Parameters:
        -----------

        aAngle:  is tenths of degrees, but will soon be degrees.
        """
        return _pcbnew.DRAWSEGMENT_SetAngle(self, *args)

   def GetAngle(self):
        """
        GetAngle(DRAWSEGMENT self) -> double

        double
        DRAWSEGMENT::GetAngle() const
        """
        return _pcbnew.DRAWSEGMENT_GetAngle(self)

   def SetType(self, *args):
        """
        SetType(DRAWSEGMENT self, int aType)

        void
        DRAWSEGMENT::SetType(int aType)
        """
        return _pcbnew.DRAWSEGMENT_SetType(self, *args)

   def GetType(self):
        """
        GetType(DRAWSEGMENT self) -> int

        int
        DRAWSEGMENT::GetType() const
        """
        return _pcbnew.DRAWSEGMENT_GetType(self)

   def SetShape(self, *args):
        """
        SetShape(DRAWSEGMENT self, STROKE_T aShape)

        void
        DRAWSEGMENT::SetShape(STROKE_T aShape)
        """
        return _pcbnew.DRAWSEGMENT_SetShape(self, *args)

   def GetShape(self):
        """
        GetShape(DRAWSEGMENT self) -> STROKE_T

        STROKE_T
        DRAWSEGMENT::GetShape() const
        """
        return _pcbnew.DRAWSEGMENT_GetShape(self)

   def SetBezControl1(self, *args):
        """
        SetBezControl1(DRAWSEGMENT self, wxPoint aPoint)

        void
        DRAWSEGMENT::SetBezControl1(const wxPoint &aPoint)
        """
        return _pcbnew.DRAWSEGMENT_SetBezControl1(self, *args)

   def GetBezControl1(self):
        """
        GetBezControl1(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetBezControl1() const
        """
        return _pcbnew.DRAWSEGMENT_GetBezControl1(self)

   def SetBezControl2(self, *args):
        """
        SetBezControl2(DRAWSEGMENT self, wxPoint aPoint)

        void
        DRAWSEGMENT::SetBezControl2(const wxPoint &aPoint)
        """
        return _pcbnew.DRAWSEGMENT_SetBezControl2(self, *args)

   def GetBezControl2(self):
        """
        GetBezControl2(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetBezControl2() const
        """
        return _pcbnew.DRAWSEGMENT_GetBezControl2(self)

   def SetPosition(self, *args):
        """
        SetPosition(DRAWSEGMENT self, wxPoint aPos)

        void
        DRAWSEGMENT::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.DRAWSEGMENT_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetPosition() const
        """
        return _pcbnew.DRAWSEGMENT_GetPosition(self)

   def GetStart(self):
        """
        GetStart(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetStart() const

        Function GetStart returns the starting point of the graphic.
        """
        return _pcbnew.DRAWSEGMENT_GetStart(self)

   def SetStart(self, *args):
        """
        SetStart(DRAWSEGMENT self, wxPoint aStart)

        void
        DRAWSEGMENT::SetStart(const wxPoint &aStart)
        """
        return _pcbnew.DRAWSEGMENT_SetStart(self, *args)

   def SetStartY(self, *args):
        """
        SetStartY(DRAWSEGMENT self, int y)

        void
        DRAWSEGMENT::SetStartY(int y)
        """
        return _pcbnew.DRAWSEGMENT_SetStartY(self, *args)

   def SetStartX(self, *args):
        """
        SetStartX(DRAWSEGMENT self, int x)

        void
        DRAWSEGMENT::SetStartX(int x)
        """
        return _pcbnew.DRAWSEGMENT_SetStartX(self, *args)

   def GetEnd(self):
        """
        GetEnd(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetEnd() const

        Function GetEnd returns the ending point of the graphic.
        """
        return _pcbnew.DRAWSEGMENT_GetEnd(self)

   def SetEnd(self, *args):
        """
        SetEnd(DRAWSEGMENT self, wxPoint aEnd)

        void
        DRAWSEGMENT::SetEnd(const wxPoint &aEnd)
        """
        return _pcbnew.DRAWSEGMENT_SetEnd(self, *args)

   def SetEndY(self, *args):
        """
        SetEndY(DRAWSEGMENT self, int y)

        void
        DRAWSEGMENT::SetEndY(int y)
        """
        return _pcbnew.DRAWSEGMENT_SetEndY(self, *args)

   def SetEndX(self, *args):
        """
        SetEndX(DRAWSEGMENT self, int x)

        void
        DRAWSEGMENT::SetEndX(int x)
        """
        return _pcbnew.DRAWSEGMENT_SetEndX(self, *args)

   def GetCenter(self):
        """
        GetCenter(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetCenter() const
        """
        return _pcbnew.DRAWSEGMENT_GetCenter(self)

   def GetArcStart(self):
        """
        GetArcStart(DRAWSEGMENT self) -> wxPoint

        const wxPoint&
        DRAWSEGMENT::GetArcStart() const
        """
        return _pcbnew.DRAWSEGMENT_GetArcStart(self)

   def GetArcEnd(self):
        """
        GetArcEnd(DRAWSEGMENT self) -> wxPoint

        const wxPoint
        DRAWSEGMENT::GetArcEnd() const
        """
        return _pcbnew.DRAWSEGMENT_GetArcEnd(self)

   def GetArcAngleStart(self):
        """
        GetArcAngleStart(DRAWSEGMENT self) -> double

        double
        DRAWSEGMENT::GetArcAngleStart() const

        function GetArcAngleStart()

        the angle of the starting point of this arc, between 0 and 3600 in 0.1
        deg
        """
        return _pcbnew.DRAWSEGMENT_GetArcAngleStart(self)

   def GetRadius(self):
        """
        GetRadius(DRAWSEGMENT self) -> int

        int
        DRAWSEGMENT::GetRadius() const

        Function GetRadius returns the radius of this item Has meaning only
        for arc and circle.
        """
        return _pcbnew.DRAWSEGMENT_GetRadius(self)

   def SetArcStart(self, *args):
        """
        SetArcStart(DRAWSEGMENT self, wxPoint aArcStartPoint)

        void
        DRAWSEGMENT::SetArcStart(const wxPoint &aArcStartPoint)

        Initialize the start arc point.

        can be used for circles to initialize one point of the cicumference
        """
        return _pcbnew.DRAWSEGMENT_SetArcStart(self, *args)

   def SetCenter(self, *args):
        """
        SetCenter(DRAWSEGMENT self, wxPoint aCenterPoint)

        void
        DRAWSEGMENT::SetCenter(const wxPoint &aCenterPoint)

        For arcs and circles:
        """
        return _pcbnew.DRAWSEGMENT_SetCenter(self, *args)

   def GetParentModule(self):
        """
        GetParentModule(DRAWSEGMENT self) -> MODULE

        MODULE *
        DRAWSEGMENT::GetParentModule() const

        Function GetParentModule returns a pointer to the parent module, or
        NULL if DRAWSEGMENT does not belong to a module.

        MODULE* - pointer to the parent module or NULL.
        """
        return _pcbnew.DRAWSEGMENT_GetParentModule(self)

   def GetBezierPoints(self):
        """
        GetBezierPoints(DRAWSEGMENT self) -> std::vector< wxPoint,std::allocator< wxPoint > > const &

        const
        std::vector<wxPoint>& DRAWSEGMENT::GetBezierPoints() const
        """
        return _pcbnew.DRAWSEGMENT_GetBezierPoints(self)

   def GetPolyPoints(self):
        """
        GetPolyPoints(DRAWSEGMENT self) -> std::vector< wxPoint,std::allocator< wxPoint > > const &

        const
        std::vector<wxPoint>& DRAWSEGMENT::GetPolyPoints() const
        """
        return _pcbnew.DRAWSEGMENT_GetPolyPoints(self)

   def SetBezierPoints(self, *args):
        """
        SetBezierPoints(DRAWSEGMENT self, std::vector< wxPoint,std::allocator< wxPoint > > const & aPoints)

        void
        DRAWSEGMENT::SetBezierPoints(const std::vector< wxPoint > &aPoints)
        """
        return _pcbnew.DRAWSEGMENT_SetBezierPoints(self, *args)

   def SetPolyPoints(self, *args):
        """
        SetPolyPoints(DRAWSEGMENT self, std::vector< wxPoint,std::allocator< wxPoint > > const & aPoints)

        void
        DRAWSEGMENT::SetPolyPoints(const std::vector< wxPoint > &aPoints)
        """
        return _pcbnew.DRAWSEGMENT_SetPolyPoints(self, *args)

   def Copy(self, *args):
        """
        Copy(DRAWSEGMENT self, DRAWSEGMENT source)

        void
        DRAWSEGMENT::Copy(DRAWSEGMENT *source)
        """
        return _pcbnew.DRAWSEGMENT_Copy(self, *args)

   def Draw(self, *args):
        """
        Draw(DRAWSEGMENT self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(DRAWSEGMENT self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        DRAWSEGMENT::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.DRAWSEGMENT_Draw(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(DRAWSEGMENT self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        DRAWSEGMENT::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.DRAWSEGMENT_GetMsgPanelInfo(self, *args)

   def GetBoundingBox(self):
        """
        GetBoundingBox(DRAWSEGMENT self) -> EDA_RECT

        const EDA_RECT
        DRAWSEGMENT::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.DRAWSEGMENT_GetBoundingBox(self)

   def HitTest(self, *args):
        """
        HitTest(DRAWSEGMENT self, wxPoint aPosition) -> bool
        HitTest(DRAWSEGMENT self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(DRAWSEGMENT self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(DRAWSEGMENT self, EDA_RECT aRect) -> bool

        bool
        DRAWSEGMENT::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.DRAWSEGMENT_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(DRAWSEGMENT self) -> wxString

        wxString
        DRAWSEGMENT::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.DRAWSEGMENT_GetClass(self)

   def GetLength(self):
        """
        GetLength(DRAWSEGMENT self) -> double

        double
        DRAWSEGMENT::GetLength() const

        Function GetLength returns the length of the track using the
        hypotenuse calculation.

        double - the length of the track
        """
        return _pcbnew.DRAWSEGMENT_GetLength(self)

   def Move(self, *args):
        """
        Move(DRAWSEGMENT self, wxPoint aMoveVector)

        virtual void
        DRAWSEGMENT::Move(const wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.DRAWSEGMENT_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(DRAWSEGMENT self, wxPoint aRotCentre, double aAngle)

        void
        DRAWSEGMENT::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.DRAWSEGMENT_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(DRAWSEGMENT self, wxPoint aCentre)

        void
        DRAWSEGMENT::Flip(const wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.DRAWSEGMENT_Flip(self, *args)

   def TransformShapeWithClearanceToPolygon(self, *args):
        """
        TransformShapeWithClearanceToPolygon(DRAWSEGMENT self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount, double aCorrectionFactor)

        void
        DRAWSEGMENT::TransformShapeWithClearanceToPolygon(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount,
        double aCorrectionFactor) const

        Function TransformShapeWithClearanceToPolygon Convert the track shape
        to a closed polygon Used in filling zones calculations Circles and
        arcs are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the pad

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approximated by segment bigger or
        equal to the real clearance value (usually near from 1.0)

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the pad

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approxiamted by segment bigger or
        equal to the real clearance value (usually near from 1.0)
        """
        return _pcbnew.DRAWSEGMENT_TransformShapeWithClearanceToPolygon(self, *args)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(DRAWSEGMENT self) -> wxString

        wxString
        DRAWSEGMENT::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.DRAWSEGMENT_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(DRAWSEGMENT self) -> BITMAP_DEF

        virtual BITMAP_DEF
        DRAWSEGMENT::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.DRAWSEGMENT_GetMenuImage(self)

   def Clone(self):
        """
        Clone(DRAWSEGMENT self) -> EDA_ITEM

        EDA_ITEM *
        DRAWSEGMENT::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.DRAWSEGMENT_Clone(self)

   def GetShapeStr(self):
        return self.ShowShape(self.GetShape())

DRAWSEGMENT_swigregister = _pcbnew.DRAWSEGMENT_swigregister
DRAWSEGMENT_swigregister(DRAWSEGMENT)

class MARKER_PCB(BOARD_ITEM,MARKER_BASE):
    """C++ includes: class_marker_pcb.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM,MARKER_BASE]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MARKER_PCB, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM,MARKER_BASE]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MARKER_PCB, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(MARKER_PCB self, BOARD_ITEM aParent) -> MARKER_PCB
        __init__(MARKER_PCB self, int aErrorCode, wxPoint aMarkerPos, wxString const & aText, wxPoint aPos, wxString const & bText,
            wxPoint bPos) -> MARKER_PCB
        __init__(MARKER_PCB self, int aErrorCode, wxPoint aMarkerPos, wxString const & aText, wxPoint aPos) -> MARKER_PCB

        MARKER_PCB::MARKER_PCB(int aErrorCode, const wxPoint &aMarkerPos,
        const wxString &aText, const wxPoint &aPos)

        Constructor.

        Parameters:
        -----------

        aErrorCode:  The categorizing identifier for an error

        aMarkerPos:  The position of the MARKER_PCB on the BOARD

        aText:  Text describing the object

        aPos:  The position of the object
        """
        this = _pcbnew.new_MARKER_PCB(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_MARKER_PCB
    __del__ = lambda self : None;
   def Move(self, *args):
        """
        Move(MARKER_PCB self, wxPoint aMoveVector)

        void MARKER_PCB::Move(const
        wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.MARKER_PCB_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(MARKER_PCB self, wxPoint aRotCentre, double aAngle)

        void
        MARKER_PCB::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.MARKER_PCB_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(MARKER_PCB self, wxPoint aCentre)

        void MARKER_PCB::Flip(const
        wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.MARKER_PCB_Flip(self, *args)

   def Draw(self, *args):
        """
        Draw(MARKER_PCB self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(MARKER_PCB self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void
        MARKER_PCB::Draw(EDA_DRAW_PANEL *aPanel, wxDC *aDC, GR_DRAWMODE
        aDrawMode, const wxPoint &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.MARKER_PCB_Draw(self, *args)

   def GetPosition(self):
        """
        GetPosition(MARKER_PCB self) -> wxPoint

        const wxPoint&
        MARKER_PCB::GetPosition() const
        """
        return _pcbnew.MARKER_PCB_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(MARKER_PCB self, wxPoint aPos)

        void
        MARKER_PCB::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.MARKER_PCB_SetPosition(self, *args)

   def SetItem(self, *args):
        """
        SetItem(MARKER_PCB self, BOARD_ITEM aItem)

        void
        MARKER_PCB::SetItem(const BOARD_ITEM *aItem)
        """
        return _pcbnew.MARKER_PCB_SetItem(self, *args)

   def GetItem(self):
        """
        GetItem(MARKER_PCB self) -> BOARD_ITEM

        const BOARD_ITEM*
        MARKER_PCB::GetItem() const
        """
        return _pcbnew.MARKER_PCB_GetItem(self)

   def HitTest(self, *args):
        """
        HitTest(MARKER_PCB self, wxPoint aPosition) -> bool

        virtual bool
        BOARD_ITEM::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Function HitTest tests if the aRect intersects or contains this object
        (depending on aContained).

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.MARKER_PCB_HitTest(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(MARKER_PCB self, LAYER_ID aLayer) -> bool

        bool
        MARKER_PCB::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.MARKER_PCB_IsOnLayer(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(MARKER_PCB self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        MARKER_PCB::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.MARKER_PCB_GetMsgPanelInfo(self, *args)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(MARKER_PCB self) -> wxString

        wxString
        MARKER_PCB::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.MARKER_PCB_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(MARKER_PCB self) -> BITMAP_DEF

        BITMAP_DEF
        MARKER_PCB::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.MARKER_PCB_GetMenuImage(self)

   def ViewBBox(self):
        """
        ViewBBox(MARKER_PCB self) -> BOX2I const

        virtual const BOX2I
        MARKER_PCB::ViewBBox() const

        >
        """
        return _pcbnew.MARKER_PCB_ViewBBox(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(MARKER_PCB self, int [] aLayers, int & aCount)

        void
        MARKER_PCB::ViewGetLayers(int aLayers[], int &aCount) const

        >
        """
        return _pcbnew.MARKER_PCB_ViewGetLayers(self, *args)

MARKER_PCB_swigregister = _pcbnew.MARKER_PCB_swigregister
MARKER_PCB_swigregister(MARKER_PCB)

class PCB_TARGET(BOARD_ITEM):
    """C++ includes: class_mire.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PCB_TARGET, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PCB_TARGET, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(PCB_TARGET self, BOARD_ITEM aParent) -> PCB_TARGET
        __init__(PCB_TARGET self, BOARD_ITEM aParent, int aShape, LAYER_ID aLayer, wxPoint aPos, int aSize, int aWidth) -> PCB_TARGET

        PCB_TARGET::PCB_TARGET(BOARD_ITEM *aParent, int aShape, LAYER_ID
        aLayer, const wxPoint &aPos, int aSize, int aWidth)
        """
        this = _pcbnew.new_PCB_TARGET(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PCB_TARGET
    __del__ = lambda self : None;
   def SetPosition(self, *args):
        """
        SetPosition(PCB_TARGET self, wxPoint aPos)

        void
        PCB_TARGET::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.PCB_TARGET_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(PCB_TARGET self) -> wxPoint

        const wxPoint&
        PCB_TARGET::GetPosition() const
        """
        return _pcbnew.PCB_TARGET_GetPosition(self)

   def SetShape(self, *args):
        """
        SetShape(PCB_TARGET self, int aShape)

        void
        PCB_TARGET::SetShape(int aShape)
        """
        return _pcbnew.PCB_TARGET_SetShape(self, *args)

   def GetShape(self):
        """
        GetShape(PCB_TARGET self) -> int

        int
        PCB_TARGET::GetShape() const
        """
        return _pcbnew.PCB_TARGET_GetShape(self)

   def SetSize(self, *args):
        """
        SetSize(PCB_TARGET self, int aSize)

        void
        PCB_TARGET::SetSize(int aSize)
        """
        return _pcbnew.PCB_TARGET_SetSize(self, *args)

   def GetSize(self):
        """
        GetSize(PCB_TARGET self) -> int

        int PCB_TARGET::GetSize()
        const
        """
        return _pcbnew.PCB_TARGET_GetSize(self)

   def SetWidth(self, *args):
        """
        SetWidth(PCB_TARGET self, int aWidth)

        void
        PCB_TARGET::SetWidth(int aWidth)
        """
        return _pcbnew.PCB_TARGET_SetWidth(self, *args)

   def GetWidth(self):
        """
        GetWidth(PCB_TARGET self) -> int

        int
        PCB_TARGET::GetWidth() const
        """
        return _pcbnew.PCB_TARGET_GetWidth(self)

   def Move(self, *args):
        """
        Move(PCB_TARGET self, wxPoint aMoveVector)

        void PCB_TARGET::Move(const
        wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.PCB_TARGET_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(PCB_TARGET self, wxPoint aRotCentre, double aAngle)

        void
        PCB_TARGET::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.PCB_TARGET_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(PCB_TARGET self, wxPoint aCentre)

        void PCB_TARGET::Flip(const
        wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.PCB_TARGET_Flip(self, *args)

   def Copy(self, *args):
        """
        Copy(PCB_TARGET self, PCB_TARGET source)

        void
        PCB_TARGET::Copy(PCB_TARGET *source)
        """
        return _pcbnew.PCB_TARGET_Copy(self, *args)

   def Draw(self, *args):
        """
        Draw(PCB_TARGET self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(PCB_TARGET self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        PCB_TARGET::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.PCB_TARGET_Draw(self, *args)

   def GetClass(self):
        """
        GetClass(PCB_TARGET self) -> wxString

        wxString
        PCB_TARGET::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.PCB_TARGET_GetClass(self)

   def HitTest(self, *args):
        """
        HitTest(PCB_TARGET self, wxPoint aPosition) -> bool
        HitTest(PCB_TARGET self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(PCB_TARGET self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(PCB_TARGET self, EDA_RECT aRect) -> bool

        bool
        PCB_TARGET::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.PCB_TARGET_HitTest(self, *args)

   def GetBoundingBox(self):
        """
        GetBoundingBox(PCB_TARGET self) -> EDA_RECT

        const EDA_RECT
        PCB_TARGET::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.PCB_TARGET_GetBoundingBox(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(PCB_TARGET self) -> wxString

        wxString
        PCB_TARGET::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.PCB_TARGET_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(PCB_TARGET self) -> BITMAP_DEF

        BITMAP_DEF
        PCB_TARGET::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.PCB_TARGET_GetMenuImage(self)

   def Clone(self):
        """
        Clone(PCB_TARGET self) -> EDA_ITEM

        EDA_ITEM *
        PCB_TARGET::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.PCB_TARGET_Clone(self)

PCB_TARGET_swigregister = _pcbnew.PCB_TARGET_swigregister
PCB_TARGET_swigregister(PCB_TARGET)

class TEXTE_MODULE(BOARD_ITEM,EDA_TEXT):
    """C++ includes: class_text_mod.h """
    __swig_setmethods__ = {}
    for _s in [BOARD_ITEM,EDA_TEXT]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TEXTE_MODULE, name, value)
    __swig_getmethods__ = {}
    for _s in [BOARD_ITEM,EDA_TEXT]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TEXTE_MODULE, name)
    __repr__ = _swig_repr
    TEXT_is_REFERENCE = _pcbnew.TEXTE_MODULE_TEXT_is_REFERENCE
    TEXT_is_VALUE = _pcbnew.TEXTE_MODULE_TEXT_is_VALUE
    TEXT_is_DIVERS = _pcbnew.TEXTE_MODULE_TEXT_is_DIVERS
   def __init__(self, *args):
        """
        __init__(TEXTE_MODULE self, MODULE parent, TEXTE_MODULE::TEXT_TYPE text_type=TEXT_is_DIVERS) -> TEXTE_MODULE
        __init__(TEXTE_MODULE self, MODULE parent) -> TEXTE_MODULE

        TEXTE_MODULE::TEXTE_MODULE(MODULE *parent, TEXT_TYPE
        text_type=TEXT_is_DIVERS)
        """
        this = _pcbnew.new_TEXTE_MODULE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_TEXTE_MODULE
    __del__ = lambda self : None;
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.TEXTE_MODULE_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
   def GetPosition(self):
        """
        GetPosition(TEXTE_MODULE self) -> wxPoint

        virtual const
        wxPoint& TEXTE_MODULE::GetPosition() const
        """
        return _pcbnew.TEXTE_MODULE_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(TEXTE_MODULE self, wxPoint aPos)

        virtual void
        TEXTE_MODULE::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.TEXTE_MODULE_SetPosition(self, *args)

   def Move(self, *args):
        """
        Move(TEXTE_MODULE self, wxPoint aMoveVector)

        void
        TEXTE_MODULE::Move(const wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.TEXTE_MODULE_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(TEXTE_MODULE self, wxPoint aRotCentre, double aAngle)

        void
        TEXTE_MODULE::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.TEXTE_MODULE_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(TEXTE_MODULE self, wxPoint aCentre)

        void
        TEXTE_MODULE::Flip(const wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.TEXTE_MODULE_Flip(self, *args)

   def RotateTransformWithModule(self, *args):
        """
        RotateTransformWithModule(TEXTE_MODULE self, wxPoint aOffset, double aAngle)

        void
        TEXTE_MODULE::RotateTransformWithModule(const wxPoint &aOffset, double
        aAngle)

        Rotate text during module rotation transform, in footprint editor.
        """
        return _pcbnew.TEXTE_MODULE_RotateTransformWithModule(self, *args)

   def FlipWithModule(self, *args):
        """
        FlipWithModule(TEXTE_MODULE self, int aOffset)

        void
        TEXTE_MODULE::FlipWithModule(int aOffset)

        Flip entity during module flip.
        """
        return _pcbnew.TEXTE_MODULE_FlipWithModule(self, *args)

   def MirrorTransformWithModule(self, *args):
        """
        MirrorTransformWithModule(TEXTE_MODULE self, int aOffset)

        void
        TEXTE_MODULE::MirrorTransformWithModule(int aOffset)

        Mirror text during module mirroring transform, in footprint editor the
        text itself is not mirrored, only position.
        """
        return _pcbnew.TEXTE_MODULE_MirrorTransformWithModule(self, *args)

   def MoveTransformWithModule(self, *args):
        """
        MoveTransformWithModule(TEXTE_MODULE self, wxPoint aMoveVector)

        void
        TEXTE_MODULE::MoveTransformWithModule(const wxPoint &aMoveVector)

        move text during module mirroring transform, in footprint editor
        """
        return _pcbnew.TEXTE_MODULE_MoveTransformWithModule(self, *args)

   def SetType(self, *args):
        """
        SetType(TEXTE_MODULE self, TEXTE_MODULE::TEXT_TYPE aType)

        void
        TEXTE_MODULE::SetType(TEXT_TYPE aType)

        Deprecated it seems (but the type is used to 'protect'
        """
        return _pcbnew.TEXTE_MODULE_SetType(self, *args)

   def GetType(self):
        """
        GetType(TEXTE_MODULE self) -> TEXTE_MODULE::TEXT_TYPE

        TEXT_TYPE
        TEXTE_MODULE::GetType() const
        """
        return _pcbnew.TEXTE_MODULE_GetType(self)

   def SetVisible(self, *args):
        """
        SetVisible(TEXTE_MODULE self, bool isVisible)

        void
        TEXTE_MODULE::SetVisible(bool isVisible)
        """
        return _pcbnew.TEXTE_MODULE_SetVisible(self, *args)

   def IsVisible(self):
        """
        IsVisible(TEXTE_MODULE self) -> bool

        bool
        TEXTE_MODULE::IsVisible() const
        """
        return _pcbnew.TEXTE_MODULE_IsVisible(self)

   def SetPos0(self, *args):
        """
        SetPos0(TEXTE_MODULE self, wxPoint aPos)

        void
        TEXTE_MODULE::SetPos0(const wxPoint &aPos)
        """
        return _pcbnew.TEXTE_MODULE_SetPos0(self, *args)

   def GetPos0(self):
        """
        GetPos0(TEXTE_MODULE self) -> wxPoint

        const wxPoint&
        TEXTE_MODULE::GetPos0() const
        """
        return _pcbnew.TEXTE_MODULE_GetPos0(self)

   def Copy(self, *args):
        """
        Copy(TEXTE_MODULE self, TEXTE_MODULE source)

        void
        TEXTE_MODULE::Copy(TEXTE_MODULE *source)
        """
        return _pcbnew.TEXTE_MODULE_Copy(self, *args)

   def GetLength(self):
        """
        GetLength(TEXTE_MODULE self) -> int

        int
        TEXTE_MODULE::GetLength() const
        """
        return _pcbnew.TEXTE_MODULE_GetLength(self)

   def GetDrawRotation(self):
        """
        GetDrawRotation(TEXTE_MODULE self) -> double

        double
        TEXTE_MODULE::GetDrawRotation() const

        the text rotation for drawings and plotting the footprint rotation is
        taken in account
        """
        return _pcbnew.TEXTE_MODULE_GetDrawRotation(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(TEXTE_MODULE self) -> EDA_RECT

        const EDA_RECT
        TEXTE_MODULE::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.TEXTE_MODULE_GetBoundingBox(self)

   def SetDrawCoord(self):
        """
        SetDrawCoord(TEXTE_MODULE self)

        void
        TEXTE_MODULE::SetDrawCoord()

        Set absolute coordinates.
        """
        return _pcbnew.TEXTE_MODULE_SetDrawCoord(self)

   def SetLocalCoord(self):
        """
        SetLocalCoord(TEXTE_MODULE self)

        void
        TEXTE_MODULE::SetLocalCoord()

        Set relative coordinates.
        """
        return _pcbnew.TEXTE_MODULE_SetLocalCoord(self)

   def Draw(self, *args):
        """
        Draw(TEXTE_MODULE self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(TEXTE_MODULE self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        EDA_TEXT::Draw(EDA_RECT *aClipBox, wxDC *aDC, const wxPoint &aOffset,
        EDA_COLOR_T aColor, GR_DRAWMODE aDrawMode, EDA_DRAW_MODE_T
        aDisplay_mode=LINE, EDA_COLOR_T aAnchor_color=UNSPECIFIED_COLOR)

        Function Draw.

        Parameters:
        -----------

        aClipBox:  = the clipping rect, or NULL if no clipping

        aDC:  = the current Device Context

        aOffset:  = draw offset (usually (0,0))

        aColor:  = text color

        aDrawMode:  = GR_OR, GR_XOR.., -1 to use the current mode.

        aDisplay_mode:  = LINE, FILLED or SKETCH

        aAnchor_color:  = anchor color ( UNSPECIFIED = do not draw anchor ).

        """
        return _pcbnew.TEXTE_MODULE_Draw(self, *args)

   def DrawUmbilical(self, *args):
        """
        DrawUmbilical(TEXTE_MODULE self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        DrawUmbilical(TEXTE_MODULE self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void
        TEXTE_MODULE::DrawUmbilical(EDA_DRAW_PANEL *aPanel, wxDC *aDC,
        GR_DRAWMODE aDrawMode, const wxPoint &aOffset=ZeroOffset)

        Function DrawUmbilical draws a line from the TEXTE_MODULE origin to
        parent MODULE origin.

        Parameters:
        -----------

        aPanel:  = the current DrawPanel

        aDC:  = the current device context

        aDrawMode:  = drawing mode, typically GR_XOR

        aOffset:  = offset for TEXTE_MODULE
        """
        return _pcbnew.TEXTE_MODULE_DrawUmbilical(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(TEXTE_MODULE self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        TEXTE_MODULE::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.TEXTE_MODULE_GetMsgPanelInfo(self, *args)

   def HitTest(self, *args):
        """
        HitTest(TEXTE_MODULE self, wxPoint aPosition) -> bool

        virtual bool
        BOARD_ITEM::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Function HitTest tests if the aRect intersects or contains this object
        (depending on aContained).

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.TEXTE_MODULE_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(TEXTE_MODULE self) -> wxString

        wxString
        TEXTE_MODULE::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.TEXTE_MODULE_GetClass(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(TEXTE_MODULE self) -> wxString

        wxString
        TEXTE_MODULE::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.TEXTE_MODULE_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(TEXTE_MODULE self) -> BITMAP_DEF

        BITMAP_DEF
        TEXTE_MODULE::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.TEXTE_MODULE_GetMenuImage(self)

   def Clone(self):
        """
        Clone(TEXTE_MODULE self) -> EDA_ITEM

        EDA_ITEM *
        TEXTE_MODULE::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.TEXTE_MODULE_Clone(self)

   def GetShownText(self):
        """
        GetShownText(TEXTE_MODULE self) -> wxString

        wxString
        TEXTE_MODULE::GetShownText() const

        Macro-expansion for text in library modules.
        """
        return _pcbnew.TEXTE_MODULE_GetShownText(self)

   def ViewBBox(self):
        """
        ViewBBox(TEXTE_MODULE self) -> BOX2I const

        const BOX2I
        TEXTE_MODULE::ViewBBox() const
        """
        return _pcbnew.TEXTE_MODULE_ViewBBox(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(TEXTE_MODULE self, int [] aLayers, int & aCount)

        void
        TEXTE_MODULE::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.TEXTE_MODULE_ViewGetLayers(self, *args)

TEXTE_MODULE_swigregister = _pcbnew.TEXTE_MODULE_swigregister
TEXTE_MODULE_swigregister(TEXTE_MODULE)

def TEXTE_MODULE_ClassOf(*args):
  """TEXTE_MODULE_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.TEXTE_MODULE_ClassOf(*args)

class EDGE_MODULE(DRAWSEGMENT):
    """C++ includes: class_edge_mod.h """
    __swig_setmethods__ = {}
    for _s in [DRAWSEGMENT]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EDGE_MODULE, name, value)
    __swig_getmethods__ = {}
    for _s in [DRAWSEGMENT]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, EDGE_MODULE, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(EDGE_MODULE self, MODULE parent, STROKE_T aShape=S_SEGMENT) -> EDGE_MODULE
        __init__(EDGE_MODULE self, MODULE parent) -> EDGE_MODULE

        EDGE_MODULE::EDGE_MODULE(MODULE *parent, STROKE_T aShape=S_SEGMENT)
        """
        this = _pcbnew.new_EDGE_MODULE(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_EDGE_MODULE
    __del__ = lambda self : None;
   def ClassOf(*args):
        """ClassOf(EDA_ITEM aItem) -> bool"""
        return _pcbnew.EDGE_MODULE_ClassOf(*args)

    if _newclass:ClassOf = staticmethod(ClassOf)
    __swig_getmethods__["ClassOf"] = lambda x: ClassOf
   def Copy(self, *args):
        """
        Copy(EDGE_MODULE self, EDGE_MODULE source)

        void
        DRAWSEGMENT::Copy(DRAWSEGMENT *source)
        """
        return _pcbnew.EDGE_MODULE_Copy(self, *args)

   def Move(self, *args):
        """
        Move(EDGE_MODULE self, wxPoint aMoveVector)

        void
        EDGE_MODULE::Move(const wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.EDGE_MODULE_Move(self, *args)

   def Flip(self, *args):
        """
        Flip(EDGE_MODULE self, wxPoint aCentre)

        void
        EDGE_MODULE::Flip(const wxPoint &aCentre)

        Flip entity relative to aCentre.
        """
        return _pcbnew.EDGE_MODULE_Flip(self, *args)

   def SetStart0(self, *args):
        """
        SetStart0(EDGE_MODULE self, wxPoint aPoint)

        void
        EDGE_MODULE::SetStart0(const wxPoint &aPoint)
        """
        return _pcbnew.EDGE_MODULE_SetStart0(self, *args)

   def GetStart0(self):
        """
        GetStart0(EDGE_MODULE self) -> wxPoint

        const wxPoint&
        EDGE_MODULE::GetStart0() const
        """
        return _pcbnew.EDGE_MODULE_GetStart0(self)

   def SetEnd0(self, *args):
        """
        SetEnd0(EDGE_MODULE self, wxPoint aPoint)

        void
        EDGE_MODULE::SetEnd0(const wxPoint &aPoint)
        """
        return _pcbnew.EDGE_MODULE_SetEnd0(self, *args)

   def GetEnd0(self):
        """
        GetEnd0(EDGE_MODULE self) -> wxPoint

        const wxPoint&
        EDGE_MODULE::GetEnd0() const
        """
        return _pcbnew.EDGE_MODULE_GetEnd0(self)

   def SetLocalCoord(self):
        """
        SetLocalCoord(EDGE_MODULE self)

        void
        EDGE_MODULE::SetLocalCoord()

        Set relative coordinates.
        """
        return _pcbnew.EDGE_MODULE_SetLocalCoord(self)

   def SetDrawCoord(self):
        """
        SetDrawCoord(EDGE_MODULE self)

        void
        EDGE_MODULE::SetDrawCoord()

        Set absolute coordinates.
        """
        return _pcbnew.EDGE_MODULE_SetDrawCoord(self)

   def Draw(self, *args):
        """
        Draw(EDGE_MODULE self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(EDGE_MODULE self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void
        EDGE_MODULE::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.EDGE_MODULE_Draw(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(EDGE_MODULE self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        EDGE_MODULE::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.EDGE_MODULE_GetMsgPanelInfo(self, *args)

   def GetClass(self):
        """
        GetClass(EDGE_MODULE self) -> wxString

        wxString
        EDGE_MODULE::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.EDGE_MODULE_GetClass(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(EDGE_MODULE self) -> wxString

        wxString
        EDGE_MODULE::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.EDGE_MODULE_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(EDGE_MODULE self) -> BITMAP_DEF

        BITMAP_DEF
        EDGE_MODULE::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.EDGE_MODULE_GetMenuImage(self)

   def Clone(self):
        """
        Clone(EDGE_MODULE self) -> EDA_ITEM

        EDA_ITEM *
        EDGE_MODULE::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.EDGE_MODULE_Clone(self)

    __swig_setmethods__["m_Start0"] = _pcbnew.EDGE_MODULE_m_Start0_set
    __swig_getmethods__["m_Start0"] = _pcbnew.EDGE_MODULE_m_Start0_get
    if _newclass:m_Start0 = _swig_property(_pcbnew.EDGE_MODULE_m_Start0_get, _pcbnew.EDGE_MODULE_m_Start0_set)
    __swig_setmethods__["m_End0"] = _pcbnew.EDGE_MODULE_m_End0_set
    __swig_getmethods__["m_End0"] = _pcbnew.EDGE_MODULE_m_End0_get
    if _newclass:m_End0 = _swig_property(_pcbnew.EDGE_MODULE_m_End0_get, _pcbnew.EDGE_MODULE_m_End0_set)
EDGE_MODULE_swigregister = _pcbnew.EDGE_MODULE_swigregister
EDGE_MODULE_swigregister(EDGE_MODULE)

def EDGE_MODULE_ClassOf(*args):
  """EDGE_MODULE_ClassOf(EDA_ITEM aItem) -> bool"""
  return _pcbnew.EDGE_MODULE_ClassOf(*args)

MAX_ZONE_CORNER_RADIUS_MILS = _pcbnew.MAX_ZONE_CORNER_RADIUS_MILS
class ZONE_SETTINGS(_object):
    """
    Class ZONE_SETTINGS handles zones parameters.

    Because a zone can be on copper or non copper layers, and can be also
    a keepout area, some parameters are irrelevant depending on the type
    of zone

    C++ includes: class_zone_settings.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ZONE_SETTINGS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ZONE_SETTINGS, name)
    __repr__ = _swig_repr
    SMOOTHING_NONE = _pcbnew.ZONE_SETTINGS_SMOOTHING_NONE
    SMOOTHING_CHAMFER = _pcbnew.ZONE_SETTINGS_SMOOTHING_CHAMFER
    SMOOTHING_FILLET = _pcbnew.ZONE_SETTINGS_SMOOTHING_FILLET
    SMOOTHING_LAST = _pcbnew.ZONE_SETTINGS_SMOOTHING_LAST
    __swig_setmethods__["m_FillMode"] = _pcbnew.ZONE_SETTINGS_m_FillMode_set
    __swig_getmethods__["m_FillMode"] = _pcbnew.ZONE_SETTINGS_m_FillMode_get
    if _newclass:m_FillMode = _swig_property(_pcbnew.ZONE_SETTINGS_m_FillMode_get, _pcbnew.ZONE_SETTINGS_m_FillMode_set)
    __swig_setmethods__["m_ZonePriority"] = _pcbnew.ZONE_SETTINGS_m_ZonePriority_set
    __swig_getmethods__["m_ZonePriority"] = _pcbnew.ZONE_SETTINGS_m_ZonePriority_get
    if _newclass:m_ZonePriority = _swig_property(_pcbnew.ZONE_SETTINGS_m_ZonePriority_get, _pcbnew.ZONE_SETTINGS_m_ZonePriority_set)
    __swig_setmethods__["m_ZoneClearance"] = _pcbnew.ZONE_SETTINGS_m_ZoneClearance_set
    __swig_getmethods__["m_ZoneClearance"] = _pcbnew.ZONE_SETTINGS_m_ZoneClearance_get
    if _newclass:m_ZoneClearance = _swig_property(_pcbnew.ZONE_SETTINGS_m_ZoneClearance_get, _pcbnew.ZONE_SETTINGS_m_ZoneClearance_set)
    __swig_setmethods__["m_ZoneMinThickness"] = _pcbnew.ZONE_SETTINGS_m_ZoneMinThickness_set
    __swig_getmethods__["m_ZoneMinThickness"] = _pcbnew.ZONE_SETTINGS_m_ZoneMinThickness_get
    if _newclass:m_ZoneMinThickness = _swig_property(_pcbnew.ZONE_SETTINGS_m_ZoneMinThickness_get, _pcbnew.ZONE_SETTINGS_m_ZoneMinThickness_set)
    __swig_setmethods__["m_NetcodeSelection"] = _pcbnew.ZONE_SETTINGS_m_NetcodeSelection_set
    __swig_getmethods__["m_NetcodeSelection"] = _pcbnew.ZONE_SETTINGS_m_NetcodeSelection_get
    if _newclass:m_NetcodeSelection = _swig_property(_pcbnew.ZONE_SETTINGS_m_NetcodeSelection_get, _pcbnew.ZONE_SETTINGS_m_NetcodeSelection_set)
    __swig_setmethods__["m_CurrentZone_Layer"] = _pcbnew.ZONE_SETTINGS_m_CurrentZone_Layer_set
    __swig_getmethods__["m_CurrentZone_Layer"] = _pcbnew.ZONE_SETTINGS_m_CurrentZone_Layer_get
    if _newclass:m_CurrentZone_Layer = _swig_property(_pcbnew.ZONE_SETTINGS_m_CurrentZone_Layer_get, _pcbnew.ZONE_SETTINGS_m_CurrentZone_Layer_set)
    __swig_setmethods__["m_Zone_HatchingStyle"] = _pcbnew.ZONE_SETTINGS_m_Zone_HatchingStyle_set
    __swig_getmethods__["m_Zone_HatchingStyle"] = _pcbnew.ZONE_SETTINGS_m_Zone_HatchingStyle_get
    if _newclass:m_Zone_HatchingStyle = _swig_property(_pcbnew.ZONE_SETTINGS_m_Zone_HatchingStyle_get, _pcbnew.ZONE_SETTINGS_m_Zone_HatchingStyle_set)
    __swig_setmethods__["m_ArcToSegmentsCount"] = _pcbnew.ZONE_SETTINGS_m_ArcToSegmentsCount_set
    __swig_getmethods__["m_ArcToSegmentsCount"] = _pcbnew.ZONE_SETTINGS_m_ArcToSegmentsCount_get
    if _newclass:m_ArcToSegmentsCount = _swig_property(_pcbnew.ZONE_SETTINGS_m_ArcToSegmentsCount_get, _pcbnew.ZONE_SETTINGS_m_ArcToSegmentsCount_set)
    __swig_setmethods__["m_ThermalReliefGap"] = _pcbnew.ZONE_SETTINGS_m_ThermalReliefGap_set
    __swig_getmethods__["m_ThermalReliefGap"] = _pcbnew.ZONE_SETTINGS_m_ThermalReliefGap_get
    if _newclass:m_ThermalReliefGap = _swig_property(_pcbnew.ZONE_SETTINGS_m_ThermalReliefGap_get, _pcbnew.ZONE_SETTINGS_m_ThermalReliefGap_set)
    __swig_setmethods__["m_ThermalReliefCopperBridge"] = _pcbnew.ZONE_SETTINGS_m_ThermalReliefCopperBridge_set
    __swig_getmethods__["m_ThermalReliefCopperBridge"] = _pcbnew.ZONE_SETTINGS_m_ThermalReliefCopperBridge_get
    if _newclass:m_ThermalReliefCopperBridge = _swig_property(_pcbnew.ZONE_SETTINGS_m_ThermalReliefCopperBridge_get, _pcbnew.ZONE_SETTINGS_m_ThermalReliefCopperBridge_set)
    __swig_setmethods__["m_Zone_45_Only"] = _pcbnew.ZONE_SETTINGS_m_Zone_45_Only_set
    __swig_getmethods__["m_Zone_45_Only"] = _pcbnew.ZONE_SETTINGS_m_Zone_45_Only_get
    if _newclass:m_Zone_45_Only = _swig_property(_pcbnew.ZONE_SETTINGS_m_Zone_45_Only_get, _pcbnew.ZONE_SETTINGS_m_Zone_45_Only_set)
   def __init__(self):
        """
        __init__(ZONE_SETTINGS self) -> ZONE_SETTINGS

        ZONE_SETTINGS::ZONE_SETTINGS()

        class ZONE_SETTINGS used to handle zones parameters
        """
        this = _pcbnew.new_ZONE_SETTINGS()
        try: self.this.append(this)
        except: self.this = this
   def __lshift__(self, *args):
        """__lshift__(ZONE_SETTINGS self, ZONE_CONTAINER aSource) -> ZONE_SETTINGS"""
        return _pcbnew.ZONE_SETTINGS___lshift__(self, *args)

   def ExportSetting(self, *args):
        """
        ExportSetting(ZONE_SETTINGS self, ZONE_CONTAINER aTarget, bool aFullExport=True)
        ExportSetting(ZONE_SETTINGS self, ZONE_CONTAINER aTarget)

        void
        ZONE_SETTINGS::ExportSetting(ZONE_CONTAINER &aTarget, bool
        aFullExport=true) const

        Function ExportSetting copy settings to a given zone.

        Parameters:
        -----------

        aTarget:  the given zone

        aFullExport:  if false: some parameters are NOT exported because they
        must not be exported when export settings from a zone to others zones
        Currently: m_NetcodeSelection
        """
        return _pcbnew.ZONE_SETTINGS_ExportSetting(self, *args)

   def SetCornerSmoothingType(self, *args):
        """
        SetCornerSmoothingType(ZONE_SETTINGS self, int aType)

        void
        ZONE_SETTINGS::SetCornerSmoothingType(int aType)
        """
        return _pcbnew.ZONE_SETTINGS_SetCornerSmoothingType(self, *args)

   def GetCornerSmoothingType(self):
        """
        GetCornerSmoothingType(ZONE_SETTINGS self) -> int

        int
        ZONE_SETTINGS::GetCornerSmoothingType() const
        """
        return _pcbnew.ZONE_SETTINGS_GetCornerSmoothingType(self)

   def SetCornerRadius(self, *args):
        """
        SetCornerRadius(ZONE_SETTINGS self, int aRadius)

        void
        ZONE_SETTINGS::SetCornerRadius(int aRadius)
        """
        return _pcbnew.ZONE_SETTINGS_SetCornerRadius(self, *args)

   def GetCornerRadius(self):
        """
        GetCornerRadius(ZONE_SETTINGS self) -> unsigned int

        unsigned int
        ZONE_SETTINGS::GetCornerRadius() const
        """
        return _pcbnew.ZONE_SETTINGS_GetCornerRadius(self)

   def GetPadConnection(self):
        """
        GetPadConnection(ZONE_SETTINGS self) -> ZoneConnection

        ZoneConnection ZONE_SETTINGS::GetPadConnection() const
        """
        return _pcbnew.ZONE_SETTINGS_GetPadConnection(self)

   def SetPadConnection(self, *args):
        """
        SetPadConnection(ZONE_SETTINGS self, ZoneConnection aPadConnection)

        void
        ZONE_SETTINGS::SetPadConnection(ZoneConnection aPadConnection)
        """
        return _pcbnew.ZONE_SETTINGS_SetPadConnection(self, *args)

   def GetIsKeepout(self):
        """
        GetIsKeepout(ZONE_SETTINGS self) -> bool const

        const bool
        ZONE_SETTINGS::GetIsKeepout() const

        Accessors to parameters used in Keepout zones:
        """
        return _pcbnew.ZONE_SETTINGS_GetIsKeepout(self)

   def GetDoNotAllowCopperPour(self):
        """
        GetDoNotAllowCopperPour(ZONE_SETTINGS self) -> bool const

        const
        bool ZONE_SETTINGS::GetDoNotAllowCopperPour() const
        """
        return _pcbnew.ZONE_SETTINGS_GetDoNotAllowCopperPour(self)

   def GetDoNotAllowVias(self):
        """
        GetDoNotAllowVias(ZONE_SETTINGS self) -> bool const

        const bool
        ZONE_SETTINGS::GetDoNotAllowVias() const
        """
        return _pcbnew.ZONE_SETTINGS_GetDoNotAllowVias(self)

   def GetDoNotAllowTracks(self):
        """
        GetDoNotAllowTracks(ZONE_SETTINGS self) -> bool const

        const bool
        ZONE_SETTINGS::GetDoNotAllowTracks() const
        """
        return _pcbnew.ZONE_SETTINGS_GetDoNotAllowTracks(self)

   def SetIsKeepout(self, *args):
        """
        SetIsKeepout(ZONE_SETTINGS self, bool aEnable)

        void
        ZONE_SETTINGS::SetIsKeepout(bool aEnable)
        """
        return _pcbnew.ZONE_SETTINGS_SetIsKeepout(self, *args)

   def SetDoNotAllowCopperPour(self, *args):
        """
        SetDoNotAllowCopperPour(ZONE_SETTINGS self, bool aEnable)

        void
        ZONE_SETTINGS::SetDoNotAllowCopperPour(bool aEnable)
        """
        return _pcbnew.ZONE_SETTINGS_SetDoNotAllowCopperPour(self, *args)

   def SetDoNotAllowVias(self, *args):
        """
        SetDoNotAllowVias(ZONE_SETTINGS self, bool aEnable)

        void
        ZONE_SETTINGS::SetDoNotAllowVias(bool aEnable)
        """
        return _pcbnew.ZONE_SETTINGS_SetDoNotAllowVias(self, *args)

   def SetDoNotAllowTracks(self, *args):
        """
        SetDoNotAllowTracks(ZONE_SETTINGS self, bool aEnable)

        void
        ZONE_SETTINGS::SetDoNotAllowTracks(bool aEnable)
        """
        return _pcbnew.ZONE_SETTINGS_SetDoNotAllowTracks(self, *args)

    __swig_destroy__ = _pcbnew.delete_ZONE_SETTINGS
    __del__ = lambda self : None;
ZONE_SETTINGS_swigregister = _pcbnew.ZONE_SETTINGS_swigregister
ZONE_SETTINGS_swigregister(ZONE_SETTINGS)

class NETCLASS(_object):
    """
    Class NETCLASS handles a collection of nets and the parameters used to
    route or test these nets.

    C++ includes: class_netclass.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NETCLASS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NETCLASS, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(NETCLASS self, wxString const & aName) -> NETCLASS

        NETCLASS::NETCLASS(const
        wxString &aName)

        Constructor stuffs a NETCLASS instance with aParent, aName, and
        optionally the initialParameters.

        Parameters:
        -----------

        aName:  = the name of this new netclass
        """
        this = _pcbnew.new_NETCLASS(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_NETCLASS
    __del__ = lambda self : None;
   def GetClass(self):
        """
        GetClass(NETCLASS self) -> wxString

        wxString
        NETCLASS::GetClass() const
        """
        return _pcbnew.NETCLASS_GetClass(self)

   def GetName(self):
        """
        GetName(NETCLASS self) -> wxString const &

        const wxString&
        NETCLASS::GetName() const
        """
        return _pcbnew.NETCLASS_GetName(self)

   def SetName(self, *args):
        """
        SetName(NETCLASS self, wxString const & aName)

        void
        NETCLASS::SetName(const wxString &aName)
        """
        return _pcbnew.NETCLASS_SetName(self, *args)

   def GetCount(self):
        """
        GetCount(NETCLASS self) -> unsigned int

        unsigned
        NETCLASS::GetCount() const

        Function GetCount returns the number of nets in this NETCLASS, i.e.

        using these rules.
        """
        return _pcbnew.NETCLASS_GetCount(self)

   def Clear(self):
        """
        Clear(NETCLASS self)

        void NETCLASS::Clear()

        Function Clear empties the collection of members.
        """
        return _pcbnew.NETCLASS_Clear(self)

   def AddNative(self, *args):
        """
        AddNative(NETCLASS self, wxString const & aNetname)

        void NETCLASS::Add(const
        wxString &aNetname)

        Function AddMember adds aNetname to this NETCLASS if it is not already
        in this NETCLASS.

        It is harmless to try and add a second identical name.
        """
        return _pcbnew.NETCLASS_AddNative(self, *args)

   def begin(self, *args):
        """
        begin(NETCLASS self) -> NETCLASS::iterator
        begin(NETCLASS self) -> NETCLASS::const_iterator

        const_iterator
        NETCLASS::begin() const
        """
        return _pcbnew.NETCLASS_begin(self, *args)

   def end(self, *args):
        """
        end(NETCLASS self) -> NETCLASS::iterator
        end(NETCLASS self) -> NETCLASS::const_iterator

        const_iterator NETCLASS::end()
        const
        """
        return _pcbnew.NETCLASS_end(self, *args)

   def Remove(self, *args):
        """
        Remove(NETCLASS self, NETCLASS::iterator aName)
        Remove(NETCLASS self, wxString const & aName)

        void NETCLASS::Remove(const
        wxString &aName)

        Function Remove will remove NET name aName from the collection of
        members.
        """
        return _pcbnew.NETCLASS_Remove(self, *args)

   def GetDescription(self):
        """
        GetDescription(NETCLASS self) -> wxString const &

        const wxString&
        NETCLASS::GetDescription() const
        """
        return _pcbnew.NETCLASS_GetDescription(self)

   def SetDescription(self, *args):
        """
        SetDescription(NETCLASS self, wxString const & aDesc)

        void
        NETCLASS::SetDescription(const wxString &aDesc)
        """
        return _pcbnew.NETCLASS_SetDescription(self, *args)

   def GetClearance(self):
        """
        GetClearance(NETCLASS self) -> int

        int
        NETCLASS::GetClearance() const
        """
        return _pcbnew.NETCLASS_GetClearance(self)

   def SetClearance(self, *args):
        """
        SetClearance(NETCLASS self, int aClearance)

        void
        NETCLASS::SetClearance(int aClearance)
        """
        return _pcbnew.NETCLASS_SetClearance(self, *args)

   def GetTrackWidth(self):
        """
        GetTrackWidth(NETCLASS self) -> int

        int
        NETCLASS::GetTrackWidth() const
        """
        return _pcbnew.NETCLASS_GetTrackWidth(self)

   def SetTrackWidth(self, *args):
        """
        SetTrackWidth(NETCLASS self, int aWidth)

        void
        NETCLASS::SetTrackWidth(int aWidth)
        """
        return _pcbnew.NETCLASS_SetTrackWidth(self, *args)

   def GetViaDiameter(self):
        """
        GetViaDiameter(NETCLASS self) -> int

        int
        NETCLASS::GetViaDiameter() const
        """
        return _pcbnew.NETCLASS_GetViaDiameter(self)

   def SetViaDiameter(self, *args):
        """
        SetViaDiameter(NETCLASS self, int aDia)

        void
        NETCLASS::SetViaDiameter(int aDia)
        """
        return _pcbnew.NETCLASS_SetViaDiameter(self, *args)

   def GetViaDrill(self):
        """
        GetViaDrill(NETCLASS self) -> int

        int
        NETCLASS::GetViaDrill() const
        """
        return _pcbnew.NETCLASS_GetViaDrill(self)

   def SetViaDrill(self, *args):
        """
        SetViaDrill(NETCLASS self, int aSize)

        void
        NETCLASS::SetViaDrill(int aSize)
        """
        return _pcbnew.NETCLASS_SetViaDrill(self, *args)

   def GetuViaDiameter(self):
        """
        GetuViaDiameter(NETCLASS self) -> int

        int
        NETCLASS::GetuViaDiameter() const
        """
        return _pcbnew.NETCLASS_GetuViaDiameter(self)

   def SetuViaDiameter(self, *args):
        """
        SetuViaDiameter(NETCLASS self, int aSize)

        void
        NETCLASS::SetuViaDiameter(int aSize)
        """
        return _pcbnew.NETCLASS_SetuViaDiameter(self, *args)

   def GetuViaDrill(self):
        """
        GetuViaDrill(NETCLASS self) -> int

        int
        NETCLASS::GetuViaDrill() const
        """
        return _pcbnew.NETCLASS_GetuViaDrill(self)

   def SetuViaDrill(self, *args):
        """
        SetuViaDrill(NETCLASS self, int aSize)

        void
        NETCLASS::SetuViaDrill(int aSize)
        """
        return _pcbnew.NETCLASS_SetuViaDrill(self, *args)

   def SetParams(self, *args):
        """
        SetParams(NETCLASS self, NETCLASS aDefaults)
        SetParams(NETCLASS self, BOARD_DESIGN_SETTINGS aSettings)

        void
        NETCLASS::SetParams(const BOARD_DESIGN_SETTINGS &aSettings)

        Function SetParams will set all the parameters by copying them from
        board design settings.

        Parameters:
        -----------

        aSettings:  is a BOARD_DESIGN_SETTINGS object to copy from. Clearance,
       via drill and microvia drill values are taken from the defaults.
        """
        return _pcbnew.NETCLASS_SetParams(self, *args)

   def Format(self, *args):
        """
        Format(NETCLASS self, OUTPUTFORMATTER * aFormatter, int aNestLevel, int aControlBits)

        void
        NETCLASS::Format(OUTPUTFORMATTER *aFormatter, int aNestLevel, int
        aControlBits) const  throw ( IO_ERROR ) Function Format outputs the
        net class to aFormatter in s-expression form.

        Parameters:
        -----------

        aFormatter:  The OUTPUTFORMATTER object to write to.

        aNestLevel:  The indentation next level.

       aControlBits:  The control bit definition for object specific
        formatting.

        Parameters:
        -----------

        ???:  on write error.
        """
        return _pcbnew.NETCLASS_Format(self, *args)

NETCLASS_swigregister = _pcbnew.NETCLASS_swigregister
NETCLASS_swigregister(NETCLASS)
NETCLASS.Default = _pcbnew.cvar.NETCLASS_Default

class NETCLASSES(_object):
    """
    Class NETCLASSES is a container for NETCLASS instances.

    It owns all its NETCLASSes (=> it will delete them at time of
   destruction). This container will always have a default NETCLASS with
    the name given by const NETCLASS::Default.

    C++ includes: class_netclass.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NETCLASSES, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NETCLASSES, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(NETCLASSES self) -> NETCLASSES

        NETCLASSES::NETCLASSES()
        """
        this = _pcbnew.new_NETCLASSES()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_NETCLASSES
    __del__ = lambda self : None;
   def Clear(self):
        """
        Clear(NETCLASSES self)

        void NETCLASSES::Clear()

        Function Clear destroys any contained NETCLASS instances except the
       Default one.
        """
        return _pcbnew.NETCLASSES_Clear(self)

   def begin(self, *args):
        """
        begin(NETCLASSES self) -> NETCLASSES::iterator
        begin(NETCLASSES self) -> NETCLASSES::const_iterator

        const_iterator
        NETCLASSES::begin() const
        """
        return _pcbnew.NETCLASSES_begin(self, *args)

   def end(self, *args):
        """
        end(NETCLASSES self) -> NETCLASSES::iterator
        end(NETCLASSES self) -> NETCLASSES::const_iterator

        const_iterator
        NETCLASSES::end() const
        """
        return _pcbnew.NETCLASSES_end(self, *args)

   def GetCount(self):
        """
        GetCount(NETCLASSES self) -> unsigned int

        unsigned
        NETCLASSES::GetCount() const

        Function GetCount.

       the number of netclasses, excluding the default one.
        """
        return _pcbnew.NETCLASSES_GetCount(self)

   def GetDefault(self):
        """
        GetDefault(NETCLASSES self) -> NETCLASSPTR

        NETCLASSPTR
        NETCLASSES::GetDefault() const

        Function GetDefault.

       the default net class.
        """
        return _pcbnew.NETCLASSES_GetDefault(self)

   def AddNative(self, *args):
        """
        AddNative(NETCLASSES self, NETCLASSPTR aNetclass) -> bool

        bool
        NETCLASSES::Add(NETCLASSPTR aNetclass)

        Function Add takes ownership of aNetclass and puts it into this
        NETCLASSES container.

        Parameters:
        -----------

        aNetclass:  is netclass to add

        true if the name within aNetclass is unique and it could be inserted
        OK, else false because the name was not unique and caller still owns
        aNetclass.
        """
        return _pcbnew.NETCLASSES_AddNative(self, *args)

   def Remove(self, *args):
        """
        Remove(NETCLASSES self, wxString const & aNetName) -> NETCLASSPTR

        NETCLASSPTR
        NETCLASSES::Remove(const wxString &aNetName)

        Function Remove removes a NETCLASS from this container but does not
        destroy/delete it.

        Parameters:
        -----------

        aNetName:  is the name of the net to delete, and it may not be
        NETCLASS::Default.

        NETCLASSPTR - the NETCLASS associated with aNetName if found and
        removed, else NULL.
        """
        return _pcbnew.NETCLASSES_Remove(self, *args)

   def Find(self, *args):
        """
        Find(NETCLASSES self, wxString const & aName) -> NETCLASSPTR

        NETCLASSPTR
        NETCLASSES::Find(const wxString &aName) const

        Function Find searches this container for a NETCLASS given by aName.

        Parameters:
        -----------

        aName:  is the name of the NETCLASS to search for.

        NETCLASSPTR - if found, else NULL.
        """
        return _pcbnew.NETCLASSES_Find(self, *args)

NETCLASSES_swigregister = _pcbnew.NETCLASSES_swigregister
NETCLASSES_swigregister(NETCLASSES)

class PLOT_CONTROLLER(_object):
    """
    Batch plotter state object.

    Keeps the plot options and handles multiple plot requests

    C++ includes: plotcontroller.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLOT_CONTROLLER, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PLOT_CONTROLLER, name)
    __repr__ = _swig_repr
   def __init__(self, *args):
        """
        __init__(PLOT_CONTROLLER self, BOARD aBoard) -> PLOT_CONTROLLER

        PLOT_CONTROLLER::PLOT_CONTROLLER(BOARD *aBoard)

        Batch plotter constructor, nothing interesting here.
        """
        this = _pcbnew.new_PLOT_CONTROLLER(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PLOT_CONTROLLER
    __del__ = lambda self : None;
   def AccessPlotOpts(self):
        """
        AccessPlotOpts(PLOT_CONTROLLER self) -> PCB_PLOT_PARAMS

        PCB_PLOT_PARAMS* PLOT_CONTROLLER::AccessPlotOpts()
        """
        return _pcbnew.PLOT_CONTROLLER_AccessPlotOpts(self)

   def IsPlotOpen(self):
        """
        IsPlotOpen(PLOT_CONTROLLER self) -> bool

        bool
        PLOT_CONTROLLER::IsPlotOpen() const
        """
        return _pcbnew.PLOT_CONTROLLER_IsPlotOpen(self)

   def ClosePlot(self):
        """
        ClosePlot(PLOT_CONTROLLER self)

        void
        PLOT_CONTROLLER::ClosePlot()

        Close the current plot, nothing happens if it isn't open.
        """
        return _pcbnew.PLOT_CONTROLLER_ClosePlot(self)

   def OpenPlotfile(self, *args):
        """
        OpenPlotfile(PLOT_CONTROLLER self, wxString const & aSuffix, PlotFormat aFormat, wxString const & aSheetDesc) -> bool

        bool
        PLOT_CONTROLLER::OpenPlotfile(const wxString &aSuffix, PlotFormat
        aFormat, const wxString &aSheetDesc)

        Open a new plotfile; works as a factory for plotter objects.
        """
        return _pcbnew.PLOT_CONTROLLER_OpenPlotfile(self, *args)

   def PlotLayer(self, *args):
        """
        PlotLayer(PLOT_CONTROLLER self, LAYER_NUM layer) -> bool

        bool
        PLOT_CONTROLLER::PlotLayer(LAYER_NUM layer)

        Plot a single layer on the current plotfile.
        """
        return _pcbnew.PLOT_CONTROLLER_PlotLayer(self, *args)

   def SetColorMode(self, *args):
        """
        SetColorMode(PLOT_CONTROLLER self, bool aColorMode)

        void
        PLOT_CONTROLLER::SetColorMode(bool aColorMode)
        """
        return _pcbnew.PLOT_CONTROLLER_SetColorMode(self, *args)

   def GetColorMode(self):
        """
        GetColorMode(PLOT_CONTROLLER self) -> bool

        bool
        PLOT_CONTROLLER::GetColorMode()
        """
        return _pcbnew.PLOT_CONTROLLER_GetColorMode(self)

PLOT_CONTROLLER_swigregister = _pcbnew.PLOT_CONTROLLER_swigregister
PLOT_CONTROLLER_swigregister(PLOT_CONTROLLER)

class PCB_PLOT_PARAMS(_object):
    """
    Class PCB_PLOT_PARAMS handles plot parameters and options when
    plotting/printing a board.

    C++ includes: pcb_plot_params.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PCB_PLOT_PARAMS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PCB_PLOT_PARAMS, name)
    __repr__ = _swig_repr
    NO_DRILL_SHAPE = _pcbnew.PCB_PLOT_PARAMS_NO_DRILL_SHAPE
    SMALL_DRILL_SHAPE = _pcbnew.PCB_PLOT_PARAMS_SMALL_DRILL_SHAPE
    FULL_DRILL_SHAPE = _pcbnew.PCB_PLOT_PARAMS_FULL_DRILL_SHAPE
   def __init__(self):
        """
        __init__(PCB_PLOT_PARAMS self) -> PCB_PLOT_PARAMS

        PCB_PLOT_PARAMS::PCB_PLOT_PARAMS()
        """
        this = _pcbnew.new_PCB_PLOT_PARAMS()
        try: self.this.append(this)
        except: self.this = this
   def SetSkipPlotNPTH_Pads(self, *args):
        """
        SetSkipPlotNPTH_Pads(PCB_PLOT_PARAMS self, bool aSkip)

        void
        PCB_PLOT_PARAMS::SetSkipPlotNPTH_Pads(bool aSkip)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetSkipPlotNPTH_Pads(self, *args)

   def GetSkipPlotNPTH_Pads(self):
        """
        GetSkipPlotNPTH_Pads(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetSkipPlotNPTH_Pads() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetSkipPlotNPTH_Pads(self)

   def Format(self, *args):
        """
        Format(PCB_PLOT_PARAMS self, OUTPUTFORMATTER * aFormatter, int aNestLevel, int aControl=0)
        Format(PCB_PLOT_PARAMS self, OUTPUTFORMATTER * aFormatter, int aNestLevel)

        void
        PCB_PLOT_PARAMS::Format(OUTPUTFORMATTER *aFormatter, int aNestLevel,
        int aControl=0) const  throw ( IO_ERROR )
        """
        return _pcbnew.PCB_PLOT_PARAMS_Format(self, *args)

   def Parse(self, *args):
        """
        Parse(PCB_PLOT_PARAMS self, PCB_PLOT_PARAMS_PARSER * aParser)

        void
        PCB_PLOT_PARAMS::Parse(PCB_PLOT_PARAMS_PARSER *aParser)  throw (
        PARSE_ERROR, IO_ERROR )
        """
        return _pcbnew.PCB_PLOT_PARAMS_Parse(self, *args)

   def __eq__(self, *args):
        """__eq__(PCB_PLOT_PARAMS self, PCB_PLOT_PARAMS aPcbPlotParams) -> bool"""
        return _pcbnew.PCB_PLOT_PARAMS___eq__(self, *args)

   def __ne__(self, *args):
        """__ne__(PCB_PLOT_PARAMS self, PCB_PLOT_PARAMS aPcbPlotParams) -> bool"""
        return _pcbnew.PCB_PLOT_PARAMS___ne__(self, *args)

   def SetColor(self, *args):
        """
        SetColor(PCB_PLOT_PARAMS self, EDA_COLOR_T aVal)

        void
        PCB_PLOT_PARAMS::SetColor(EDA_COLOR_T aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetColor(self, *args)

   def GetColor(self):
        """
        GetColor(PCB_PLOT_PARAMS self) -> EDA_COLOR_T

        EDA_COLOR_T
        PCB_PLOT_PARAMS::GetColor() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetColor(self)

   def SetReferenceColor(self, *args):
        """
        SetReferenceColor(PCB_PLOT_PARAMS self, EDA_COLOR_T aVal)

        void
        PCB_PLOT_PARAMS::SetReferenceColor(EDA_COLOR_T aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetReferenceColor(self, *args)

   def GetReferenceColor(self):
        """
        GetReferenceColor(PCB_PLOT_PARAMS self) -> EDA_COLOR_T

        EDA_COLOR_T PCB_PLOT_PARAMS::GetReferenceColor() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetReferenceColor(self)

   def SetValueColor(self, *args):
        """
        SetValueColor(PCB_PLOT_PARAMS self, EDA_COLOR_T aVal)

        void
        PCB_PLOT_PARAMS::SetValueColor(EDA_COLOR_T aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetValueColor(self, *args)

   def GetValueColor(self):
        """
        GetValueColor(PCB_PLOT_PARAMS self) -> EDA_COLOR_T

        EDA_COLOR_T
        PCB_PLOT_PARAMS::GetValueColor() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetValueColor(self)

   def SetTextMode(self, *args):
        """
        SetTextMode(PCB_PLOT_PARAMS self, PlotTextMode aVal)

        void
        PCB_PLOT_PARAMS::SetTextMode(PlotTextMode aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetTextMode(self, *args)

   def GetTextMode(self):
        """
        GetTextMode(PCB_PLOT_PARAMS self) -> PlotTextMode

        PlotTextMode
        PCB_PLOT_PARAMS::GetTextMode() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetTextMode(self)

   def SetMode(self, *args):
        """
        SetMode(PCB_PLOT_PARAMS self, EDA_DRAW_MODE_T aVal)

        void
        PCB_PLOT_PARAMS::SetMode(EDA_DRAW_MODE_T aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetMode(self, *args)

   def GetMode(self):
        """
        GetMode(PCB_PLOT_PARAMS self) -> EDA_DRAW_MODE_T

        EDA_DRAW_MODE_T
        PCB_PLOT_PARAMS::GetMode() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetMode(self)

   def SetDrillMarksType(self, *args):
        """
        SetDrillMarksType(PCB_PLOT_PARAMS self, PCB_PLOT_PARAMS::DrillMarksType aVal)

        void
        PCB_PLOT_PARAMS::SetDrillMarksType(DrillMarksType aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetDrillMarksType(self, *args)

   def GetDrillMarksType(self):
        """
        GetDrillMarksType(PCB_PLOT_PARAMS self) -> PCB_PLOT_PARAMS::DrillMarksType

        DrillMarksType PCB_PLOT_PARAMS::GetDrillMarksType() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetDrillMarksType(self)

   def SetScale(self, *args):
        """
        SetScale(PCB_PLOT_PARAMS self, double aVal)

        void
        PCB_PLOT_PARAMS::SetScale(double aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetScale(self, *args)

   def GetScale(self):
        """
        GetScale(PCB_PLOT_PARAMS self) -> double

        double
        PCB_PLOT_PARAMS::GetScale() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetScale(self)

   def SetFineScaleAdjustX(self, *args):
        """
        SetFineScaleAdjustX(PCB_PLOT_PARAMS self, double aVal)

        void
        PCB_PLOT_PARAMS::SetFineScaleAdjustX(double aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetFineScaleAdjustX(self, *args)

   def GetFineScaleAdjustX(self):
        """
        GetFineScaleAdjustX(PCB_PLOT_PARAMS self) -> double

        double
        PCB_PLOT_PARAMS::GetFineScaleAdjustX() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetFineScaleAdjustX(self)

   def SetFineScaleAdjustY(self, *args):
        """
        SetFineScaleAdjustY(PCB_PLOT_PARAMS self, double aVal)

        void
        PCB_PLOT_PARAMS::SetFineScaleAdjustY(double aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetFineScaleAdjustY(self, *args)

   def GetFineScaleAdjustY(self):
        """
        GetFineScaleAdjustY(PCB_PLOT_PARAMS self) -> double

        double
        PCB_PLOT_PARAMS::GetFineScaleAdjustY() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetFineScaleAdjustY(self)

   def SetWidthAdjust(self, *args):
        """
        SetWidthAdjust(PCB_PLOT_PARAMS self, int aVal)

        void
        PCB_PLOT_PARAMS::SetWidthAdjust(int aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetWidthAdjust(self, *args)

   def GetWidthAdjust(self):
        """
        GetWidthAdjust(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetWidthAdjust() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetWidthAdjust(self)

   def SetAutoScale(self, *args):
        """
        SetAutoScale(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetAutoScale(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetAutoScale(self, *args)

   def GetAutoScale(self):
        """
        GetAutoScale(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetAutoScale() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetAutoScale(self)

   def SetMirror(self, *args):
        """
        SetMirror(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetMirror(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetMirror(self, *args)

   def GetMirror(self):
        """
        GetMirror(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetMirror() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetMirror(self)

   def SetPlotPadsOnSilkLayer(self, *args):
        """
        SetPlotPadsOnSilkLayer(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetPlotPadsOnSilkLayer(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetPlotPadsOnSilkLayer(self, *args)

   def GetPlotPadsOnSilkLayer(self):
        """
        GetPlotPadsOnSilkLayer(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetPlotPadsOnSilkLayer() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetPlotPadsOnSilkLayer(self)

   def SetPlotInvisibleText(self, *args):
        """
        SetPlotInvisibleText(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetPlotInvisibleText(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetPlotInvisibleText(self, *args)

   def GetPlotInvisibleText(self):
        """
        GetPlotInvisibleText(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetPlotInvisibleText() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetPlotInvisibleText(self)

   def SetPlotValue(self, *args):
        """
        SetPlotValue(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetPlotValue(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetPlotValue(self, *args)

   def GetPlotValue(self):
        """
        GetPlotValue(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetPlotValue() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetPlotValue(self)

   def SetPlotReference(self, *args):
        """
        SetPlotReference(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetPlotReference(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetPlotReference(self, *args)

   def GetPlotReference(self):
        """
        GetPlotReference(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetPlotReference() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetPlotReference(self)

   def SetNegative(self, *args):
        """
        SetNegative(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetNegative(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetNegative(self, *args)

   def GetNegative(self):
        """
        GetNegative(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetNegative() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetNegative(self)

   def SetPlotViaOnMaskLayer(self, *args):
        """
        SetPlotViaOnMaskLayer(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetPlotViaOnMaskLayer(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetPlotViaOnMaskLayer(self, *args)

   def GetPlotViaOnMaskLayer(self):
        """
        GetPlotViaOnMaskLayer(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetPlotViaOnMaskLayer() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetPlotViaOnMaskLayer(self)

   def SetPlotFrameRef(self, *args):
        """
        SetPlotFrameRef(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetPlotFrameRef(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetPlotFrameRef(self, *args)

   def GetPlotFrameRef(self):
        """
        GetPlotFrameRef(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetPlotFrameRef() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetPlotFrameRef(self)

   def SetExcludeEdgeLayer(self, *args):
        """
        SetExcludeEdgeLayer(PCB_PLOT_PARAMS self, bool aFlag)

        void
        PCB_PLOT_PARAMS::SetExcludeEdgeLayer(bool aFlag)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetExcludeEdgeLayer(self, *args)

   def GetExcludeEdgeLayer(self):
        """
        GetExcludeEdgeLayer(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetExcludeEdgeLayer() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetExcludeEdgeLayer(self)

   def SetFormat(self, *args):
        """
        SetFormat(PCB_PLOT_PARAMS self, PlotFormat aFormat)

        void
        PCB_PLOT_PARAMS::SetFormat(PlotFormat aFormat)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetFormat(self, *args)

   def GetFormat(self):
        """
        GetFormat(PCB_PLOT_PARAMS self) -> PlotFormat

        PlotFormat
        PCB_PLOT_PARAMS::GetFormat() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetFormat(self)

   def SetOutputDirectory(self, *args):
        """
        SetOutputDirectory(PCB_PLOT_PARAMS self, wxString aDir)

        void
        PCB_PLOT_PARAMS::SetOutputDirectory(wxString aDir)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetOutputDirectory(self, *args)

   def GetOutputDirectory(self):
        """
        GetOutputDirectory(PCB_PLOT_PARAMS self) -> wxString

        wxString
        PCB_PLOT_PARAMS::GetOutputDirectory() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetOutputDirectory(self)

   def SetUseGerberAttributes(self, *args):
        """
        SetUseGerberAttributes(PCB_PLOT_PARAMS self, bool aUse)

        void
        PCB_PLOT_PARAMS::SetUseGerberAttributes(bool aUse)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetUseGerberAttributes(self, *args)

   def GetUseGerberAttributes(self):
        """
        GetUseGerberAttributes(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetUseGerberAttributes() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetUseGerberAttributes(self)

   def SetUseGerberExtensions(self, *args):
        """
        SetUseGerberExtensions(PCB_PLOT_PARAMS self, bool aUse)

        void
        PCB_PLOT_PARAMS::SetUseGerberExtensions(bool aUse)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetUseGerberExtensions(self, *args)

   def GetUseGerberExtensions(self):
        """
        GetUseGerberExtensions(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetUseGerberExtensions() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetUseGerberExtensions(self)

   def SetGerberPrecision(self, *args):
        """
        SetGerberPrecision(PCB_PLOT_PARAMS self, int aPrecision)

        void
        PCB_PLOT_PARAMS::SetGerberPrecision(int aPrecision)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetGerberPrecision(self, *args)

   def GetGerberPrecision(self):
        """
        GetGerberPrecision(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetGerberPrecision() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetGerberPrecision(self)

   def GetGerberDefaultPrecision():
        """GetGerberDefaultPrecision() -> int"""
        return _pcbnew.PCB_PLOT_PARAMS_GetGerberDefaultPrecision()

    if _newclass:GetGerberDefaultPrecision = staticmethod(GetGerberDefaultPrecision)
    __swig_getmethods__["GetGerberDefaultPrecision"] = lambda x: GetGerberDefaultPrecision
   def SetSubtractMaskFromSilk(self, *args):
        """
        SetSubtractMaskFromSilk(PCB_PLOT_PARAMS self, bool aSubtract)

        void
        PCB_PLOT_PARAMS::SetSubtractMaskFromSilk(bool aSubtract)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetSubtractMaskFromSilk(self, *args)

   def GetSubtractMaskFromSilk(self):
        """
        GetSubtractMaskFromSilk(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetSubtractMaskFromSilk() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetSubtractMaskFromSilk(self)

   def SetLayerSelection(self, *args):
        """
        SetLayerSelection(PCB_PLOT_PARAMS self, LSET aSelection)

        void
        PCB_PLOT_PARAMS::SetLayerSelection(LSET aSelection)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetLayerSelection(self, *args)

   def GetLayerSelection(self):
        """
        GetLayerSelection(PCB_PLOT_PARAMS self) -> LSET

        LSET
        PCB_PLOT_PARAMS::GetLayerSelection() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetLayerSelection(self)

   def SetUseAuxOrigin(self, *args):
        """
        SetUseAuxOrigin(PCB_PLOT_PARAMS self, bool aAux)

        void
        PCB_PLOT_PARAMS::SetUseAuxOrigin(bool aAux)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetUseAuxOrigin(self, *args)

   def GetUseAuxOrigin(self):
        """
        GetUseAuxOrigin(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetUseAuxOrigin() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetUseAuxOrigin(self)

   def SetScaleSelection(self, *args):
        """
        SetScaleSelection(PCB_PLOT_PARAMS self, int aSelection)

        void
        PCB_PLOT_PARAMS::SetScaleSelection(int aSelection)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetScaleSelection(self, *args)

   def GetScaleSelection(self):
        """
        GetScaleSelection(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetScaleSelection() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetScaleSelection(self)

   def SetA4Output(self, *args):
        """
        SetA4Output(PCB_PLOT_PARAMS self, int aForce)

        void
        PCB_PLOT_PARAMS::SetA4Output(int aForce)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetA4Output(self, *args)

   def GetA4Output(self):
        """
        GetA4Output(PCB_PLOT_PARAMS self) -> bool

        bool
        PCB_PLOT_PARAMS::GetA4Output() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetA4Output(self)

   def GetHPGLPenDiameter(self):
        """
        GetHPGLPenDiameter(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetHPGLPenDiameter() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetHPGLPenDiameter(self)

   def SetHPGLPenDiameter(self, *args):
        """
        SetHPGLPenDiameter(PCB_PLOT_PARAMS self, int aValue) -> bool

        bool
        PCB_PLOT_PARAMS::SetHPGLPenDiameter(int aValue)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetHPGLPenDiameter(self, *args)

   def GetHPGLPenSpeed(self):
        """
        GetHPGLPenSpeed(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetHPGLPenSpeed() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetHPGLPenSpeed(self)

   def SetHPGLPenSpeed(self, *args):
        """
        SetHPGLPenSpeed(PCB_PLOT_PARAMS self, int aValue) -> bool

        bool
        PCB_PLOT_PARAMS::SetHPGLPenSpeed(int aValue)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetHPGLPenSpeed(self, *args)

   def GetHPGLPenOverlay(self):
        """
        GetHPGLPenOverlay(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetHPGLPenOverlay() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetHPGLPenOverlay(self)

   def SetHPGLPenOverlay(self, *args):
        """
        SetHPGLPenOverlay(PCB_PLOT_PARAMS self, int aValue) -> bool

        bool
        PCB_PLOT_PARAMS::SetHPGLPenOverlay(int aValue)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetHPGLPenOverlay(self, *args)

   def SetHPGLPenNum(self, *args):
        """
        SetHPGLPenNum(PCB_PLOT_PARAMS self, int aVal)

        void
        PCB_PLOT_PARAMS::SetHPGLPenNum(int aVal)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetHPGLPenNum(self, *args)

   def GetHPGLPenNum(self):
        """
        GetHPGLPenNum(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetHPGLPenNum() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetHPGLPenNum(self)

   def GetLineWidth(self):
        """
        GetLineWidth(PCB_PLOT_PARAMS self) -> int

        int
        PCB_PLOT_PARAMS::GetLineWidth() const
        """
        return _pcbnew.PCB_PLOT_PARAMS_GetLineWidth(self)

   def SetLineWidth(self, *args):
        """
        SetLineWidth(PCB_PLOT_PARAMS self, int aValue) -> bool

        bool
        PCB_PLOT_PARAMS::SetLineWidth(int aValue)
        """
        return _pcbnew.PCB_PLOT_PARAMS_SetLineWidth(self, *args)

    __swig_destroy__ = _pcbnew.delete_PCB_PLOT_PARAMS
    __del__ = lambda self : None;
PCB_PLOT_PARAMS_swigregister = _pcbnew.PCB_PLOT_PARAMS_swigregister
PCB_PLOT_PARAMS_swigregister(PCB_PLOT_PARAMS)

def PCB_PLOT_PARAMS_GetGerberDefaultPrecision():
  """PCB_PLOT_PARAMS_GetGerberDefaultPrecision() -> int"""
  return _pcbnew.PCB_PLOT_PARAMS_GetGerberDefaultPrecision()

PLOT_FIRST_FORMAT = _pcbnew.PLOT_FIRST_FORMAT
PLOT_FORMAT_HPGL = _pcbnew.PLOT_FORMAT_HPGL
PLOT_FORMAT_GERBER = _pcbnew.PLOT_FORMAT_GERBER
PLOT_FORMAT_POST = _pcbnew.PLOT_FORMAT_POST
PLOT_FORMAT_DXF = _pcbnew.PLOT_FORMAT_DXF
PLOT_FORMAT_PDF = _pcbnew.PLOT_FORMAT_PDF
PLOT_FORMAT_SVG = _pcbnew.PLOT_FORMAT_SVG
PLOT_LAST_FORMAT = _pcbnew.PLOT_LAST_FORMAT
PLOTTEXTMODE_STROKE = _pcbnew.PLOTTEXTMODE_STROKE
PLOTTEXTMODE_NATIVE = _pcbnew.PLOTTEXTMODE_NATIVE
PLOTTEXTMODE_PHANTOM = _pcbnew.PLOTTEXTMODE_PHANTOM
PLOTTEXTMODE_DEFAULT = _pcbnew.PLOTTEXTMODE_DEFAULT
class PLOTTER(_object):
    """
    Base plotter engine class.

    General rule: all the interface with the caller is done in IU, the IU
    size is specified with SetViewport. Internal and output processing is
    usually done in decimils (or whatever unit the effective engine class
    need to use)

    C++ includes: plot_common.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLOTTER, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PLOTTER, name)
   def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
   DEFAULT_LINE_WIDTH = _pcbnew.PLOTTER_DEFAULT_LINE_WIDTH
    __swig_destroy__ = _pcbnew.delete_PLOTTER
    __del__ = lambda self : None;
   def GetPlotterType(self):
        """
        GetPlotterType(PLOTTER self) -> PlotFormat

        virtual PlotFormat
        PLOTTER::GetPlotterType() const =0

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.PLOTTER_GetPlotterType(self)

   def StartPlot(self):
        """
        StartPlot(PLOTTER self) -> bool

        virtual bool
        PLOTTER::StartPlot()=0
        """
        return _pcbnew.PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(PLOTTER self) -> bool

        virtual bool
        PLOTTER::EndPlot()=0
        """
        return _pcbnew.PLOTTER_EndPlot(self)

   def SetNegative(self, *args):
        """
        SetNegative(PLOTTER self, bool _negative)

        virtual void
        PLOTTER::SetNegative(bool _negative)
        """
        return _pcbnew.PLOTTER_SetNegative(self, *args)

   def SetColorMode(self, *args):
        """
        SetColorMode(PLOTTER self, bool _color_mode)

        virtual void
        PLOTTER::SetColorMode(bool _color_mode)
        """
        return _pcbnew.PLOTTER_SetColorMode(self, *args)

   def GetColorMode(self):
        """
        GetColorMode(PLOTTER self) -> bool

        bool
        PLOTTER::GetColorMode() const
        """
        return _pcbnew.PLOTTER_GetColorMode(self)

   def SetPageSettings(self, *args):
        """
        SetPageSettings(PLOTTER self, PAGE_INFO const & aPageSettings)

        void
        PLOTTER::SetPageSettings(const PAGE_INFO &aPageSettings)
        """
        return _pcbnew.PLOTTER_SetPageSettings(self, *args)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(PLOTTER self, int width)

        virtual void
        PLOTTER::SetCurrentLineWidth(int width)=0

        Set the line width for the next drawing.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDefaultLineWidth(self, *args):
        """
        SetDefaultLineWidth(PLOTTER self, int width)

        virtual void
        PLOTTER::SetDefaultLineWidth(int width)=0

       Set the default line width.

        Used at the beginning and when a width of -1 (DEFAULT_LINE_WIDTH) is
        requested.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.PLOTTER_SetDefaultLineWidth(self, *args)

   def GetCurrentLineWidth(self):
        """
        GetCurrentLineWidth(PLOTTER self) -> int

        virtual int
        PLOTTER::GetCurrentLineWidth() const
        """
        return _pcbnew.PLOTTER_GetCurrentLineWidth(self)

   def SetColor(self, *args):
        """
        SetColor(PLOTTER self, EDA_COLOR_T color)

        virtual void
        PLOTTER::SetColor(EDA_COLOR_T color)=0
        """
        return _pcbnew.PLOTTER_SetColor(self, *args)

   def SetDash(self, *args):
        """
        SetDash(PLOTTER self, bool dashed)

        virtual void
        PLOTTER::SetDash(bool dashed)=0
        """
        return _pcbnew.PLOTTER_SetDash(self, *args)

   def SetCreator(self, *args):
        """
        SetCreator(PLOTTER self, wxString const & _creator)

        virtual void
        PLOTTER::SetCreator(const wxString &_creator)
        """
        return _pcbnew.PLOTTER_SetCreator(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        virtual void
        PLOTTER::SetViewport(const wxPoint &aOffset, double aIusPerDecimil,
        double aScale, bool aMirror)=0

        Set the plot offset and scaling for the current plot.

        Parameters:
        -----------

        aOffset:  is the plot offset

        aIusPerDecimil:  gives the scaling factor from IUs to device units

        aScale:  is the user set plot scaling factor (either explicitly or
        using 'fit to A4')

        aMirror:  flips the plot in the Y direction (useful for toner
        transfers or some kind of film)
        """
        return _pcbnew.PLOTTER_SetViewport(self, *args)

   def OpenFile(self, *args):
        """
        OpenFile(PLOTTER self, wxString const & aFullFilename) -> bool

        bool
        PLOTTER::OpenFile(const wxString &aFullFilename)

        Open or create the plot file aFullFilename.

        Parameters:
        -----------

        aFullFilename:  = the full file name of the file to create

        true if success, false if the file cannot be created/opened  Virtual
        because some plotters use ascii files, some others binary files (PDF)
        The base class open the file in text mode
        """
        return _pcbnew.PLOTTER_OpenFile(self, *args)

   def GetIUsPerDecimil(self):
        """
        GetIUsPerDecimil(PLOTTER self) -> double

        double
        PLOTTER::GetIUsPerDecimil() const

        The IUs per decimil are an essential scaling factor when plotting;
        they are set and saved when establishing the viewport.

        Here they can be get back again
        """
        return _pcbnew.PLOTTER_GetIUsPerDecimil(self)

   def Rect(self, *args):
        """
        Rect(PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        virtual void
        PLOTTER::Rect(const wxPoint &p1, const wxPoint &p2, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)=0
        """
        return _pcbnew.PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        virtual void
        PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)=0
        """
        return _pcbnew.PLOTTER_Circle(self, *args)

   def Arc(self, *args):
        """
        Arc(PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Arc(PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill)

        void PLOTTER::Arc(const wxPoint
        &centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)

        Generic fallback: arc rendered as a polyline.
        """
        return _pcbnew.PLOTTER_Arc(self, *args)

   def PenTo(self, *args):
        """
        PenTo(PLOTTER self, wxPoint pos, char plume)

        virtual void
        PLOTTER::PenTo(const wxPoint &pos, char plume)=0

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.PLOTTER_PenTo(self, *args)

   def MoveTo(self, *args):
        """
        MoveTo(PLOTTER self, wxPoint pos)

        void PLOTTER::MoveTo(const
        wxPoint &pos)
        """
        return _pcbnew.PLOTTER_MoveTo(self, *args)

   def LineTo(self, *args):
        """
        LineTo(PLOTTER self, wxPoint pos)

        void PLOTTER::LineTo(const
        wxPoint &pos)
        """
        return _pcbnew.PLOTTER_LineTo(self, *args)

   def FinishTo(self, *args):
        """
        FinishTo(PLOTTER self, wxPoint pos)

        void
        PLOTTER::FinishTo(const wxPoint &pos)
        """
        return _pcbnew.PLOTTER_FinishTo(self, *args)

   def PenFinish(self):
        """
        PenFinish(PLOTTER self)

        void PLOTTER::PenFinish()

        """
        return _pcbnew.PLOTTER_PenFinish(self)

   def PlotPoly(self, *args):
        """
        PlotPoly(PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        virtual void
        PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList, FILL_T
        aFill, int aWidth=DEFAULT_LINE_WIDTH)=0

        Function PlotPoly.

        Draw a polygon ( filled or not )

        Parameters:
        -----------

        aCornerList:  = corners list

        aFill:  = type of fill

        aWidth:  = line width
        """
        return _pcbnew.PLOTTER_PlotPoly(self, *args)

   def PlotImage(self, *args):
        """
        PlotImage(PLOTTER self, wxImage const & aImage, wxPoint aPos, double aScaleFactor)

        void
        PLOTTER::PlotImage(const wxImage &aImage, const wxPoint &aPos, double
        aScaleFactor)

        Function PlotImage Only Postscript plotters can plot bitmaps for
        plotters that cannot plot a bitmap, a rectangle is plotted.

        Draw an image bitmap

        Parameters:
        -----------

        aImage:  = the bitmap

        aPos:  = position of the center of the bitmap

        aScaleFactor:  = the scale factor to apply to the bitmap size (this is
        not the plot scale factor)
        """
        return _pcbnew.PLOTTER_PlotImage(self, *args)

   def ThickSegment(self, *args):
        """
        ThickSegment(PLOTTER self, wxPoint start, wxPoint end, int width, EDA_DRAW_MODE_T tracemode)

        void
        PLOTTER::ThickSegment(const wxPoint &start, const wxPoint &end, int
        width, EDA_DRAW_MODE_T tracemode)
        """
        return _pcbnew.PLOTTER_ThickSegment(self, *args)

   def ThickArc(self, *args):
        """
        ThickArc(PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, int width, EDA_DRAW_MODE_T tracemode)

        void
        PLOTTER::ThickArc(const wxPoint &centre, double StAngle, double
        EndAngle, int rayon, int width, EDA_DRAW_MODE_T tracemode)
        """
        return _pcbnew.PLOTTER_ThickArc(self, *args)

   def ThickRect(self, *args):
        """
        ThickRect(PLOTTER self, wxPoint p1, wxPoint p2, int width, EDA_DRAW_MODE_T tracemode)

        void
        PLOTTER::ThickRect(const wxPoint &p1, const wxPoint &p2, int width,
        EDA_DRAW_MODE_T tracemode)
        """
        return _pcbnew.PLOTTER_ThickRect(self, *args)

   def ThickCircle(self, *args):
        """
        ThickCircle(PLOTTER self, wxPoint pos, int diametre, int width, EDA_DRAW_MODE_T tracemode)

        void
        PLOTTER::ThickCircle(const wxPoint &pos, int diametre, int width,
        EDA_DRAW_MODE_T tracemode)
        """
        return _pcbnew.PLOTTER_ThickCircle(self, *args)

   def FlashPadCircle(self, *args):
        """
        FlashPadCircle(PLOTTER self, wxPoint pos, int diametre, EDA_DRAW_MODE_T trace_mode)

        virtual void
        PLOTTER::FlashPadCircle(const wxPoint &pos, int diametre,
        EDA_DRAW_MODE_T trace_mode)=0
        """
        return _pcbnew.PLOTTER_FlashPadCircle(self, *args)

   def FlashPadOval(self, *args):
        """
        FlashPadOval(PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        virtual void
        PLOTTER::FlashPadOval(const wxPoint &pos, const wxSize &size, double
        orient, EDA_DRAW_MODE_T trace_mode)=0
        """
        return _pcbnew.PLOTTER_FlashPadOval(self, *args)

   def FlashPadRect(self, *args):
        """
        FlashPadRect(PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        virtual void
        PLOTTER::FlashPadRect(const wxPoint &pos, const wxSize &size, double
        orient, EDA_DRAW_MODE_T trace_mode)=0
        """
        return _pcbnew.PLOTTER_FlashPadRect(self, *args)

   def FlashPadTrapez(self, *args):
        """
        FlashPadTrapez(PLOTTER self, wxPoint aPadPos, wxPoint aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        virtual void
        PLOTTER::FlashPadTrapez(const wxPoint &aPadPos, const wxPoint
        *aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)=0

        virtual function FlashPadTrapez flash a trapezoidal pad

        Parameters:
        -----------

        aPadPos:  = the position of the shape

        aCorners:  = the list of 4 corners positions, relative to the shape
        position, pad orientation 0

        aPadOrient:  = the rotation of the shape

        aTrace_Mode:  = FILLED or SKETCH
        """
        return _pcbnew.PLOTTER_FlashPadTrapez(self, *args)

   def Text(self, *args):
        """
        Text(PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=False)
        Text(PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold)

        void PLOTTER::Text(const
        wxPoint &aPos, enum EDA_COLOR_T aColor, const wxString &aText, double
        aOrient, const wxSize &aSize, enum EDA_TEXT_HJUSTIFY_T aH_justify,
        enum EDA_TEXT_VJUSTIFY_T aV_justify, int aWidth, bool aItalic, bool
        aBold, bool aMultilineAllowed=false)

        Draws text with the plotter.

        Function PlotGraphicText same as DrawGraphicText, but plot graphic
        text insteed of draw it.

        For convenience it accept the color to use

        Parameters:
        -----------

        aPos:  = text position (according to aH_justify, aV_justify)

        aColor:  (enum EDA_COLOR_T) = text color

        aText:  = text to draw

        aOrient:  = angle in 0.1 degree

        aSize:  = text size (size.x or size.y can be < 0 for mirrored texts)

        aH_justify:  = horizontal justification (Left, center, right)

        aV_justify:  = vertical justification (bottom, center, top)

        aWidth:  = line width (pen width) (default = 0) if width < 0 : draw
        segments in sketch mode, width = abs(width) Use a value min(aSize.x,
        aSize.y) / 5 for a bold text

        aItalic:  = true to simulate an italic font

       aBold:  = true to use a bold font Useful only with default width value
        (aWidth = 0)

        aMultilineAllowed:  = true to plot text as multiline, otherwise single
        line
        """
        return _pcbnew.PLOTTER_Text(self, *args)

    MARKER_COUNT = _pcbnew.PLOTTER_MARKER_COUNT
   def Marker(self, *args):
        """
        Marker(PLOTTER self, wxPoint position, int diametre, unsigned int aShapeId)

        void PLOTTER::Marker(const
        wxPoint &position, int diametre, unsigned aShapeId)

        Draw a pattern shape number aShapeId, to coord x0, y0.

        x0, y0 = coordinates tables Diameter diameter = (coord table) hole
        AShapeId = index (used to generate forms characters)
        """
        return _pcbnew.PLOTTER_Marker(self, *args)

   def SetLayerPolarity(self, *args):
        """
        SetLayerPolarity(PLOTTER self, bool aPositive)

        virtual void
        PLOTTER::SetLayerPolarity(bool aPositive)

        Function SetLayerPolarity sets current Gerber layer polarity to
        positive or negative by writing %LPD*% or %LPC*% to the Gerber file,
        respectively.

        (obviously starts a new Gerber layer, too)

        Parameters:
        -----------

        aPositive:  is the layer polarity and true for positive. It's not
        useful with most other plotter since they can't 'scratch' the film
        like photoplotter imagers do
        """
        return _pcbnew.PLOTTER_SetLayerPolarity(self, *args)

   def SetTextMode(self, *args):
        """
        SetTextMode(PLOTTER self, PlotTextMode mode)

        virtual void
        PLOTTER::SetTextMode(PlotTextMode mode)

        Change the current text mode.

        See the PlotTextMode explanation at the beginning of the file
        """
        return _pcbnew.PLOTTER_SetTextMode(self, *args)

   def SetLayerAttribFunction(self, *args):
        """
        SetLayerAttribFunction(PLOTTER self, wxString const & function)

        virtual void
        PLOTTER::SetLayerAttribFunction(const wxString &function)
        """
        return _pcbnew.PLOTTER_SetLayerAttribFunction(self, *args)

   def SetGerberCoordinatesFormat(self, *args):
        """
        SetGerberCoordinatesFormat(PLOTTER self, int aResolution, bool aUseInches=False)
        SetGerberCoordinatesFormat(PLOTTER self, int aResolution)

        virtual
        void PLOTTER::SetGerberCoordinatesFormat(int aResolution, bool
        aUseInches=false)
        """
        return _pcbnew.PLOTTER_SetGerberCoordinatesFormat(self, *args)

PLOTTER_swigregister = _pcbnew.PLOTTER_swigregister
PLOTTER_swigregister(PLOTTER)

class HPGL_PLOTTER(PLOTTER):
    """C++ includes: plot_common.h """
    __swig_setmethods__ = {}
    for _s in [PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HPGL_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, HPGL_PLOTTER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(HPGL_PLOTTER self) -> HPGL_PLOTTER

        HPGL_PLOTTER::HPGL_PLOTTER()
        """
        this = _pcbnew.new_HPGL_PLOTTER()
        try: self.this.append(this)
        except: self.this = this
   def GetPlotterType(self):
        """
        GetPlotterType(HPGL_PLOTTER self) -> PlotFormat

        virtual
        PlotFormat HPGL_PLOTTER::GetPlotterType() const

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.HPGL_PLOTTER_GetPlotterType(self)

   def GetDefaultFileExtension():
        """GetDefaultFileExtension() -> wxString"""
        return _pcbnew.HPGL_PLOTTER_GetDefaultFileExtension()

    if _newclass:GetDefaultFileExtension = staticmethod(GetDefaultFileExtension)
    __swig_getmethods__["GetDefaultFileExtension"] = lambda x: GetDefaultFileExtension
   def StartPlot(self):
        """
        StartPlot(HPGL_PLOTTER self) -> bool

        bool
        HPGL_PLOTTER::StartPlot()

        At the start of the HPGL plot pen speed and number are requested.
        """
        return _pcbnew.HPGL_PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(HPGL_PLOTTER self) -> bool

        bool
        HPGL_PLOTTER::EndPlot()

        HPGL end of plot: pen return and release.
        """
        return _pcbnew.HPGL_PLOTTER_EndPlot(self)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(HPGL_PLOTTER self, int width)

        virtual
        void HPGL_PLOTTER::SetCurrentLineWidth(int width)

        HPGL doesn't handle line thickness or color.
        """
        return _pcbnew.HPGL_PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDefaultLineWidth(self, *args):
        """
        SetDefaultLineWidth(HPGL_PLOTTER self, int width)

        virtual
        void HPGL_PLOTTER::SetDefaultLineWidth(int width)

       Set the default line width.

        Used at the beginning and when a width of -1 (DEFAULT_LINE_WIDTH) is
        requested.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.HPGL_PLOTTER_SetDefaultLineWidth(self, *args)

   def SetDash(self, *args):
        """
        SetDash(HPGL_PLOTTER self, bool dashed)

        void
        HPGL_PLOTTER::SetDash(bool dashed)

        HPGL supports dashed lines.
        """
        return _pcbnew.HPGL_PLOTTER_SetDash(self, *args)

   def SetColor(self, *args):
        """
        SetColor(HPGL_PLOTTER self, EDA_COLOR_T color)

        virtual void
        HPGL_PLOTTER::SetColor(EDA_COLOR_T color)
        """
        return _pcbnew.HPGL_PLOTTER_SetColor(self, *args)

   def SetPenSpeed(self, *args):
        """
        SetPenSpeed(HPGL_PLOTTER self, int speed)

        virtual void
        HPGL_PLOTTER::SetPenSpeed(int speed)
        """
        return _pcbnew.HPGL_PLOTTER_SetPenSpeed(self, *args)

   def SetPenNumber(self, *args):
        """
        SetPenNumber(HPGL_PLOTTER self, int number)

        virtual void
        HPGL_PLOTTER::SetPenNumber(int number)
        """
        return _pcbnew.HPGL_PLOTTER_SetPenNumber(self, *args)

   def SetPenDiameter(self, *args):
        """
        SetPenDiameter(HPGL_PLOTTER self, double diameter)

        virtual void
        HPGL_PLOTTER::SetPenDiameter(double diameter)
        """
        return _pcbnew.HPGL_PLOTTER_SetPenDiameter(self, *args)

   def SetPenOverlap(self, *args):
        """
        SetPenOverlap(HPGL_PLOTTER self, double overlap)

        virtual void
        HPGL_PLOTTER::SetPenOverlap(double overlap)
        """
        return _pcbnew.HPGL_PLOTTER_SetPenOverlap(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(HPGL_PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        void
        HPGL_PLOTTER::SetViewport(const wxPoint &aOffset, double
        aIusPerDecimil, double aScale, bool aMirror)

        Set the plot offset and scaling for the current plot.

        Parameters:
        -----------

        aOffset:  is the plot offset

        aIusPerDecimil:  gives the scaling factor from IUs to device units

        aScale:  is the user set plot scaling factor (either explicitly or
        using 'fit to A4')

        aMirror:  flips the plot in the Y direction (useful for toner
        transfers or some kind of film)
        """
        return _pcbnew.HPGL_PLOTTER_SetViewport(self, *args)

   def Rect(self, *args):
        """
        Rect(HPGL_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(HPGL_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        void
        HPGL_PLOTTER::Rect(const wxPoint &p1, const wxPoint &p2, FILL_T fill,
        int width=DEFAULT_LINE_WIDTH)

        HPGL rectangle: fill not supported.
        """
        return _pcbnew.HPGL_PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(HPGL_PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(HPGL_PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        void
        HPGL_PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill,
        int width=DEFAULT_LINE_WIDTH)

        HPGL circle: fill not supported.
        """
        return _pcbnew.HPGL_PLOTTER_Circle(self, *args)

   def PlotPoly(self, *args):
        """
        PlotPoly(HPGL_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(HPGL_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        void
        HPGL_PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList,
        FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)

        HPGL polygon: fill not supported (but closed, at least)
        """
        return _pcbnew.HPGL_PLOTTER_PlotPoly(self, *args)

   def ThickSegment(self, *args):
        """
        ThickSegment(HPGL_PLOTTER self, wxPoint start, wxPoint end, int width, EDA_DRAW_MODE_T tracemode)

        void
        HPGL_PLOTTER::ThickSegment(const wxPoint &start, const wxPoint &end,
        int width, EDA_DRAW_MODE_T tracemode)
        """
        return _pcbnew.HPGL_PLOTTER_ThickSegment(self, *args)

   def Arc(self, *args):
        """
        Arc(HPGL_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Arc(HPGL_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill)

        void
        HPGL_PLOTTER::Arc(const wxPoint &centre, double StAngle, double
        EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)

        Generic fallback: arc rendered as a polyline.
        """
        return _pcbnew.HPGL_PLOTTER_Arc(self, *args)

   def PenTo(self, *args):
        """
        PenTo(HPGL_PLOTTER self, wxPoint pos, char plume)

        void
        HPGL_PLOTTER::PenTo(const wxPoint &pos, char plume)

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.HPGL_PLOTTER_PenTo(self, *args)

   def FlashPadCircle(self, *args):
        """
        FlashPadCircle(HPGL_PLOTTER self, wxPoint pos, int diametre, EDA_DRAW_MODE_T trace_mode)

        void
        HPGL_PLOTTER::FlashPadCircle(const wxPoint &pos, int diametre,
        EDA_DRAW_MODE_T trace_mode)
        """
        return _pcbnew.HPGL_PLOTTER_FlashPadCircle(self, *args)

   def FlashPadOval(self, *args):
        """
        FlashPadOval(HPGL_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        HPGL_PLOTTER::FlashPadOval(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)
        """
        return _pcbnew.HPGL_PLOTTER_FlashPadOval(self, *args)

   def FlashPadRect(self, *args):
        """
        FlashPadRect(HPGL_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        HPGL_PLOTTER::FlashPadRect(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)
        """
        return _pcbnew.HPGL_PLOTTER_FlashPadRect(self, *args)

   def FlashPadTrapez(self, *args):
        """
        FlashPadTrapez(HPGL_PLOTTER self, wxPoint aPadPos, wxPoint aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        void
        HPGL_PLOTTER::FlashPadTrapez(const wxPoint &aPadPos, const wxPoint
        *aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        virtual function FlashPadTrapez flash a trapezoidal pad

        Parameters:
        -----------

        aPadPos:  = the position of the shape

        aCorners:  = the list of 4 corners positions, relative to the shape
        position, pad orientation 0

        aPadOrient:  = the rotation of the shape

        aTrace_Mode:  = FILLED or SKETCH
        """
        return _pcbnew.HPGL_PLOTTER_FlashPadTrapez(self, *args)

    __swig_destroy__ = _pcbnew.delete_HPGL_PLOTTER
    __del__ = lambda self : None;
HPGL_PLOTTER_swigregister = _pcbnew.HPGL_PLOTTER_swigregister
HPGL_PLOTTER_swigregister(HPGL_PLOTTER)

def HPGL_PLOTTER_GetDefaultFileExtension():
  """HPGL_PLOTTER_GetDefaultFileExtension() -> wxString"""
  return _pcbnew.HPGL_PLOTTER_GetDefaultFileExtension()

class PSLIKE_PLOTTER(PLOTTER):
    """
    The PSLIKE_PLOTTER class is an intermediate class to handle common
    routines for engines working more or less with the postscript imaging
    model.

    C++ includes: plot_common.h
    """
    __swig_setmethods__ = {}
    for _s in [PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PSLIKE_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PSLIKE_PLOTTER, name)
   def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
   def SetTextMode(self, *args):
        """
        SetTextMode(PSLIKE_PLOTTER self, PlotTextMode mode)

        virtual void
        PSLIKE_PLOTTER::SetTextMode(PlotTextMode mode)

        PS and PDF fully implement native text (for the Latin-1 subset)
        """
        return _pcbnew.PSLIKE_PLOTTER_SetTextMode(self, *args)

   def SetDefaultLineWidth(self, *args):
        """
        SetDefaultLineWidth(PSLIKE_PLOTTER self, int width)

        void
        PSLIKE_PLOTTER::SetDefaultLineWidth(int width)

       Set the default line width.

        Used at the beginning and when a width of -1 (DEFAULT_LINE_WIDTH) is
        requested.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.PSLIKE_PLOTTER_SetDefaultLineWidth(self, *args)

   def SetScaleAdjust(self, *args):
        """
        SetScaleAdjust(PSLIKE_PLOTTER self, double scaleX, double scaleY)

        void
        PSLIKE_PLOTTER::SetScaleAdjust(double scaleX, double scaleY)

        Set the 'fine' scaling for the postscript engine.
        """
        return _pcbnew.PSLIKE_PLOTTER_SetScaleAdjust(self, *args)

   def FlashPadCircle(self, *args):
        """
        FlashPadCircle(PSLIKE_PLOTTER self, wxPoint pos, int diametre, EDA_DRAW_MODE_T trace_mode)

        void
        PSLIKE_PLOTTER::FlashPadCircle(const wxPoint &pos, int diametre,
        EDA_DRAW_MODE_T trace_mode)
        """
        return _pcbnew.PSLIKE_PLOTTER_FlashPadCircle(self, *args)

   def FlashPadOval(self, *args):
        """
        FlashPadOval(PSLIKE_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        PSLIKE_PLOTTER::FlashPadOval(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)
        """
        return _pcbnew.PSLIKE_PLOTTER_FlashPadOval(self, *args)

   def FlashPadRect(self, *args):
        """
        FlashPadRect(PSLIKE_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        PSLIKE_PLOTTER::FlashPadRect(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)
        """
        return _pcbnew.PSLIKE_PLOTTER_FlashPadRect(self, *args)

   def FlashPadTrapez(self, *args):
        """
        FlashPadTrapez(PSLIKE_PLOTTER self, wxPoint aPadPos, wxPoint aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        void
        PSLIKE_PLOTTER::FlashPadTrapez(const wxPoint &aPadPos, const wxPoint
        *aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        virtual function FlashPadTrapez flash a trapezoidal pad

        Parameters:
        -----------

        aPadPos:  = the position of the shape

        aCorners:  = the list of 4 corners positions, relative to the shape
        position, pad orientation 0

        aPadOrient:  = the rotation of the shape

        aTrace_Mode:  = FILLED or SKETCH
        """
        return _pcbnew.PSLIKE_PLOTTER_FlashPadTrapez(self, *args)

   def SetColor(self, *args):
        """
        SetColor(PSLIKE_PLOTTER self, EDA_COLOR_T color)

        void
        PSLIKE_PLOTTER::SetColor(EDA_COLOR_T color)

        The SetColor implementation is split with the subclasses: The PSLIKE
        computes the rgb values, the subclass emits the operator to actually
        do it.
        """
        return _pcbnew.PSLIKE_PLOTTER_SetColor(self, *args)

    __swig_destroy__ = _pcbnew.delete_PSLIKE_PLOTTER
    __del__ = lambda self : None;
PSLIKE_PLOTTER_swigregister = _pcbnew.PSLIKE_PLOTTER_swigregister
PSLIKE_PLOTTER_swigregister(PSLIKE_PLOTTER)

class PS_PLOTTER(PSLIKE_PLOTTER):
    """C++ includes: plot_common.h """
    __swig_setmethods__ = {}
    for _s in [PSLIKE_PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PS_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PSLIKE_PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PS_PLOTTER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(PS_PLOTTER self) -> PS_PLOTTER

        PS_PLOTTER::PS_PLOTTER()
        """
        this = _pcbnew.new_PS_PLOTTER()
        try: self.this.append(this)
        except: self.this = this
   def GetDefaultFileExtension():
        """GetDefaultFileExtension() -> wxString"""
        return _pcbnew.PS_PLOTTER_GetDefaultFileExtension()

    if _newclass:GetDefaultFileExtension = staticmethod(GetDefaultFileExtension)
    __swig_getmethods__["GetDefaultFileExtension"] = lambda x: GetDefaultFileExtension
   def GetPlotterType(self):
        """
        GetPlotterType(PS_PLOTTER self) -> PlotFormat

        virtual PlotFormat
        PS_PLOTTER::GetPlotterType() const

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.PS_PLOTTER_GetPlotterType(self)

   def StartPlot(self):
        """
        StartPlot(PS_PLOTTER self) -> bool

        bool
        PS_PLOTTER::StartPlot()

        The code within this function (and the CloseFilePS function) creates
        postscript files whose contents comply with Adobe's Document
        Structuring Convention, as documented by assorted details described
        within the following URLs:

        http://en.wikipedia.org/wiki/Document_Structuring_Conventionshttp://pa
        rtners.adobe.com/public/developer/en/ps/5001.DSC_Spec.pdf

        BBox is the boundary box (position and size of the "client
        rectangle" for drawings (page - margins) in mils (0.001 inch)
        """
        return _pcbnew.PS_PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(PS_PLOTTER self) -> bool

        bool
        PS_PLOTTER::EndPlot()
        """
        return _pcbnew.PS_PLOTTER_EndPlot(self)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(PS_PLOTTER self, int width)

        void
        PS_PLOTTER::SetCurrentLineWidth(int width)

        Set the line width for the next drawing.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.PS_PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDash(self, *args):
        """
        SetDash(PS_PLOTTER self, bool dashed)

        void
        PS_PLOTTER::SetDash(bool dashed)

        Postscript supports dashed lines.
        """
        return _pcbnew.PS_PLOTTER_SetDash(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(PS_PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        void
        PS_PLOTTER::SetViewport(const wxPoint &aOffset, double aIusPerDecimil,
        double aScale, bool aMirror)

        Set the plot offset and scaling for the current plot.

        Parameters:
        -----------

        aOffset:  is the plot offset

        aIusPerDecimil:  gives the scaling factor from IUs to device units

        aScale:  is the user set plot scaling factor (either explicitly or
        using 'fit to A4')

        aMirror:  flips the plot in the Y direction (useful for toner
        transfers or some kind of film)
        """
        return _pcbnew.PS_PLOTTER_SetViewport(self, *args)

   def Rect(self, *args):
        """
        Rect(PS_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(PS_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        void PS_PLOTTER::Rect(const
        wxPoint &p1, const wxPoint &p2, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)
        """
        return _pcbnew.PS_PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(PS_PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(PS_PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        void
        PS_PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)
        """
        return _pcbnew.PS_PLOTTER_Circle(self, *args)

   def Arc(self, *args):
        """
        Arc(PS_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Arc(PS_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill)

        void PS_PLOTTER::Arc(const
        wxPoint &centre, double StAngle, double EndAngle, int rayon, FILL_T
        fill, int width=DEFAULT_LINE_WIDTH)

        Generic fallback: arc rendered as a polyline.
        """
        return _pcbnew.PS_PLOTTER_Arc(self, *args)

   def PlotPoly(self, *args):
        """
        PlotPoly(PS_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(PS_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        void
        PS_PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList, FILL_T
        aFill, int aWidth=DEFAULT_LINE_WIDTH)

        Function PlotPoly.

        Draw a polygon ( filled or not )

        Parameters:
        -----------

        aCornerList:  = corners list

        aFill:  = type of fill

        aWidth:  = line width
        """
        return _pcbnew.PS_PLOTTER_PlotPoly(self, *args)

   def PlotImage(self, *args):
        """
        PlotImage(PS_PLOTTER self, wxImage const & aImage, wxPoint aPos, double aScaleFactor)

        void
        PS_PLOTTER::PlotImage(const wxImage &aImage, const wxPoint &aPos,
        double aScaleFactor)

        Postscript-likes at the moment are the only plot engines supporting
        bitmaps...
        """
        return _pcbnew.PS_PLOTTER_PlotImage(self, *args)

   def PenTo(self, *args):
        """
        PenTo(PS_PLOTTER self, wxPoint pos, char plume)

        void
        PS_PLOTTER::PenTo(const wxPoint &pos, char plume)

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.PS_PLOTTER_PenTo(self, *args)

   def Text(self, *args):
        """
        Text(PS_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=False)
        Text(PS_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold)

        void PS_PLOTTER::Text(const
        wxPoint &aPos, enum EDA_COLOR_T aColor, const wxString &aText, double
        aOrient, const wxSize &aSize, enum EDA_TEXT_HJUSTIFY_T aH_justify,
        enum EDA_TEXT_VJUSTIFY_T aV_justify, int aWidth, bool aItalic, bool
        aBold, bool aMultilineAllowed=false)

        Draws text with the plotter.

        Function PlotGraphicText same as DrawGraphicText, but plot graphic
        text insteed of draw it.

        For convenience it accept the color to use

        Parameters:
        -----------

        aPos:  = text position (according to aH_justify, aV_justify)

        aColor:  (enum EDA_COLOR_T) = text color

        aText:  = text to draw

        aOrient:  = angle in 0.1 degree

        aSize:  = text size (size.x or size.y can be < 0 for mirrored texts)

        aH_justify:  = horizontal justification (Left, center, right)

        aV_justify:  = vertical justification (bottom, center, top)

        aWidth:  = line width (pen width) (default = 0) if width < 0 : draw
        segments in sketch mode, width = abs(width) Use a value min(aSize.x,
        aSize.y) / 5 for a bold text

        aItalic:  = true to simulate an italic font

       aBold:  = true to use a bold font Useful only with default width value
        (aWidth = 0)

        aMultilineAllowed:  = true to plot text as multiline, otherwise single
        line
        """
        return _pcbnew.PS_PLOTTER_Text(self, *args)

    __swig_destroy__ = _pcbnew.delete_PS_PLOTTER
    __del__ = lambda self : None;
PS_PLOTTER_swigregister = _pcbnew.PS_PLOTTER_swigregister
PS_PLOTTER_swigregister(PS_PLOTTER)

def PS_PLOTTER_GetDefaultFileExtension():
  """PS_PLOTTER_GetDefaultFileExtension() -> wxString"""
  return _pcbnew.PS_PLOTTER_GetDefaultFileExtension()

class PDF_PLOTTER(PSLIKE_PLOTTER):
    """C++ includes: plot_common.h """
    __swig_setmethods__ = {}
    for _s in [PSLIKE_PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PDF_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PSLIKE_PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PDF_PLOTTER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(PDF_PLOTTER self) -> PDF_PLOTTER

        PDF_PLOTTER::PDF_PLOTTER()
        """
        this = _pcbnew.new_PDF_PLOTTER()
        try: self.this.append(this)
        except: self.this = this
   def GetPlotterType(self):
        """
        GetPlotterType(PDF_PLOTTER self) -> PlotFormat

        virtual
        PlotFormat PDF_PLOTTER::GetPlotterType() const

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.PDF_PLOTTER_GetPlotterType(self)

   def GetDefaultFileExtension():
        """GetDefaultFileExtension() -> wxString"""
        return _pcbnew.PDF_PLOTTER_GetDefaultFileExtension()

    if _newclass:GetDefaultFileExtension = staticmethod(GetDefaultFileExtension)
    __swig_getmethods__["GetDefaultFileExtension"] = lambda x: GetDefaultFileExtension
   def OpenFile(self, *args):
        """
        OpenFile(PDF_PLOTTER self, wxString const & aFullFilename) -> bool

        bool
        PDF_PLOTTER::OpenFile(const wxString &aFullFilename)

        Open or create the plot file aFullFilename.

        Parameters:
        -----------

        aFullFilename:  = the full file name of the file to create

        true if success, false if the file cannot be created/opened  The base
        class open the file in text mode, so we should have this function
        overlaid for PDF files, which are binary files
        """
        return _pcbnew.PDF_PLOTTER_OpenFile(self, *args)

   def StartPlot(self):
        """
        StartPlot(PDF_PLOTTER self) -> bool

        bool
        PDF_PLOTTER::StartPlot()

        The PDF engine supports multiple pages; the first one is opened 'for
        free' the following are to be closed and reopened.

        Between each page parameters can be set
        """
        return _pcbnew.PDF_PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(PDF_PLOTTER self) -> bool

        bool
        PDF_PLOTTER::EndPlot()
        """
        return _pcbnew.PDF_PLOTTER_EndPlot(self)

   def StartPage(self):
        """
        StartPage(PDF_PLOTTER self)

        void
        PDF_PLOTTER::StartPage()

        Starts a new page in the PDF document.
        """
        return _pcbnew.PDF_PLOTTER_StartPage(self)

   def ClosePage(self):
        """
        ClosePage(PDF_PLOTTER self)

        void
        PDF_PLOTTER::ClosePage()

        Close the current page in the PDF document (and emit its compressed
        stream)
        """
        return _pcbnew.PDF_PLOTTER_ClosePage(self)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(PDF_PLOTTER self, int width)

        void
        PDF_PLOTTER::SetCurrentLineWidth(int width)

        Pen width setting for PDF.

        Since the specs explicitly says that a 0 width is a bad thing to use
        (since it results in 1 pixel traces), we convert such requests to the
       default width (like -1)
        """
        return _pcbnew.PDF_PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDash(self, *args):
        """
        SetDash(PDF_PLOTTER self, bool dashed)

        void
        PDF_PLOTTER::SetDash(bool dashed)

        PDF supports dashed lines.
        """
        return _pcbnew.PDF_PLOTTER_SetDash(self, *args)

   def SetPageSettings(self, *args):
        """
        SetPageSettings(PDF_PLOTTER self, PAGE_INFO const & aPageSettings)

        void
        PDF_PLOTTER::SetPageSettings(const PAGE_INFO &aPageSettings)

        PDF can have multiple pages, so SetPageSettings can be called with the
        outputFile open (but not inside a page stream!)
        """
        return _pcbnew.PDF_PLOTTER_SetPageSettings(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(PDF_PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        void
        PDF_PLOTTER::SetViewport(const wxPoint &aOffset, double
        aIusPerDecimil, double aScale, bool aMirror)

        Set the plot offset and scaling for the current plot.

        Parameters:
        -----------

        aOffset:  is the plot offset

        aIusPerDecimil:  gives the scaling factor from IUs to device units

        aScale:  is the user set plot scaling factor (either explicitly or
        using 'fit to A4')

        aMirror:  flips the plot in the Y direction (useful for toner
        transfers or some kind of film)
        """
        return _pcbnew.PDF_PLOTTER_SetViewport(self, *args)

   def Rect(self, *args):
        """
        Rect(PDF_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(PDF_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        void
        PDF_PLOTTER::Rect(const wxPoint &p1, const wxPoint &p2, FILL_T fill,
        int width=DEFAULT_LINE_WIDTH)

        Rectangles in PDF.

        Supported by the native operator
        """
        return _pcbnew.PDF_PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(PDF_PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(PDF_PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        void
        PDF_PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)

        Circle drawing for PDF.

        They're approximated by curves, but fill is supported
        """
        return _pcbnew.PDF_PLOTTER_Circle(self, *args)

   def Arc(self, *args):
        """
        Arc(PDF_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Arc(PDF_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill)

        void PDF_PLOTTER::Arc(const
        wxPoint &centre, double StAngle, double EndAngle, int rayon, FILL_T
        fill, int width=DEFAULT_LINE_WIDTH)

        The PDF engine can't directly plot arcs, it uses the base emulation.

        So no filled arcs (not a great loss... )
        """
        return _pcbnew.PDF_PLOTTER_Arc(self, *args)

   def PlotPoly(self, *args):
        """
        PlotPoly(PDF_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(PDF_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        void
        PDF_PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList,
        FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)

        Polygon plotting for PDF.

        Everything is supported
        """
        return _pcbnew.PDF_PLOTTER_PlotPoly(self, *args)

   def PenTo(self, *args):
        """
        PenTo(PDF_PLOTTER self, wxPoint pos, char plume)

        void
        PDF_PLOTTER::PenTo(const wxPoint &pos, char plume)

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.PDF_PLOTTER_PenTo(self, *args)

   def Text(self, *args):
        """
        Text(PDF_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=False)
        Text(PDF_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold)

        void
        PDF_PLOTTER::Text(const wxPoint &aPos, enum EDA_COLOR_T aColor, const
        wxString &aText, double aOrient, const wxSize &aSize, enum
        EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
        int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=false)

        Draws text with the plotter.

        Function PlotGraphicText same as DrawGraphicText, but plot graphic
        text insteed of draw it.

        For convenience it accept the color to use

        Parameters:
        -----------

        aPos:  = text position (according to aH_justify, aV_justify)

        aColor:  (enum EDA_COLOR_T) = text color

        aText:  = text to draw

        aOrient:  = angle in 0.1 degree

        aSize:  = text size (size.x or size.y can be < 0 for mirrored texts)

        aH_justify:  = horizontal justification (Left, center, right)

        aV_justify:  = vertical justification (bottom, center, top)

        aWidth:  = line width (pen width) (default = 0) if width < 0 : draw
        segments in sketch mode, width = abs(width) Use a value min(aSize.x,
        aSize.y) / 5 for a bold text

        aItalic:  = true to simulate an italic font

       aBold:  = true to use a bold font Useful only with default width value
        (aWidth = 0)

        aMultilineAllowed:  = true to plot text as multiline, otherwise single
        line
        """
        return _pcbnew.PDF_PLOTTER_Text(self, *args)

   def PlotImage(self, *args):
        """
        PlotImage(PDF_PLOTTER self, wxImage const & aImage, wxPoint aPos, double aScaleFactor)

        void
        PDF_PLOTTER::PlotImage(const wxImage &aImage, const wxPoint &aPos,
        double aScaleFactor)

        PDF images are handles as inline, not XObject streams...
        """
        return _pcbnew.PDF_PLOTTER_PlotImage(self, *args)

    __swig_destroy__ = _pcbnew.delete_PDF_PLOTTER
    __del__ = lambda self : None;
PDF_PLOTTER_swigregister = _pcbnew.PDF_PLOTTER_swigregister
PDF_PLOTTER_swigregister(PDF_PLOTTER)

def PDF_PLOTTER_GetDefaultFileExtension():
  """PDF_PLOTTER_GetDefaultFileExtension() -> wxString"""
  return _pcbnew.PDF_PLOTTER_GetDefaultFileExtension()

class SVG_PLOTTER(PSLIKE_PLOTTER):
    """C++ includes: plot_common.h """
    __swig_setmethods__ = {}
    for _s in [PSLIKE_PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SVG_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PSLIKE_PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, SVG_PLOTTER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(SVG_PLOTTER self) -> SVG_PLOTTER

        SVG_PLOTTER::SVG_PLOTTER()
        """
        this = _pcbnew.new_SVG_PLOTTER()
        try: self.this.append(this)
        except: self.this = this
   def GetDefaultFileExtension():
        """GetDefaultFileExtension() -> wxString"""
        return _pcbnew.SVG_PLOTTER_GetDefaultFileExtension()

    if _newclass:GetDefaultFileExtension = staticmethod(GetDefaultFileExtension)
    __swig_getmethods__["GetDefaultFileExtension"] = lambda x: GetDefaultFileExtension
   def GetPlotterType(self):
        """
        GetPlotterType(SVG_PLOTTER self) -> PlotFormat

        virtual
        PlotFormat SVG_PLOTTER::GetPlotterType() const

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.SVG_PLOTTER_GetPlotterType(self)

   def SetColor(self, *args):
        """
        SetColor(SVG_PLOTTER self, EDA_COLOR_T color)

        void
        SVG_PLOTTER::SetColor(EDA_COLOR_T color)

        The SetColor implementation is split with the subclasses: The PSLIKE
        computes the rgb values, the subclass emits the operator to actually
        do it.
        """
        return _pcbnew.SVG_PLOTTER_SetColor(self, *args)

   def StartPlot(self):
        """
        StartPlot(SVG_PLOTTER self) -> bool

        bool
        SVG_PLOTTER::StartPlot()

        The code within this function creates SVG files header.
        """
        return _pcbnew.SVG_PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(SVG_PLOTTER self) -> bool

        bool
        SVG_PLOTTER::EndPlot()
        """
        return _pcbnew.SVG_PLOTTER_EndPlot(self)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(SVG_PLOTTER self, int width)

        void
        SVG_PLOTTER::SetCurrentLineWidth(int width)

        Set the line width for the next drawing.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.SVG_PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDash(self, *args):
        """
        SetDash(SVG_PLOTTER self, bool dashed)

        void
        SVG_PLOTTER::SetDash(bool dashed)

        SVG supports dashed lines.
        """
        return _pcbnew.SVG_PLOTTER_SetDash(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(SVG_PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        void
        SVG_PLOTTER::SetViewport(const wxPoint &aOffset, double
        aIusPerDecimil, double aScale, bool aMirror)

        Set the plot offset and scaling for the current plot.

        Parameters:
        -----------

        aOffset:  is the plot offset

        aIusPerDecimil:  gives the scaling factor from IUs to device units

        aScale:  is the user set plot scaling factor (either explicitly or
        using 'fit to A4')

        aMirror:  flips the plot in the Y direction (useful for toner
        transfers or some kind of film)
        """
        return _pcbnew.SVG_PLOTTER_SetViewport(self, *args)

   def Rect(self, *args):
        """
        Rect(SVG_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(SVG_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        void
        SVG_PLOTTER::Rect(const wxPoint &p1, const wxPoint &p2, FILL_T fill,
        int width=DEFAULT_LINE_WIDTH)
        """
        return _pcbnew.SVG_PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(SVG_PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(SVG_PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        void
        SVG_PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)
        """
        return _pcbnew.SVG_PLOTTER_Circle(self, *args)

   def Arc(self, *args):
        """
        Arc(SVG_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Arc(SVG_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill)

        void SVG_PLOTTER::Arc(const
        wxPoint &centre, double StAngle, double EndAngle, int rayon, FILL_T
        fill, int width=DEFAULT_LINE_WIDTH)

        Generic fallback: arc rendered as a polyline.
        """
        return _pcbnew.SVG_PLOTTER_Arc(self, *args)

   def PlotPoly(self, *args):
        """
        PlotPoly(SVG_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(SVG_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        void
        SVG_PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList,
        FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)

        Function PlotPoly.

        Draw a polygon ( filled or not )

        Parameters:
        -----------

        aCornerList:  = corners list

        aFill:  = type of fill

        aWidth:  = line width
        """
        return _pcbnew.SVG_PLOTTER_PlotPoly(self, *args)

   def PlotImage(self, *args):
        """
        PlotImage(SVG_PLOTTER self, wxImage const & aImage, wxPoint aPos, double aScaleFactor)

        void
        SVG_PLOTTER::PlotImage(const wxImage &aImage, const wxPoint &aPos,
        double aScaleFactor)

        Postscript-likes at the moment are the only plot engines supporting
        bitmaps...
        """
        return _pcbnew.SVG_PLOTTER_PlotImage(self, *args)

   def PenTo(self, *args):
        """
        PenTo(SVG_PLOTTER self, wxPoint pos, char plume)

        void
        SVG_PLOTTER::PenTo(const wxPoint &pos, char plume)

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.SVG_PLOTTER_PenTo(self, *args)

   def Text(self, *args):
        """
        Text(SVG_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=False)
        Text(SVG_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold)

        void
        SVG_PLOTTER::Text(const wxPoint &aPos, enum EDA_COLOR_T aColor, const
        wxString &aText, double aOrient, const wxSize &aSize, enum
        EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
        int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=false)

        Draws text with the plotter.

        Function PlotGraphicText same as DrawGraphicText, but plot graphic
        text insteed of draw it.

        For convenience it accept the color to use

        Parameters:
        -----------

        aPos:  = text position (according to aH_justify, aV_justify)

        aColor:  (enum EDA_COLOR_T) = text color

        aText:  = text to draw

        aOrient:  = angle in 0.1 degree

        aSize:  = text size (size.x or size.y can be < 0 for mirrored texts)

        aH_justify:  = horizontal justification (Left, center, right)

        aV_justify:  = vertical justification (bottom, center, top)

        aWidth:  = line width (pen width) (default = 0) if width < 0 : draw
        segments in sketch mode, width = abs(width) Use a value min(aSize.x,
        aSize.y) / 5 for a bold text

        aItalic:  = true to simulate an italic font

       aBold:  = true to use a bold font Useful only with default width value
        (aWidth = 0)

        aMultilineAllowed:  = true to plot text as multiline, otherwise single
        line
        """
        return _pcbnew.SVG_PLOTTER_Text(self, *args)

    __swig_destroy__ = _pcbnew.delete_SVG_PLOTTER
    __del__ = lambda self : None;
SVG_PLOTTER_swigregister = _pcbnew.SVG_PLOTTER_swigregister
SVG_PLOTTER_swigregister(SVG_PLOTTER)

def SVG_PLOTTER_GetDefaultFileExtension():
  """SVG_PLOTTER_GetDefaultFileExtension() -> wxString"""
  return _pcbnew.SVG_PLOTTER_GetDefaultFileExtension()

FIRST_DCODE_VALUE = _pcbnew.FIRST_DCODE_VALUE
class APERTURE(_object):
    """Proxy of C++ APERTURE class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, APERTURE, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, APERTURE, name)
    __repr__ = _swig_repr
    Circle = _pcbnew.APERTURE_Circle
    Rect = _pcbnew.APERTURE_Rect
    Plotting = _pcbnew.APERTURE_Plotting
    Oval = _pcbnew.APERTURE_Oval
    __swig_setmethods__["Size"] = _pcbnew.APERTURE_Size_set
    __swig_getmethods__["Size"] = _pcbnew.APERTURE_Size_get
    if _newclass:Size = _swig_property(_pcbnew.APERTURE_Size_get, _pcbnew.APERTURE_Size_set)
    __swig_setmethods__["Type"] = _pcbnew.APERTURE_Type_set
    __swig_getmethods__["Type"] = _pcbnew.APERTURE_Type_get
    if _newclass:Type = _swig_property(_pcbnew.APERTURE_Type_get, _pcbnew.APERTURE_Type_set)
    __swig_setmethods__["DCode"] = _pcbnew.APERTURE_DCode_set
    __swig_getmethods__["DCode"] = _pcbnew.APERTURE_DCode_get
    if _newclass:DCode = _swig_property(_pcbnew.APERTURE_DCode_get, _pcbnew.APERTURE_DCode_set)
   def __init__(self):
        """__init__(APERTURE self) -> APERTURE"""
        this = _pcbnew.new_APERTURE()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_APERTURE
    __del__ = lambda self : None;
APERTURE_swigregister = _pcbnew.APERTURE_swigregister
APERTURE_swigregister(APERTURE)

class GERBER_PLOTTER(PLOTTER):
    """C++ includes: plot_common.h """
    __swig_setmethods__ = {}
    for _s in [PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, GERBER_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, GERBER_PLOTTER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(GERBER_PLOTTER self) -> GERBER_PLOTTER

        GERBER_PLOTTER::GERBER_PLOTTER()
        """
        this = _pcbnew.new_GERBER_PLOTTER()
        try: self.this.append(this)
        except: self.this = this
   def GetPlotterType(self):
        """
        GetPlotterType(GERBER_PLOTTER self) -> PlotFormat

        virtual
        PlotFormat GERBER_PLOTTER::GetPlotterType() const

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.GERBER_PLOTTER_GetPlotterType(self)

   def GetDefaultFileExtension():
        """GetDefaultFileExtension() -> wxString"""
        return _pcbnew.GERBER_PLOTTER_GetDefaultFileExtension()

    if _newclass:GetDefaultFileExtension = staticmethod(GetDefaultFileExtension)
    __swig_getmethods__["GetDefaultFileExtension"] = lambda x: GetDefaultFileExtension
   def StartPlot(self):
        """
        StartPlot(GERBER_PLOTTER self) -> bool

        bool
        GERBER_PLOTTER::StartPlot()

        Function StartPlot Write GERBER header to file initialize global
        variable g_Plot_PlotOutputFile.
        """
        return _pcbnew.GERBER_PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(GERBER_PLOTTER self) -> bool

        bool
        GERBER_PLOTTER::EndPlot()
        """
        return _pcbnew.GERBER_PLOTTER_EndPlot(self)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(GERBER_PLOTTER self, int width)

        void
        GERBER_PLOTTER::SetCurrentLineWidth(int width)

        Set the line width for the next drawing.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.GERBER_PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDefaultLineWidth(self, *args):
        """
        SetDefaultLineWidth(GERBER_PLOTTER self, int width)

        void
        GERBER_PLOTTER::SetDefaultLineWidth(int width)

       Set the default line width.

        Used at the beginning and when a width of -1 (DEFAULT_LINE_WIDTH) is
        requested.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.GERBER_PLOTTER_SetDefaultLineWidth(self, *args)

   def SetDash(self, *args):
        """
        SetDash(GERBER_PLOTTER self, bool dashed)

        virtual void
        GERBER_PLOTTER::SetDash(bool dashed)
        """
        return _pcbnew.GERBER_PLOTTER_SetDash(self, *args)

   def SetColor(self, *args):
        """
        SetColor(GERBER_PLOTTER self, EDA_COLOR_T color)

        virtual void
        GERBER_PLOTTER::SetColor(EDA_COLOR_T color)
        """
        return _pcbnew.GERBER_PLOTTER_SetColor(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(GERBER_PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        void
        GERBER_PLOTTER::SetViewport(const wxPoint &aOffset, double
        aIusPerDecimil, double aScale, bool aMirror)

        Set the plot offset and scaling for the current plot.

        Parameters:
        -----------

        aOffset:  is the plot offset

        aIusPerDecimil:  gives the scaling factor from IUs to device units

        aScale:  is the user set plot scaling factor (either explicitly or
        using 'fit to A4')

        aMirror:  flips the plot in the Y direction (useful for toner
        transfers or some kind of film)
        """
        return _pcbnew.GERBER_PLOTTER_SetViewport(self, *args)

   def Rect(self, *args):
        """
        Rect(GERBER_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(GERBER_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        void
        GERBER_PLOTTER::Rect(const wxPoint &p1, const wxPoint &p2, FILL_T
        fill, int width=DEFAULT_LINE_WIDTH)
        """
        return _pcbnew.GERBER_PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(GERBER_PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(GERBER_PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        void
        GERBER_PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill,
        int width=DEFAULT_LINE_WIDTH)
        """
        return _pcbnew.GERBER_PLOTTER_Circle(self, *args)

   def Arc(self, *args):
        """
        Arc(GERBER_PLOTTER self, wxPoint aCenter, double aStAngle, double aEndAngle, int aRadius, FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)
        Arc(GERBER_PLOTTER self, wxPoint aCenter, double aStAngle, double aEndAngle, int aRadius, FILL_T aFill)

        void
        GERBER_PLOTTER::Arc(const wxPoint &aCenter, double aStAngle, double
        aEndAngle, int aRadius, FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)

        Generic fallback: arc rendered as a polyline.
        """
        return _pcbnew.GERBER_PLOTTER_Arc(self, *args)

   def PlotPoly(self, *args):
        """
        PlotPoly(GERBER_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(GERBER_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        void
        GERBER_PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList,
        FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)

        Gerber polygon: they can (and should) be filled with the appropriate
        G36/G37 sequence.
        """
        return _pcbnew.GERBER_PLOTTER_PlotPoly(self, *args)

   def PenTo(self, *args):
        """
        PenTo(GERBER_PLOTTER self, wxPoint pos, char plume)

        void
        GERBER_PLOTTER::PenTo(const wxPoint &pos, char plume)

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.GERBER_PLOTTER_PenTo(self, *args)

   def FlashPadCircle(self, *args):
        """
        FlashPadCircle(GERBER_PLOTTER self, wxPoint pos, int diametre, EDA_DRAW_MODE_T trace_mode)

        void
        GERBER_PLOTTER::FlashPadCircle(const wxPoint &pos, int diametre,
        EDA_DRAW_MODE_T trace_mode)

        Filled circular flashes are stored as apertures.
        """
        return _pcbnew.GERBER_PLOTTER_FlashPadCircle(self, *args)

   def FlashPadOval(self, *args):
        """
        FlashPadOval(GERBER_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        GERBER_PLOTTER::FlashPadOval(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)

        Filled oval flashes are handled as aperture in the 90 degree positions
        only.
        """
        return _pcbnew.GERBER_PLOTTER_FlashPadOval(self, *args)

   def FlashPadRect(self, *args):
        """
        FlashPadRect(GERBER_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        GERBER_PLOTTER::FlashPadRect(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)

        Filled rect flashes are handled as aperture in the 90 degree positions
        only.
        """
        return _pcbnew.GERBER_PLOTTER_FlashPadRect(self, *args)

   def FlashPadTrapez(self, *args):
        """
        FlashPadTrapez(GERBER_PLOTTER self, wxPoint aPadPos, wxPoint aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        void
        GERBER_PLOTTER::FlashPadTrapez(const wxPoint &aPadPos, const wxPoint
        *aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        Trapezoidal pad at the moment are never handled as aperture, since
        they require aperture macros.
        """
        return _pcbnew.GERBER_PLOTTER_FlashPadTrapez(self, *args)

   def SetLayerPolarity(self, *args):
        """
        SetLayerPolarity(GERBER_PLOTTER self, bool aPositive)

        void
        GERBER_PLOTTER::SetLayerPolarity(bool aPositive)

        Change the plot polarity and begin a new layer Used to 'scratch off'
        silk screen away from solder mask.
        """
        return _pcbnew.GERBER_PLOTTER_SetLayerPolarity(self, *args)

   def SetLayerAttribFunction(self, *args):
        """
        SetLayerAttribFunction(GERBER_PLOTTER self, wxString const & function)

        virtual void GERBER_PLOTTER::SetLayerAttribFunction(const wxString
        &function)
        """
        return _pcbnew.GERBER_PLOTTER_SetLayerAttribFunction(self, *args)

   def SetGerberCoordinatesFormat(self, *args):
        """
        SetGerberCoordinatesFormat(GERBER_PLOTTER self, int aResolution, bool aUseInches=False)
        SetGerberCoordinatesFormat(GERBER_PLOTTER self, int aResolution)

        void GERBER_PLOTTER::SetGerberCoordinatesFormat(int aResolution, bool
        aUseInches=false)

        Function SetGerberCoordinatesFormat selection of Gerber units and
        resolution (number of digits in mantissa)

        Parameters:
        -----------

        aResolution:  = number of digits in mantissa of coordinate use 5 or 6
        for mm and 6 or 7 for inches do not use value > 6 (mm) or > 7 (in) to
        avoid overflow

        aUseInches:  = true to use inches, false to use mm (default)

        Should be called only after SetViewport() is called
        """
        return _pcbnew.GERBER_PLOTTER_SetGerberCoordinatesFormat(self, *args)

    __swig_destroy__ = _pcbnew.delete_GERBER_PLOTTER
    __del__ = lambda self : None;
GERBER_PLOTTER_swigregister = _pcbnew.GERBER_PLOTTER_swigregister
GERBER_PLOTTER_swigregister(GERBER_PLOTTER)

def GERBER_PLOTTER_GetDefaultFileExtension():
  """GERBER_PLOTTER_GetDefaultFileExtension() -> wxString"""
  return _pcbnew.GERBER_PLOTTER_GetDefaultFileExtension()

class DXF_PLOTTER(PLOTTER):
    """C++ includes: plot_common.h """
    __swig_setmethods__ = {}
    for _s in [PLOTTER]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DXF_PLOTTER, name, value)
    __swig_getmethods__ = {}
    for _s in [PLOTTER]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, DXF_PLOTTER, name)
    __repr__ = _swig_repr
   def __init__(self):
        """
        __init__(DXF_PLOTTER self) -> DXF_PLOTTER

        DXF_PLOTTER::DXF_PLOTTER()
        """
        this = _pcbnew.new_DXF_PLOTTER()
        try: self.this.append(this)
        except: self.this = this
   def GetPlotterType(self):
        """
        GetPlotterType(DXF_PLOTTER self) -> PlotFormat

        virtual
        PlotFormat DXF_PLOTTER::GetPlotterType() const

        Returns the effective plot engine in use.

        It's not very OO but for now is required since some things are only
        done with some output devices (like drill marks, emitted only for
        postscript
        """
        return _pcbnew.DXF_PLOTTER_GetPlotterType(self)

   def GetDefaultFileExtension():
        """GetDefaultFileExtension() -> wxString"""
        return _pcbnew.DXF_PLOTTER_GetDefaultFileExtension()

    if _newclass:GetDefaultFileExtension = staticmethod(GetDefaultFileExtension)
    __swig_getmethods__["GetDefaultFileExtension"] = lambda x: GetDefaultFileExtension
   def SetTextMode(self, *args):
        """
        SetTextMode(DXF_PLOTTER self, PlotTextMode mode)

        virtual void
        DXF_PLOTTER::SetTextMode(PlotTextMode mode)

        DXF handles NATIVE text emitting TEXT entities.
        """
        return _pcbnew.DXF_PLOTTER_SetTextMode(self, *args)

   def StartPlot(self):
        """
        StartPlot(DXF_PLOTTER self) -> bool

        bool
        DXF_PLOTTER::StartPlot()

        Opens the DXF plot with a skeleton header.
        """
        return _pcbnew.DXF_PLOTTER_StartPlot(self)

   def EndPlot(self):
        """
        EndPlot(DXF_PLOTTER self) -> bool

        bool
        DXF_PLOTTER::EndPlot()
        """
        return _pcbnew.DXF_PLOTTER_EndPlot(self)

   def SetCurrentLineWidth(self, *args):
        """
        SetCurrentLineWidth(DXF_PLOTTER self, int width)

        virtual void
        DXF_PLOTTER::SetCurrentLineWidth(int width)

        Set the line width for the next drawing.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.DXF_PLOTTER_SetCurrentLineWidth(self, *args)

   def SetDefaultLineWidth(self, *args):
        """
        SetDefaultLineWidth(DXF_PLOTTER self, int width)

        virtual void
        DXF_PLOTTER::SetDefaultLineWidth(int width)

       Set the default line width.

        Used at the beginning and when a width of -1 (DEFAULT_LINE_WIDTH) is
        requested.

        Parameters:
        -----------

        width:  is specified in IUs
        """
        return _pcbnew.DXF_PLOTTER_SetDefaultLineWidth(self, *args)

   def SetDash(self, *args):
        """
        SetDash(DXF_PLOTTER self, bool dashed)

        void
        DXF_PLOTTER::SetDash(bool dashed)

        Dashed lines are not (yet) supported by DXF_PLOTTER.
        """
        return _pcbnew.DXF_PLOTTER_SetDash(self, *args)

   def SetColor(self, *args):
        """
        SetColor(DXF_PLOTTER self, EDA_COLOR_T color)

        void
        DXF_PLOTTER::SetColor(EDA_COLOR_T color)

        The DXF exporter handles 'colors' as layers...
        """
        return _pcbnew.DXF_PLOTTER_SetColor(self, *args)

   def SetViewport(self, *args):
        """
        SetViewport(DXF_PLOTTER self, wxPoint aOffset, double aIusPerDecimil, double aScale, bool aMirror)

        void
        DXF_PLOTTER::SetViewport(const wxPoint &aOffset, double
        aIusPerDecimil, double aScale, bool aMirror)

        Set the scale/position for the DXF plot The DXF engine doesn't support
        line widths and mirroring.

        The output coordinate system is in the first quadrant (in mm)
        """
        return _pcbnew.DXF_PLOTTER_SetViewport(self, *args)

   def Rect(self, *args):
        """
        Rect(DXF_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Rect(DXF_PLOTTER self, wxPoint p1, wxPoint p2, FILL_T fill)

        void
        DXF_PLOTTER::Rect(const wxPoint &p1, const wxPoint &p2, FILL_T fill,
        int width=DEFAULT_LINE_WIDTH)

        DXF rectangle: fill not supported.
        """
        return _pcbnew.DXF_PLOTTER_Rect(self, *args)

   def Circle(self, *args):
        """
        Circle(DXF_PLOTTER self, wxPoint pos, int diametre, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Circle(DXF_PLOTTER self, wxPoint pos, int diametre, FILL_T fill)

        void
        DXF_PLOTTER::Circle(const wxPoint &pos, int diametre, FILL_T fill, int
        width=DEFAULT_LINE_WIDTH)

        DXF circle: full functionality; it even does 'fills' drawing a circle
        with a dual-arc polyline wide as the radius.

        I could use this trick to do other filled primitives
        """
        return _pcbnew.DXF_PLOTTER_Circle(self, *args)

   def PlotPoly(self, *args):
        """
        PlotPoly(DXF_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill,
            int aWidth=DEFAULT_LINE_WIDTH)
        PlotPoly(DXF_PLOTTER self, std::vector< wxPoint,std::allocator< wxPoint > > const & aCornerList, FILL_T aFill)

        void
        DXF_PLOTTER::PlotPoly(const std::vector< wxPoint > &aCornerList,
        FILL_T aFill, int aWidth=DEFAULT_LINE_WIDTH)

        DXF polygon: doesn't fill it but at least it close the filled ones DXF
        does not know thick outline.

        It does not know thhick segments, therefore filled polygons with thick
        outline are converted to inflated polygon by aWidth/2
        """
        return _pcbnew.DXF_PLOTTER_PlotPoly(self, *args)

   def ThickSegment(self, *args):
        """
        ThickSegment(DXF_PLOTTER self, wxPoint start, wxPoint end, int width, EDA_DRAW_MODE_T tracemode)

        void
        DXF_PLOTTER::ThickSegment(const wxPoint &start, const wxPoint &end,
        int width, EDA_DRAW_MODE_T tracemode)
        """
        return _pcbnew.DXF_PLOTTER_ThickSegment(self, *args)

   def Arc(self, *args):
        """
        Arc(DXF_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill, int width=DEFAULT_LINE_WIDTH)
        Arc(DXF_PLOTTER self, wxPoint centre, double StAngle, double EndAngle, int rayon, FILL_T fill)

        void DXF_PLOTTER::Arc(const
        wxPoint &centre, double StAngle, double EndAngle, int rayon, FILL_T
        fill, int width=DEFAULT_LINE_WIDTH)

        Generic fallback: arc rendered as a polyline.
        """
        return _pcbnew.DXF_PLOTTER_Arc(self, *args)

   def PenTo(self, *args):
        """
        PenTo(DXF_PLOTTER self, wxPoint pos, char plume)

        void
        DXF_PLOTTER::PenTo(const wxPoint &pos, char plume)

        moveto/lineto primitive, moves the 'pen' to the specified direction

        Parameters:
        -----------

        pos:  is the target position

        plume:  specifies the kind of motion: 'U' only moves the pen, 'D' draw
        a line from the current position and 'Z' finish the drawing and
        returns the 'pen' to rest (flushes the trace)
        """
        return _pcbnew.DXF_PLOTTER_PenTo(self, *args)

   def FlashPadCircle(self, *args):
        """
        FlashPadCircle(DXF_PLOTTER self, wxPoint pos, int diametre, EDA_DRAW_MODE_T trace_mode)

        void
        DXF_PLOTTER::FlashPadCircle(const wxPoint &pos, int diametre,
        EDA_DRAW_MODE_T trace_mode)

        DXF round pad: always done in sketch mode; it could be filled but it
        isn't pretty if other kinds of pad aren't...
        """
        return _pcbnew.DXF_PLOTTER_FlashPadCircle(self, *args)

   def FlashPadOval(self, *args):
        """
        FlashPadOval(DXF_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        DXF_PLOTTER::FlashPadOval(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)

        DXF oval pad: always done in sketch mode.
        """
        return _pcbnew.DXF_PLOTTER_FlashPadOval(self, *args)

   def FlashPadRect(self, *args):
        """
        FlashPadRect(DXF_PLOTTER self, wxPoint pos, wxSize size, double orient, EDA_DRAW_MODE_T trace_mode)

        void
        DXF_PLOTTER::FlashPadRect(const wxPoint &pos, const wxSize &size,
        double orient, EDA_DRAW_MODE_T trace_mode)

        DXF rectangular pad: alwayd done in sketch mode.
        """
        return _pcbnew.DXF_PLOTTER_FlashPadRect(self, *args)

   def FlashPadTrapez(self, *args):
        """
        FlashPadTrapez(DXF_PLOTTER self, wxPoint aPadPos, wxPoint aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        void
        DXF_PLOTTER::FlashPadTrapez(const wxPoint &aPadPos, const wxPoint
        *aCorners, double aPadOrient, EDA_DRAW_MODE_T aTrace_Mode)

        DXF trapezoidal pad: only sketch mode is supported.
        """
        return _pcbnew.DXF_PLOTTER_FlashPadTrapez(self, *args)

   def Text(self, *args):
        """
        Text(DXF_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=False)
        Text(DXF_PLOTTER self, wxPoint aPos, enum EDA_COLOR_T aColor, wxString const & aText, double aOrient, wxSize aSize,
            enum EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
            int aWidth, bool aItalic, bool aBold)

        void
        DXF_PLOTTER::Text(const wxPoint &aPos, enum EDA_COLOR_T aColor, const
        wxString &aText, double aOrient, const wxSize &aSize, enum
        EDA_TEXT_HJUSTIFY_T aH_justify, enum EDA_TEXT_VJUSTIFY_T aV_justify,
        int aWidth, bool aItalic, bool aBold, bool aMultilineAllowed=false)

        Draws text with the plotter.

        Function PlotGraphicText same as DrawGraphicText, but plot graphic
        text insteed of draw it.

        For convenience it accept the color to use

        Parameters:
        -----------

        aPos:  = text position (according to aH_justify, aV_justify)

        aColor:  (enum EDA_COLOR_T) = text color

        aText:  = text to draw

        aOrient:  = angle in 0.1 degree

        aSize:  = text size (size.x or size.y can be < 0 for mirrored texts)

        aH_justify:  = horizontal justification (Left, center, right)

        aV_justify:  = vertical justification (bottom, center, top)

        aWidth:  = line width (pen width) (default = 0) if width < 0 : draw
        segments in sketch mode, width = abs(width) Use a value min(aSize.x,
        aSize.y) / 5 for a bold text

        aItalic:  = true to simulate an italic font

       aBold:  = true to use a bold font Useful only with default width value
        (aWidth = 0)

        aMultilineAllowed:  = true to plot text as multiline, otherwise single
        line
        """
        return _pcbnew.DXF_PLOTTER_Text(self, *args)

    __swig_destroy__ = _pcbnew.delete_DXF_PLOTTER
    __del__ = lambda self : None;
DXF_PLOTTER_swigregister = _pcbnew.DXF_PLOTTER_swigregister
DXF_PLOTTER_swigregister(DXF_PLOTTER)

def DXF_PLOTTER_GetDefaultFileExtension():
  """DXF_PLOTTER_GetDefaultFileExtension() -> wxString"""
  return _pcbnew.DXF_PLOTTER_GetDefaultFileExtension()


def PlotWorkSheet(*args):
  """
    PlotWorkSheet(PLOTTER plotter, TITLE_BLOCK aTitleBlock, PAGE_INFO const & aPageInfo, int aSheetNumber,
        int aNumberOfSheets, wxString const & aSheetDesc, wxString const & aFilename)
    """
  return _pcbnew.PlotWorkSheet(*args)

def GetDefaultPlotExtension(*args):
  """GetDefaultPlotExtension(PlotFormat aFormat) -> wxString"""
  return _pcbnew.GetDefaultPlotExtension(*args)
UNSPECIFIED_COLOR = _pcbnew.UNSPECIFIED_COLOR
BLACK = _pcbnew.BLACK
DARKDARKGRAY = _pcbnew.DARKDARKGRAY
DARKGRAY = _pcbnew.DARKGRAY
LIGHTGRAY = _pcbnew.LIGHTGRAY
WHITE = _pcbnew.WHITE
LIGHTYELLOW = _pcbnew.LIGHTYELLOW
DARKBLUE = _pcbnew.DARKBLUE
DARKGREEN = _pcbnew.DARKGREEN
DARKCYAN = _pcbnew.DARKCYAN
DARKRED = _pcbnew.DARKRED
DARKMAGENTA = _pcbnew.DARKMAGENTA
DARKBROWN = _pcbnew.DARKBROWN
BLUE = _pcbnew.BLUE
GREEN = _pcbnew.GREEN
CYAN = _pcbnew.CYAN
RED = _pcbnew.RED
MAGENTA = _pcbnew.MAGENTA
BROWN = _pcbnew.BROWN
LIGHTBLUE = _pcbnew.LIGHTBLUE
LIGHTGREEN = _pcbnew.LIGHTGREEN
LIGHTCYAN = _pcbnew.LIGHTCYAN
LIGHTRED = _pcbnew.LIGHTRED
LIGHTMAGENTA = _pcbnew.LIGHTMAGENTA
YELLOW = _pcbnew.YELLOW
PUREBLUE = _pcbnew.PUREBLUE
PUREGREEN = _pcbnew.PUREGREEN
PURECYAN = _pcbnew.PURECYAN
PURERED = _pcbnew.PURERED
PUREMAGENTA = _pcbnew.PUREMAGENTA
PUREYELLOW = _pcbnew.PUREYELLOW
NBCOLORS = _pcbnew.NBCOLORS
HIGHLIGHT_FLAG = _pcbnew.HIGHLIGHT_FLAG
MASKCOLOR = _pcbnew.MASKCOLOR

def ColorFromInt(*args):
  """ColorFromInt(int aColor) -> EDA_COLOR_T"""
  return _pcbnew.ColorFromInt(*args)

def NextColor(*args):
  """NextColor(EDA_COLOR_T & aColor) -> EDA_COLOR_T"""
  return _pcbnew.NextColor(*args)

def ColorGetBase(*args):
  """ColorGetBase(EDA_COLOR_T aColor) -> EDA_COLOR_T"""
  return _pcbnew.ColorGetBase(*args)

def ColorMix(*args):
  """ColorMix(EDA_COLOR_T aColor1, EDA_COLOR_T aColor2) -> EDA_COLOR_T"""
  return _pcbnew.ColorMix(*args)

def ColorTurnToDarkDarkGray(*args):
  """ColorTurnToDarkDarkGray(EDA_COLOR_T * aColor)"""
  return _pcbnew.ColorTurnToDarkDarkGray(*args)

def ColorChangeHighlightFlag(*args):
  """ColorChangeHighlightFlag(EDA_COLOR_T * aColor, bool flag)"""
  return _pcbnew.ColorChangeHighlightFlag(*args)

def SetAlpha(*args):
  """SetAlpha(EDA_COLOR_T * aColor, unsigned char aBlend)"""
  return _pcbnew.SetAlpha(*args)

def GetAlpha(*args):
  """GetAlpha(EDA_COLOR_T aColor) -> unsigned char"""
  return _pcbnew.GetAlpha(*args)
class StructColors(_object):
    """Proxy of C++ StructColors class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StructColors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StructColors, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m_Blue"] = _pcbnew.StructColors_m_Blue_set
    __swig_getmethods__["m_Blue"] = _pcbnew.StructColors_m_Blue_get
    if _newclass:m_Blue = _swig_property(_pcbnew.StructColors_m_Blue_get, _pcbnew.StructColors_m_Blue_set)
    __swig_setmethods__["m_Green"] = _pcbnew.StructColors_m_Green_set
    __swig_getmethods__["m_Green"] = _pcbnew.StructColors_m_Green_get
    if _newclass:m_Green = _swig_property(_pcbnew.StructColors_m_Green_get, _pcbnew.StructColors_m_Green_set)
    __swig_setmethods__["m_Red"] = _pcbnew.StructColors_m_Red_set
    __swig_getmethods__["m_Red"] = _pcbnew.StructColors_m_Red_get
    if _newclass:m_Red = _swig_property(_pcbnew.StructColors_m_Red_get, _pcbnew.StructColors_m_Red_set)
    __swig_setmethods__["m_Numcolor"] = _pcbnew.StructColors_m_Numcolor_set
    __swig_getmethods__["m_Numcolor"] = _pcbnew.StructColors_m_Numcolor_get
    if _newclass:m_Numcolor = _swig_property(_pcbnew.StructColors_m_Numcolor_get, _pcbnew.StructColors_m_Numcolor_set)
    __swig_setmethods__["m_Name"] = _pcbnew.StructColors_m_Name_set
    __swig_getmethods__["m_Name"] = _pcbnew.StructColors_m_Name_get
    if _newclass:m_Name = _swig_property(_pcbnew.StructColors_m_Name_get, _pcbnew.StructColors_m_Name_set)
    __swig_setmethods__["m_LightColor"] = _pcbnew.StructColors_m_LightColor_set
    __swig_getmethods__["m_LightColor"] = _pcbnew.StructColors_m_LightColor_get
    if _newclass:m_LightColor = _swig_property(_pcbnew.StructColors_m_LightColor_get, _pcbnew.StructColors_m_LightColor_set)
   def __init__(self):
        """__init__(StructColors self) -> StructColors"""
        this = _pcbnew.new_StructColors()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_StructColors
    __del__ = lambda self : None;
StructColors_swigregister = _pcbnew.StructColors_swigregister
StructColors_swigregister(StructColors)


def ColorApplyHighlightFlag(*args):
  """ColorApplyHighlightFlag(EDA_COLOR_T * aColor)"""
  return _pcbnew.ColorApplyHighlightFlag(*args)

def ColorByName(*args):
  """ColorByName(wxString const & aName) -> EDA_COLOR_T"""
  return _pcbnew.ColorByName(*args)

def ColorFindNearest(*args):
  """
    ColorFindNearest(wxColour const & aColor) -> EDA_COLOR_T
    ColorFindNearest(int aR, int aG, int aB) -> EDA_COLOR_T
    """
  return _pcbnew.ColorFindNearest(*args)

def ColorIsLight(*args):
  """ColorIsLight(EDA_COLOR_T aColor) -> bool"""
  return _pcbnew.ColorIsLight(*args)

def ColorGetName(*args):
  """ColorGetName(EDA_COLOR_T aColor) -> wxChar const *"""
  return _pcbnew.ColorGetName(*args)

def ColorSetBrush(*args):
  """ColorSetBrush(wxBrush * aBrush, EDA_COLOR_T aColor)"""
  return _pcbnew.ColorSetBrush(*args)

def MakeColour(*args):
  """MakeColour(EDA_COLOR_T aColor) -> wxColour"""
  return _pcbnew.MakeColour(*args)

def Cast_to_BOARD_ITEM(*args):
  """Cast_to_BOARD_ITEM(EDA_ITEM base) -> BOARD_ITEM"""
  return _pcbnew.Cast_to_BOARD_ITEM(*args)

def GetBoard():
  """GetBoard() -> BOARD"""
  return _pcbnew.GetBoard()

def LoadBoard(*args):
  """
    LoadBoard(wxString & aFileName, IO_MGR::PCB_FILE_T aFormat) -> BOARD
    LoadBoard(wxString & aFileName) -> BOARD
    """
  return _pcbnew.LoadBoard(*args)

def SaveBoard(*args):
  """
    SaveBoard(wxString & aFileName, BOARD aBoard, IO_MGR::PCB_FILE_T aFormat) -> bool
    SaveBoard(wxString & aFileName, BOARD aBoard) -> bool
    """
  return _pcbnew.SaveBoard(*args)
class PROPERTIES(str_utf8_Map):
    """
    Class PROPERTIES is a name/value tuple with unique names and optional
    values.

    The names may be iterated alphabetically.

    C++ includes: io_mgr.h
    """
    __swig_setmethods__ = {}
    for _s in [str_utf8_Map]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PROPERTIES, name, value)
    __swig_getmethods__ = {}
    for _s in [str_utf8_Map]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PROPERTIES, name)
    __repr__ = _swig_repr
   def Value(self, *args):
        """
        Value(PROPERTIES self, char const * aName, UTF8 aFetchedValue=None) -> bool
        Value(PROPERTIES self, char const * aName) -> bool

        bool
        PROPERTIES::Value(const char *aName, UTF8 *aFetchedValue=NULL) const

        Function Value fetches a property by aName and returns true if that
        property was found, else false.

        If not found, aFetchedValue is not touched.

        Parameters:
        -----------

        aName:  is the property or option to look for.

        aFetchedValue:  is where to put the value of the property if it exists
        and aFetchedValue is not NULL.

        bool - true if property is found, else false.
        """
        return _pcbnew.PROPERTIES_Value(self, *args)

   def __init__(self):
        """
        __init__(PROPERTIES self) -> PROPERTIES

        Class PROPERTIES is a name/value tuple with unique names and optional
        values.

        The names may be iterated alphabetically.

        C++ includes: io_mgr.h
        """
        this = _pcbnew.new_PROPERTIES()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PROPERTIES
    __del__ = lambda self : None;
PROPERTIES_swigregister = _pcbnew.PROPERTIES_swigregister
PROPERTIES_swigregister(PROPERTIES)
g_ColorRefs = cvar.g_ColorRefs

class IO_MGR(_object):
    """
    Class IO_MGR is a factory which returns an instance of a PLUGIN.

    C++ includes: io_mgr.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IO_MGR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IO_MGR, name)
    __repr__ = _swig_repr
    LEGACY = _pcbnew.IO_MGR_LEGACY
    KICAD = _pcbnew.IO_MGR_KICAD
    EAGLE = _pcbnew.IO_MGR_EAGLE
    PCAD = _pcbnew.IO_MGR_PCAD
    GEDA_PCB = _pcbnew.IO_MGR_GEDA_PCB
    GITHUB = _pcbnew.IO_MGR_GITHUB
   def PluginFind(*args):
        """PluginFind(IO_MGR::PCB_FILE_T aFileType) -> PLUGIN"""
        return _pcbnew.IO_MGR_PluginFind(*args)

    if _newclass:PluginFind = staticmethod(PluginFind)
    __swig_getmethods__["PluginFind"] = lambda x: PluginFind
   def PluginRelease(*args):
        """PluginRelease(PLUGIN aPlugin)"""
        return _pcbnew.IO_MGR_PluginRelease(*args)

    if _newclass:PluginRelease = staticmethod(PluginRelease)
    __swig_getmethods__["PluginRelease"] = lambda x: PluginRelease
   def ShowType(*args):
        """ShowType(IO_MGR::PCB_FILE_T aFileType) -> wxString const"""
        return _pcbnew.IO_MGR_ShowType(*args)

    if _newclass:ShowType = staticmethod(ShowType)
    __swig_getmethods__["ShowType"] = lambda x: ShowType
   def EnumFromStr(*args):
        """EnumFromStr(wxString const & aFileType) -> IO_MGR::PCB_FILE_T"""
        return _pcbnew.IO_MGR_EnumFromStr(*args)

    if _newclass:EnumFromStr = staticmethod(EnumFromStr)
    __swig_getmethods__["EnumFromStr"] = lambda x: EnumFromStr
   def GetFileExtension(*args):
        """GetFileExtension(IO_MGR::PCB_FILE_T aFileType) -> wxString const"""
        return _pcbnew.IO_MGR_GetFileExtension(*args)

    if _newclass:GetFileExtension = staticmethod(GetFileExtension)
    __swig_getmethods__["GetFileExtension"] = lambda x: GetFileExtension
   def GuessPluginTypeFromLibPath(*args):
        """GuessPluginTypeFromLibPath(wxString const & aLibPath) -> IO_MGR::PCB_FILE_T"""
        return _pcbnew.IO_MGR_GuessPluginTypeFromLibPath(*args)

    if _newclass:GuessPluginTypeFromLibPath = staticmethod(GuessPluginTypeFromLibPath)
    __swig_getmethods__["GuessPluginTypeFromLibPath"] = lambda x: GuessPluginTypeFromLibPath
   def Load(*args):
        """
        Load(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aAppendToMe=None,
            PROPERTIES aProperties=None) -> BOARD
        Load(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aAppendToMe=None) -> BOARD
        Load(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName) -> BOARD
        """
        return _pcbnew.IO_MGR_Load(*args)

    if _newclass:Load = staticmethod(Load)
    __swig_getmethods__["Load"] = lambda x: Load
   def Save(*args):
        """
        Save(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aBoard, PROPERTIES aProperties=None)
        Save(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aBoard)
        """
        return _pcbnew.IO_MGR_Save(*args)

    if _newclass:Save = staticmethod(Save)
    __swig_getmethods__["Save"] = lambda x: Save
   def __init__(self):
        """
        __init__(IO_MGR self) -> IO_MGR

        Class IO_MGR is a factory which returns an instance of a PLUGIN.

        C++ includes: io_mgr.h
        """
        this = _pcbnew.new_IO_MGR()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_IO_MGR
    __del__ = lambda self : None;
IO_MGR_swigregister = _pcbnew.IO_MGR_swigregister
IO_MGR_swigregister(IO_MGR)

def IO_MGR_PluginFind(*args):
  """IO_MGR_PluginFind(IO_MGR::PCB_FILE_T aFileType) -> PLUGIN"""
  return _pcbnew.IO_MGR_PluginFind(*args)

def IO_MGR_PluginRelease(*args):
  """IO_MGR_PluginRelease(PLUGIN aPlugin)"""
  return _pcbnew.IO_MGR_PluginRelease(*args)

def IO_MGR_ShowType(*args):
  """IO_MGR_ShowType(IO_MGR::PCB_FILE_T aFileType) -> wxString const"""
  return _pcbnew.IO_MGR_ShowType(*args)

def IO_MGR_EnumFromStr(*args):
  """IO_MGR_EnumFromStr(wxString const & aFileType) -> IO_MGR::PCB_FILE_T"""
  return _pcbnew.IO_MGR_EnumFromStr(*args)

def IO_MGR_GetFileExtension(*args):
  """IO_MGR_GetFileExtension(IO_MGR::PCB_FILE_T aFileType) -> wxString const"""
  return _pcbnew.IO_MGR_GetFileExtension(*args)

def IO_MGR_GuessPluginTypeFromLibPath(*args):
  """IO_MGR_GuessPluginTypeFromLibPath(wxString const & aLibPath) -> IO_MGR::PCB_FILE_T"""
  return _pcbnew.IO_MGR_GuessPluginTypeFromLibPath(*args)

def IO_MGR_Load(*args):
  """
    Load(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aAppendToMe=None,
        PROPERTIES aProperties=None) -> BOARD
    Load(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aAppendToMe=None) -> BOARD
    IO_MGR_Load(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName) -> BOARD
    """
  return _pcbnew.IO_MGR_Load(*args)

def IO_MGR_Save(*args):
  """
    Save(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aBoard, PROPERTIES aProperties=None)
    IO_MGR_Save(IO_MGR::PCB_FILE_T aFileType, wxString const & aFileName, BOARD aBoard)
    """
  return _pcbnew.IO_MGR_Save(*args)

class PLUGIN(_object):
    """
    Class PLUGIN is a base class that BOARD loading and saving plugins
    should derive from.

    Implementations can provide either Load() or Save() functions, or
    both. PLUGINs throw exceptions, so it is best that you wrap your calls
    to these functions in a try catch block. Plugins throw exceptions
    because it is illegal for them to have any user interface calls in
    them whatsoever, i.e. no windowing or screen printing at all.

    try   { IO_MGR::Load(...);   or IO_MGR::Save(...);   }   catch( const
    IO_ERROR& ioe )   {        // grab text from ioe, show in error
    window.   }

    C++ includes: io_mgr.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PLUGIN, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PLUGIN, name)
   def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
   def PluginName(self):
        """
        PluginName(PLUGIN self) -> wxString const

        virtual const wxString
        PLUGIN::PluginName() const =0

        Function PluginName returns a brief hard coded name for this PLUGIN.

        """
        return _pcbnew.PLUGIN_PluginName(self)

   def GetFileExtension(self):
        """
        GetFileExtension(PLUGIN self) -> wxString const

        virtual const
        wxString PLUGIN::GetFileExtension() const =0

        Function GetFileExtension returns the file extension for the PLUGIN.

        """
        return _pcbnew.PLUGIN_GetFileExtension(self)

   def Load(self, *args):
        """
        Load(PLUGIN self, wxString const & aFileName, BOARD aAppendToMe, PROPERTIES aProperties=None) -> BOARD
        Load(PLUGIN self, wxString const & aFileName, BOARD aAppendToMe) -> BOARD

        BOARD * PLUGIN::Load(const
        wxString &aFileName, BOARD *aAppendToMe, const PROPERTIES
        *aProperties=NULL)

        Function Load loads information from some input file format that this
        PLUGIN implementation knows about, into either a new BOARD or an
        existing one.

        This may be used to load an entire new BOARD, or to augment an
        existing one if aAppendToMe is not NULL.

        Parameters:
        -----------

        aFileName:  is the name of the file to use as input and may be foreign
        in nature or native in nature.

        aAppendToMe:  is an existing BOARD to append to, but if NULL then this
        means "do not append, rather load anew".

        aProperties:  is an associative array that can be used to tell the
        loader how to load the file, because it can take any number of
        additional named arguments that the plugin is known to support. These
        are tuning parameters for the import or load. The caller continues to
        own this object (plugin may not delete it), and plugins should expect
        it to be optionally NULL.

        BOARD* - the successfully loaded board, or the same one as aAppendToMe
        if aAppendToMe was not NULL, and caller owns it.

        Parameters:
        -----------

        ???:  if there is a problem loading, and its contents should say what
        went wrong, using line number and character offsets of the input file
        if possible.
        """
        return _pcbnew.PLUGIN_Load(self, *args)

   def Save(self, *args):
        """
        Save(PLUGIN self, wxString const & aFileName, BOARD aBoard, PROPERTIES aProperties=None)
        Save(PLUGIN self, wxString const & aFileName, BOARD aBoard)

        void PLUGIN::Save(const wxString
        &aFileName, BOARD *aBoard, const PROPERTIES *aProperties=NULL)

        Function Save will write aBoard to a storage file in a format that
        this PLUGIN implementation knows about, or it can be used to write a
        portion of aBoard to a special kind of export file.

        Parameters:
        -----------

        aFileName:  is the name of a file to save to on disk.

        aBoard:  is the class BOARD in memory document tree from which to
        extract information when writing to aFileName. The caller continues to
        own the BOARD, and the plugin should refrain from modifying the BOARD
        if possible.

        aProperties:  is an associative array that can be used to tell the
        saver how to save the file, because it can take any number of
        additional named tuning arguments that the plugin is known to support.
        The caller continues to own this object (plugin may not delete it),
        and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem saving or exporting.
        """
        return _pcbnew.PLUGIN_Save(self, *args)

   def FootprintEnumerate(self, *args):
        """
        FootprintEnumerate(PLUGIN self, wxString const & aLibraryPath, PROPERTIES aProperties=None) -> wxArrayString
        FootprintEnumerate(PLUGIN self, wxString const & aLibraryPath) -> wxArrayString

        wxArrayString
        PLUGIN::FootprintEnumerate(const wxString &aLibraryPath, const
        PROPERTIES *aProperties=NULL)

        Function FootprintEnumerate returns a list of footprint names
        contained within the library at aLibraryPath.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aProperties:  is an associative array that can be used to tell the
        plugin anything needed about how to perform with respect to
        aLibraryPath. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        wxArrayString - is the array of available footprint names inside a
        library

        Parameters:
        -----------

        ???:  if the library cannot be found, or footprint cannot be loaded.

        """
        return _pcbnew.PLUGIN_FootprintEnumerate(self, *args)

   def FootprintLoad(self, *args):
        """
        FootprintLoad(PLUGIN self, wxString const & aLibraryPath, wxString const & aFootprintName, PROPERTIES aProperties=None) -> MODULE
        FootprintLoad(PLUGIN self, wxString const & aLibraryPath, wxString const & aFootprintName) -> MODULE

        MODULE *
        PLUGIN::FootprintLoad(const wxString &aLibraryPath, const wxString
        &aFootprintName, const PROPERTIES *aProperties=NULL)

        Function FootprintLoad loads a footprint having aFootprintName from
        the aLibraryPath containing a library format that this PLUGIN knows
        about.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aFootprintName:  is the name of the footprint to load.

        aProperties:  is an associative array that can be used to tell the
        loader implementation to do something special, because it can take any
        number of additional named tuning arguments that the plugin is known
        to support. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        MODULE* - if found caller owns it, else NULL if not found.

        Parameters:
        -----------

        ???:  if the library cannot be found or read. No exception is thrown
        in the case where aFootprintName cannot be found.
        """
        return _pcbnew.PLUGIN_FootprintLoad(self, *args)

   def FootprintSave(self, *args):
        """
        FootprintSave(PLUGIN self, wxString const & aLibraryPath, MODULE aFootprint, PROPERTIES aProperties=None)
        FootprintSave(PLUGIN self, wxString const & aLibraryPath, MODULE aFootprint)

        void
        PLUGIN::FootprintSave(const wxString &aLibraryPath, const MODULE
        *aFootprint, const PROPERTIES *aProperties=NULL)

        Function FootprintSave will write aModule to an existing library
        located at aLibraryPath.

        If a footprint by the same name already exists, it is replaced.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aFootprint:  is what to store in the library. The caller continues to
        own the footprint after this call.

        aProperties:  is an associative array that can be used to tell the
        saver how to save the footprint, because it can take any number of
        additional named tuning arguments that the plugin is known to support.
        The caller continues to own this object (plugin may not delete it),
        and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem saving.
        """
        return _pcbnew.PLUGIN_FootprintSave(self, *args)

   def FootprintDelete(self, *args):
        """
        FootprintDelete(PLUGIN self, wxString const & aLibraryPath, wxString const & aFootprintName, PROPERTIES aProperties=None)
        FootprintDelete(PLUGIN self, wxString const & aLibraryPath, wxString const & aFootprintName)

        void
        PLUGIN::FootprintDelete(const wxString &aLibraryPath, const wxString
        &aFootprintName, const PROPERTIES *aProperties=NULL)

        Function FootprintDelete deletes aFootprintName from the library at
        aLibraryPath.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aFootprintName:  is the name of a footprint to delete from the
        specified library.

        aProperties:  is an associative array that can be used to tell the
        library delete function anything special, because it can take any
        number of additional named tuning arguments that the plugin is known
        to support. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem finding the footprint or the library, or
        deleting it.
        """
        return _pcbnew.PLUGIN_FootprintDelete(self, *args)

   def FootprintLibCreate(self, *args):
        """
        FootprintLibCreate(PLUGIN self, wxString const & aLibraryPath, PROPERTIES aProperties=None)
        FootprintLibCreate(PLUGIN self, wxString const & aLibraryPath)

        void
        PLUGIN::FootprintLibCreate(const wxString &aLibraryPath, const
        PROPERTIES *aProperties=NULL)

        Function FootprintLibCreate creates a new empty footprint library at
        aLibraryPath empty.

        It is an error to attempt to create an existing library or to attempt
        to create on a "read only" location.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aProperties:  is an associative array that can be used to tell the
        library create function anything special, because it can take any
        number of additional named tuning arguments that the plugin is known
        to support. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem finding the library, or creating it.
        """
        return _pcbnew.PLUGIN_FootprintLibCreate(self, *args)

   def FootprintLibDelete(self, *args):
        """
        FootprintLibDelete(PLUGIN self, wxString const & aLibraryPath, PROPERTIES aProperties=None) -> bool
        FootprintLibDelete(PLUGIN self, wxString const & aLibraryPath) -> bool

        bool
        PLUGIN::FootprintLibDelete(const wxString &aLibraryPath, const
        PROPERTIES *aProperties=NULL)

        Function FootprintLibDelete deletes an existing footprint library and
        returns true, or if library does not exist returns false, or throws an
        exception if library exists but is read only or cannot be deleted for
        some other reason.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory
        or file which will contain footprints.

        aProperties:  is an associative array that can be used to tell the
        library delete implementation function anything special, because it
        can take any number of additional named tuning arguments that the
        plugin is known to support. The caller continues to own this object
        (plugin may not delete it), and plugins should expect it to be
        optionally NULL.

        bool - true if library deleted, false if library did not exist.

        Parameters:
        -----------

        ???:  if there is a problem deleting an existing library.
        """
        return _pcbnew.PLUGIN_FootprintLibDelete(self, *args)

   def IsFootprintLibWritable(self, *args):
        """
        IsFootprintLibWritable(PLUGIN self, wxString const & aLibraryPath) -> bool

        bool
        PLUGIN::IsFootprintLibWritable(const wxString &aLibraryPath)

        Function IsFootprintLibWritable returns true iff the library at
        aLibraryPath is writable.

        (Often system libraries are read only because of where they are
        installed.)

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        Parameters:
        -----------

        ???:  if no library at aLibraryPath exists.
        """
        return _pcbnew.PLUGIN_IsFootprintLibWritable(self, *args)

   def FootprintLibOptions(self, *args):
        """
        FootprintLibOptions(PLUGIN self, PROPERTIES aListToAppendTo)

        void
        PLUGIN::FootprintLibOptions(PROPERTIES *aListToAppendTo) const

        Function FootprintLibOptions appends supported PLUGIN options to
        aListToAppenTo along with internationalized descriptions.

        Options are typically appended so that a derived PLUGIN can call its
        base class function by the same name first, thus inheriting options
        declared there. (Some base class options could pertain to all
        Footprint*() functions in all derived PLUGINs.) Note that since
        aListToAppendTo is a PROPERTIES object, all options will be unique and
        last guy wins.

        Parameters:
        -----------

        aListToAppendTo:  holds a tuple ofoption This eventually is what shows
        up into the fp-lib-table "options" field, possibly combined with
        others. internationalized description The internationalized
        description is displayed in DIALOG_FP_PLUGIN_OPTIONS. It may be multi-
        line and be quite explanatory of the option.   In the future perhaps
        aListToAppendTo evolves to something capable of also holding a
        wxValidator for the cells in said
        dialog:http://forums.wxwidgets.org/viewtopic.php?t=23277&p=104180.
        This would require a 3 column list, and introducing wx GUI knowledge
        to PLUGIN, which has been avoided to date.
        """
        return _pcbnew.PLUGIN_FootprintLibOptions(self, *args)

    __swig_destroy__ = _pcbnew.delete_PLUGIN
    __del__ = lambda self : None;
PLUGIN_swigregister = _pcbnew.PLUGIN_swigregister
PLUGIN_swigregister(PLUGIN)

SEXPR_BOARD_FILE_VERSION = _pcbnew.SEXPR_BOARD_FILE_VERSION
CTL_STD_LAYER_NAMES = _pcbnew.CTL_STD_LAYER_NAMES
CTL_OMIT_NETS = _pcbnew.CTL_OMIT_NETS
CTL_OMIT_TSTAMPS = _pcbnew.CTL_OMIT_TSTAMPS
CTL_OMIT_INITIAL_COMMENTS = _pcbnew.CTL_OMIT_INITIAL_COMMENTS
CTL_OMIT_PATH = _pcbnew.CTL_OMIT_PATH
CTL_OMIT_AT = _pcbnew.CTL_OMIT_AT
CTL_FOR_CLIPBOARD = _pcbnew.CTL_FOR_CLIPBOARD
CTL_FOR_LIBRARY = _pcbnew.CTL_FOR_LIBRARY
CTL_FOR_BOARD = _pcbnew.CTL_FOR_BOARD
class PCB_IO(PLUGIN):
    """
    Class PCB_IO is a PLUGIN derivation for saving and loading Pcbnew
    s-expression formatted files.

    This class is not thread safe, but it is re-entrant multiple times in
    sequence.

    C++ includes: kicad_plugin.h
    """
    __swig_setmethods__ = {}
    for _s in [PLUGIN]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PCB_IO, name, value)
    __swig_getmethods__ = {}
    for _s in [PLUGIN]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PCB_IO, name)
    __repr__ = _swig_repr
   def PluginName(self):
        """
        PluginName(PCB_IO self) -> wxString const

        const wxString
        PCB_IO::PluginName() const

        Function PluginName returns a brief hard coded name for this PLUGIN.

        """
        return _pcbnew.PCB_IO_PluginName(self)

   def GetFileExtension(self):
        """
        GetFileExtension(PCB_IO self) -> wxString const

        const wxString
        PCB_IO::GetFileExtension() const

        Function GetFileExtension returns the file extension for the PLUGIN.

        """
        return _pcbnew.PCB_IO_GetFileExtension(self)

   def Save(self, *args):
        """
        Save(PCB_IO self, wxString const & aFileName, BOARD aBoard, PROPERTIES aProperties=None)
        Save(PCB_IO self, wxString const & aFileName, BOARD aBoard)

        void PCB_IO::Save(const wxString
        &aFileName, BOARD *aBoard, const PROPERTIES *aProperties=NULL)

        Function Save will write aBoard to a storage file in a format that
        this PLUGIN implementation knows about, or it can be used to write a
        portion of aBoard to a special kind of export file.

        Parameters:
        -----------

        aFileName:  is the name of a file to save to on disk.

        aBoard:  is the class BOARD in memory document tree from which to
        extract information when writing to aFileName. The caller continues to
        own the BOARD, and the plugin should refrain from modifying the BOARD
        if possible.

        aProperties:  is an associative array that can be used to tell the
        saver how to save the file, because it can take any number of
        additional named tuning arguments that the plugin is known to support.
        The caller continues to own this object (plugin may not delete it),
        and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem saving or exporting.
        """
        return _pcbnew.PCB_IO_Save(self, *args)

   def Load(self, *args):
        """
        Load(PCB_IO self, wxString const & aFileName, BOARD aAppendToMe, PROPERTIES aProperties=None) -> BOARD
        Load(PCB_IO self, wxString const & aFileName, BOARD aAppendToMe) -> BOARD

        BOARD * PCB_IO::Load(const
        wxString &aFileName, BOARD *aAppendToMe, const PROPERTIES
        *aProperties=NULL)

        Function Load loads information from some input file format that this
        PLUGIN implementation knows about, into either a new BOARD or an
        existing one.

        This may be used to load an entire new BOARD, or to augment an
        existing one if aAppendToMe is not NULL.

        Parameters:
        -----------

        aFileName:  is the name of the file to use as input and may be foreign
        in nature or native in nature.

        aAppendToMe:  is an existing BOARD to append to, but if NULL then this
        means "do not append, rather load anew".

        aProperties:  is an associative array that can be used to tell the
        loader how to load the file, because it can take any number of
        additional named arguments that the plugin is known to support. These
        are tuning parameters for the import or load. The caller continues to
        own this object (plugin may not delete it), and plugins should expect
        it to be optionally NULL.

        BOARD* - the successfully loaded board, or the same one as aAppendToMe
        if aAppendToMe was not NULL, and caller owns it.

        Parameters:
        -----------

        ???:  if there is a problem loading, and its contents should say what
        went wrong, using line number and character offsets of the input file
        if possible.
        """
        return _pcbnew.PCB_IO_Load(self, *args)

   def FootprintEnumerate(self, *args):
        """
        FootprintEnumerate(PCB_IO self, wxString const & aLibraryPath, PROPERTIES aProperties=None) -> wxArrayString
        FootprintEnumerate(PCB_IO self, wxString const & aLibraryPath) -> wxArrayString

        wxArrayString
        PCB_IO::FootprintEnumerate(const wxString &aLibraryPath, const
        PROPERTIES *aProperties=NULL)

        Function FootprintEnumerate returns a list of footprint names
        contained within the library at aLibraryPath.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aProperties:  is an associative array that can be used to tell the
        plugin anything needed about how to perform with respect to
        aLibraryPath. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        wxArrayString - is the array of available footprint names inside a
        library

        Parameters:
        -----------

        ???:  if the library cannot be found, or footprint cannot be loaded.

        """
        return _pcbnew.PCB_IO_FootprintEnumerate(self, *args)

   def FootprintLoad(self, *args):
        """
        FootprintLoad(PCB_IO self, wxString const & aLibraryPath, wxString const & aFootprintName, PROPERTIES aProperties=None) -> MODULE
        FootprintLoad(PCB_IO self, wxString const & aLibraryPath, wxString const & aFootprintName) -> MODULE

        MODULE *
        PCB_IO::FootprintLoad(const wxString &aLibraryPath, const wxString
        &aFootprintName, const PROPERTIES *aProperties=NULL)

        Function FootprintLoad loads a footprint having aFootprintName from
        the aLibraryPath containing a library format that this PLUGIN knows
        about.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aFootprintName:  is the name of the footprint to load.

        aProperties:  is an associative array that can be used to tell the
        loader implementation to do something special, because it can take any
        number of additional named tuning arguments that the plugin is known
        to support. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        MODULE* - if found caller owns it, else NULL if not found.

        Parameters:
        -----------

        ???:  if the library cannot be found or read. No exception is thrown
        in the case where aFootprintName cannot be found.
        """
        return _pcbnew.PCB_IO_FootprintLoad(self, *args)

   def FootprintSave(self, *args):
        """
        FootprintSave(PCB_IO self, wxString const & aLibraryPath, MODULE aFootprint, PROPERTIES aProperties=None)
        FootprintSave(PCB_IO self, wxString const & aLibraryPath, MODULE aFootprint)

        void
        PCB_IO::FootprintSave(const wxString &aLibraryPath, const MODULE
        *aFootprint, const PROPERTIES *aProperties=NULL)

        Function FootprintSave will write aModule to an existing library
        located at aLibraryPath.

        If a footprint by the same name already exists, it is replaced.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aFootprint:  is what to store in the library. The caller continues to
        own the footprint after this call.

        aProperties:  is an associative array that can be used to tell the
        saver how to save the footprint, because it can take any number of
        additional named tuning arguments that the plugin is known to support.
        The caller continues to own this object (plugin may not delete it),
        and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem saving.
        """
        return _pcbnew.PCB_IO_FootprintSave(self, *args)

   def FootprintDelete(self, *args):
        """
        FootprintDelete(PCB_IO self, wxString const & aLibraryPath, wxString const & aFootprintName, PROPERTIES aProperties=None)
        FootprintDelete(PCB_IO self, wxString const & aLibraryPath, wxString const & aFootprintName)

        void
        PCB_IO::FootprintDelete(const wxString &aLibraryPath, const wxString
        &aFootprintName, const PROPERTIES *aProperties=NULL)

        Function FootprintDelete deletes aFootprintName from the library at
        aLibraryPath.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aFootprintName:  is the name of a footprint to delete from the
        specified library.

        aProperties:  is an associative array that can be used to tell the
        library delete function anything special, because it can take any
        number of additional named tuning arguments that the plugin is known
        to support. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem finding the footprint or the library, or
        deleting it.
        """
        return _pcbnew.PCB_IO_FootprintDelete(self, *args)

   def FootprintLibCreate(self, *args):
        """
        FootprintLibCreate(PCB_IO self, wxString const & aLibraryPath, PROPERTIES aProperties=None)
        FootprintLibCreate(PCB_IO self, wxString const & aLibraryPath)

        void
        PCB_IO::FootprintLibCreate(const wxString &aLibraryPath, const
        PROPERTIES *aProperties=NULL)

        Function FootprintLibCreate creates a new empty footprint library at
        aLibraryPath empty.

        It is an error to attempt to create an existing library or to attempt
        to create on a "read only" location.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        aProperties:  is an associative array that can be used to tell the
        library create function anything special, because it can take any
        number of additional named tuning arguments that the plugin is known
        to support. The caller continues to own this object (plugin may not
        delete it), and plugins should expect it to be optionally NULL.

        Parameters:
        -----------

        ???:  if there is a problem finding the library, or creating it.
        """
        return _pcbnew.PCB_IO_FootprintLibCreate(self, *args)

   def FootprintLibDelete(self, *args):
        """
        FootprintLibDelete(PCB_IO self, wxString const & aLibraryPath, PROPERTIES aProperties=None) -> bool
        FootprintLibDelete(PCB_IO self, wxString const & aLibraryPath) -> bool

        bool
        PCB_IO::FootprintLibDelete(const wxString &aLibraryPath, const
        PROPERTIES *aProperties=NULL)

        Function FootprintLibDelete deletes an existing footprint library and
        returns true, or if library does not exist returns false, or throws an
        exception if library exists but is read only or cannot be deleted for
        some other reason.

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory
        or file which will contain footprints.

        aProperties:  is an associative array that can be used to tell the
        library delete implementation function anything special, because it
        can take any number of additional named tuning arguments that the
        plugin is known to support. The caller continues to own this object
        (plugin may not delete it), and plugins should expect it to be
        optionally NULL.

        bool - true if library deleted, false if library did not exist.

        Parameters:
        -----------

        ???:  if there is a problem deleting an existing library.
        """
        return _pcbnew.PCB_IO_FootprintLibDelete(self, *args)

   def IsFootprintLibWritable(self, *args):
        """
        IsFootprintLibWritable(PCB_IO self, wxString const & aLibraryPath) -> bool

        bool
        PCB_IO::IsFootprintLibWritable(const wxString &aLibraryPath)

        Function IsFootprintLibWritable returns true iff the library at
        aLibraryPath is writable.

        (Often system libraries are read only because of where they are
        installed.)

        Parameters:
        -----------

        aLibraryPath:  is a locator for the "library", usually a directory,
        file, or URL containing several footprints.

        Parameters:
        -----------

        ???:  if no library at aLibraryPath exists.
        """
        return _pcbnew.PCB_IO_IsFootprintLibWritable(self, *args)

   def __init__(self, *args):
        """
        __init__(PCB_IO self, int aControlFlags=((1 << 3))) -> PCB_IO
        __init__(PCB_IO self) -> PCB_IO

        PCB_IO::PCB_IO(int
        aControlFlags=CTL_FOR_BOARD)
        """
        this = _pcbnew.new_PCB_IO(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PCB_IO
    __del__ = lambda self : None;
   def Format(self, *args):
        """
        Format(PCB_IO self, BOARD_ITEM aItem, int aNestLevel=0)
        Format(PCB_IO self, BOARD_ITEM aItem)

        void PCB_IO::Format(BOARD_ITEM
        *aItem, int aNestLevel=0) const  throw ( IO_ERROR ) Function Format
        outputs aItem to aFormatter in s-expression format.

        Parameters:
        -----------

        aItem:  A pointer the an BOARD_ITEM object to format.

        aNestLevel:  The indentation nest level.

        Parameters:
        -----------

        ???:  on write error.
        """
        return _pcbnew.PCB_IO_Format(self, *args)

   def GetStringOutput(self, *args):
        """
        GetStringOutput(PCB_IO self, bool doClear) -> std::string

        std::string
        PCB_IO::GetStringOutput(bool doClear)
        """
        return _pcbnew.PCB_IO_GetStringOutput(self, *args)

   def SetOutputFormatter(self, *args):
        """
        SetOutputFormatter(PCB_IO self, OUTPUTFORMATTER * aFormatter)

        void
        PCB_IO::SetOutputFormatter(OUTPUTFORMATTER *aFormatter)
        """
        return _pcbnew.PCB_IO_SetOutputFormatter(self, *args)

   def Parse(self, *args):
        """
        Parse(PCB_IO self, wxString const & aClipboardSourceInput) -> BOARD_ITEM

        BOARD_ITEM *
        PCB_IO::Parse(const wxString &aClipboardSourceInput)  throw (
        PARSE_ERROR, IO_ERROR )
        """
        return _pcbnew.PCB_IO_Parse(self, *args)

PCB_IO_swigregister = _pcbnew.PCB_IO_swigregister
PCB_IO_swigregister(PCB_IO)

class BOARD_ITEM_List(DHEAD):
    """Proxy of C++ DLIST<(BOARD_ITEM)> class"""
    __swig_setmethods__ = {}
    for _s in [DHEAD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BOARD_ITEM_List, name, value)
    __swig_getmethods__ = {}
    for _s in [DHEAD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, BOARD_ITEM_List, name)
    __repr__ = _swig_repr
   def Get(self):
        """Get(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_Get(self)

   def __deref__(self):
        """__deref__(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List___deref__(self)

   def GetFirst(self):
        """GetFirst(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_GetFirst(self)

   def GetLast(self):
        """GetLast(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_GetLast(self)

   def Append(self, *args):
        """
        Append(BOARD_ITEM_List self, BOARD_ITEM aNewElement)
        Append(BOARD_ITEM_List self, BOARD_ITEM_List aList)
        """
        return _pcbnew.BOARD_ITEM_List_Append(self, *args)

   def Insert(self, *args):
        """Insert(BOARD_ITEM_List self, BOARD_ITEM aNewElement, BOARD_ITEM aElementAfterMe)"""
        return _pcbnew.BOARD_ITEM_List_Insert(self, *args)

   def Remove(self, *args):
        """Remove(BOARD_ITEM_List self, BOARD_ITEM aElement) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_Remove(self, *args)

   def begin(self):
        """begin(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_begin(self)

   def end(self):
        """end(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_end(self)

   def PopFront(self):
        """PopFront(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_PopFront(self)

   def PopBack(self):
        """PopBack(BOARD_ITEM_List self) -> BOARD_ITEM"""
        return _pcbnew.BOARD_ITEM_List_PopBack(self)

   def PushFront(self, *args):
        """PushFront(BOARD_ITEM_List self, BOARD_ITEM aNewElement)"""
        return _pcbnew.BOARD_ITEM_List_PushFront(self, *args)

   def PushBack(self, *args):
        """PushBack(BOARD_ITEM_List self, BOARD_ITEM aNewElement)"""
        return _pcbnew.BOARD_ITEM_List_PushBack(self, *args)

    class DLISTIter:
       def __init__(self,aList):
            self.last = aList   # last item is the start of list

       def next(self):         # get the next item

            item = self.last
            try:
              item = item.Get()
            except:
              pass

            if item is None:    # if the item is None, then finish the iteration
                raise StopIteration
            else:
                ret = None


                try:
                    ret = self.last.Get()
                except:
                    ret = self.last # next items do not..

                self.last = self.last.Next()



                if 'Cast' in dir(ret):
                    ret = ret.Cast()

                return ret

   def __iter__(self):
        return self.DLISTIter(self)


   def __init__(self):
        """__init__(DLIST<(BOARD_ITEM)> self) -> BOARD_ITEM_List"""
        this = _pcbnew.new_BOARD_ITEM_List()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_BOARD_ITEM_List
    __del__ = lambda self : None;
   def GetPosition(self):
        """
        GetPosition(BOARD_ITEM_List self) -> wxPoint

        virtual const
        wxPoint& BOARD_ITEM::GetPosition() const =0
        """
        return _pcbnew.BOARD_ITEM_List_GetPosition(self)

   def SetPosition(self, *args):
        """
        SetPosition(BOARD_ITEM_List self, wxPoint aPos)

        virtual void
        BOARD_ITEM::SetPosition(const wxPoint &aPos)=0
        """
        return _pcbnew.BOARD_ITEM_List_SetPosition(self, *args)

   def IsConnected(self):
        """
        IsConnected(BOARD_ITEM_List self) -> bool

        virtual bool
        BOARD_ITEM::IsConnected() const

        Function IsConnected() Returns information if the object is derived
        from BOARD_CONNECTED_ITEM.

        True if the object is of BOARD_CONNECTED_ITEM type, false otherwise.

        """
        return _pcbnew.BOARD_ITEM_List_IsConnected(self)

   def Next(self):
        """
        Next(BOARD_ITEM_List self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::Next() const
        """
        return _pcbnew.BOARD_ITEM_List_Next(self)

   def Back(self):
        """
        Back(BOARD_ITEM_List self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::Back() const
        """
        return _pcbnew.BOARD_ITEM_List_Back(self)

   def GetParent(self):
        """
        GetParent(BOARD_ITEM_List self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::GetParent() const
        """
        return _pcbnew.BOARD_ITEM_List_GetParent(self)

   def GetLayer(self):
        """
        GetLayer(BOARD_ITEM_List self) -> LAYER_ID

        LAYER_ID
        BOARD_ITEM::GetLayer() const

        Function GetLayer returns the layer this item is on.
        """
        return _pcbnew.BOARD_ITEM_List_GetLayer(self)

   def SetLayer(self, *args):
        """
        SetLayer(BOARD_ITEM_List self, LAYER_ID aLayer)

        virtual void
        BOARD_ITEM::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.BOARD_ITEM_List_SetLayer(self, *args)

   def Draw(self, *args):
        """
        Draw(BOARD_ITEM_List self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint offset=)
        Draw(BOARD_ITEM_List self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        virtual void
        BOARD_ITEM::Draw(EDA_DRAW_PANEL *panel, wxDC *DC, GR_DRAWMODE
        aDrawMode, const wxPoint &offset=ZeroOffset)=0

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.BOARD_ITEM_List_Draw(self, *args)

   def SwapData(self, *args):
        """
        SwapData(BOARD_ITEM_List self, BOARD_ITEM aImage)

        void
        BOARD_ITEM::SwapData(BOARD_ITEM *aImage)

        Swap data between aItem and aImage.

        aItem and aImage should have the same type Used in undo redo command
        to swap values between an item and its copy Only values like layer,
        size .. which are modified by edition are swapped, not the pointers
        like Pnext and Pback because aItem is not changed in the linked list

        Parameters:
        -----------

        aImage:  = the item image which contains data to swap
        """
        return _pcbnew.BOARD_ITEM_List_SwapData(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(BOARD_ITEM_List self, LAYER_ID aLayer) -> bool

        virtual bool
        BOARD_ITEM::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.BOARD_ITEM_List_IsOnLayer(self, *args)

   def IsTrack(self):
        """
        IsTrack(BOARD_ITEM_List self) -> bool

        bool
        BOARD_ITEM::IsTrack() const

        Function IsTrack tests to see if this object is a track or via (or
        microvia).

        form of testing. bool - true if a track or via, else false.
        """
        return _pcbnew.BOARD_ITEM_List_IsTrack(self)

   def IsLocked(self):
        """
        IsLocked(BOARD_ITEM_List self) -> bool

        virtual bool
        BOARD_ITEM::IsLocked() const

        Function IsLocked.

        bool - true if the object is locked, else false
        """
        return _pcbnew.BOARD_ITEM_List_IsLocked(self)

   def UnLink(self):
        """
        UnLink(BOARD_ITEM_List self)

        void BOARD_ITEM::UnLink()

        Function UnLink detaches this object from its owner.

        This base class implementation should work for all derived classes
        which are held in a DLIST<>.
        """
        return _pcbnew.BOARD_ITEM_List_UnLink(self)

   def DeleteStructure(self):
        """
        DeleteStructure(BOARD_ITEM_List self)

        void
        BOARD_ITEM::DeleteStructure()

        Function DeleteStructure deletes this object after UnLink()ing it from
        its owner if it has one.
        """
        return _pcbnew.BOARD_ITEM_List_DeleteStructure(self)

   def ShowShape(self, *args):
        """ShowShape(BOARD_ITEM_List self, STROKE_T aShape) -> wxString"""
        return _pcbnew.BOARD_ITEM_List_ShowShape(self, *args)

   def Move(self, *args):
        """
        Move(BOARD_ITEM_List self, wxPoint aMoveVector)

        virtual void
        BOARD_ITEM::Move(const wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.BOARD_ITEM_List_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(BOARD_ITEM_List self, wxPoint aRotCentre, double aAngle)

        virtual void
        BOARD_ITEM::Rotate(const wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.BOARD_ITEM_List_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(BOARD_ITEM_List self, wxPoint aCentre)

        virtual void
        BOARD_ITEM::Flip(const wxPoint &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.BOARD_ITEM_List_Flip(self, *args)

   def GetBoard(self):
        """
        GetBoard(BOARD_ITEM_List self) -> BOARD

        BOARD *
        BOARD_ITEM::GetBoard() const

        Function GetBoard returns the BOARD in which this BOARD_ITEM resides,
        or NULL if none.
        """
        return _pcbnew.BOARD_ITEM_List_GetBoard(self)

   def GetLayerName(self):
        """
        GetLayerName(BOARD_ITEM_List self) -> wxString

        wxString
        BOARD_ITEM::GetLayerName() const

        Function GetLayerName returns the name of the PCB layer on which the
        item resides.

        wxString containing the layer name associated with this item.
        """
        return _pcbnew.BOARD_ITEM_List_GetLayerName(self)

   def HitTest(self, *args):
        """
        HitTest(BOARD_ITEM_List self, wxPoint aPosition) -> bool
        HitTest(BOARD_ITEM_List self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(BOARD_ITEM_List self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(BOARD_ITEM_List self, EDA_RECT aRect) -> bool

        virtual bool
        BOARD_ITEM::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Function HitTest tests if the aRect intersects or contains this object
        (depending on aContained).

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.BOARD_ITEM_List_HitTest(self, *args)

   def FormatInternalUnits(self, *args):
        """
        FormatInternalUnits(BOARD_ITEM_List self, int aValue) -> std::string
        FormatInternalUnits(BOARD_ITEM_List self, wxPoint aPoint) -> std::string
        FormatInternalUnits(BOARD_ITEM_List self, wxSize aSize) -> std::string
        """
        return _pcbnew.BOARD_ITEM_List_FormatInternalUnits(self, *args)

   def FormatAngle(self, *args):
        """FormatAngle(BOARD_ITEM_List self, double aAngle) -> std::string"""
        return _pcbnew.BOARD_ITEM_List_FormatAngle(self, *args)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(BOARD_ITEM_List self, int [] aLayers, int & aCount)

        void
        BOARD_ITEM::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.BOARD_ITEM_List_ViewGetLayers(self, *args)

   def Cast_to_TEXTE_PCB(self):
        """Cast_to_TEXTE_PCB(BOARD_ITEM_List self) -> TEXTE_PCB"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_TEXTE_PCB(self)

   def Cast_to_DIMENSION(self):
        """Cast_to_DIMENSION(BOARD_ITEM_List self) -> DIMENSION"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_DIMENSION(self)

   def Cast_to_MODULE(self):
        """Cast_to_MODULE(BOARD_ITEM_List self) -> MODULE"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_MODULE(self)

   def Cast_to_TEXTE_MODULE(self):
        """Cast_to_TEXTE_MODULE(BOARD_ITEM_List self) -> TEXTE_MODULE"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_TEXTE_MODULE(self)

   def Cast_to_DRAWSEGMENT(self):
        """Cast_to_DRAWSEGMENT(BOARD_ITEM_List self) -> DRAWSEGMENT"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_DRAWSEGMENT(self)

   def Cast_to_MARKER_PCB(self):
        """Cast_to_MARKER_PCB(BOARD_ITEM_List self) -> MARKER_PCB"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_MARKER_PCB(self)

   def Cast_to_BOARD(self):
        """Cast_to_BOARD(BOARD_ITEM_List self) -> BOARD"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_BOARD(self)

   def Cast_to_EDGE_MODULE(self):
        """Cast_to_EDGE_MODULE(BOARD_ITEM_List self) -> EDGE_MODULE"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_EDGE_MODULE(self)

   def Cast_to_D_PAD(self):
        """Cast_to_D_PAD(BOARD_ITEM_List self) -> D_PAD"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_D_PAD(self)

   def Cast_to_TRACK(self):
        """Cast_to_TRACK(BOARD_ITEM_List self) -> TRACK"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_TRACK(self)

   def Cast_to_VIA(self):
        """Cast_to_VIA(BOARD_ITEM_List self) -> VIA"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_VIA(self)

   def Cast_to_ZONE_CONTAINER(self):
        """Cast_to_ZONE_CONTAINER(BOARD_ITEM_List self) -> ZONE_CONTAINER"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_ZONE_CONTAINER(self)

   def Cast_to_PCB_TARGET(self):
        """Cast_to_PCB_TARGET(BOARD_ITEM_List self) -> PCB_TARGET"""
        return _pcbnew.BOARD_ITEM_List_Cast_to_PCB_TARGET(self)

   def Type(self):
        """
        Type(BOARD_ITEM_List self) -> KICAD_T

        KICAD_T EDA_ITEM::Type() const

        Function Type()

        returns the type of object. This attribute should never be changed
        after a constructor sets it, so there is no public "setter" method.
        KICAD_T - the type of object.
        """
        return _pcbnew.BOARD_ITEM_List_Type(self)

   def SetTimeStamp(self, *args):
        """
        SetTimeStamp(BOARD_ITEM_List self, time_t aNewTimeStamp)

        void
        EDA_ITEM::SetTimeStamp(time_t aNewTimeStamp)
        """
        return _pcbnew.BOARD_ITEM_List_SetTimeStamp(self, *args)

   def GetTimeStamp(self):
        """
        GetTimeStamp(BOARD_ITEM_List self) -> time_t

        time_t
        EDA_ITEM::GetTimeStamp() const
        """
        return _pcbnew.BOARD_ITEM_List_GetTimeStamp(self)

   def GetList(self):
        """
        GetList(BOARD_ITEM_List self) -> DHEAD

        DHEAD* EDA_ITEM::GetList()
        const
        """
        return _pcbnew.BOARD_ITEM_List_GetList(self)

   def SetParent(self, *args):
        """
        SetParent(BOARD_ITEM_List self, EDA_ITEM aParent)

        void
        EDA_ITEM::SetParent(EDA_ITEM *aParent)
        """
        return _pcbnew.BOARD_ITEM_List_SetParent(self, *args)

   def SetList(self, *args):
        """
        SetList(BOARD_ITEM_List self, DHEAD aList)

        void
        EDA_ITEM::SetList(DHEAD *aList)
        """
        return _pcbnew.BOARD_ITEM_List_SetList(self, *args)

   def IsNew(self):
        """
        IsNew(BOARD_ITEM_List self) -> bool

        bool EDA_ITEM::IsNew() const

        """
        return _pcbnew.BOARD_ITEM_List_IsNew(self)

   def IsModified(self):
        """
        IsModified(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsModified() const
        """
        return _pcbnew.BOARD_ITEM_List_IsModified(self)

   def IsMoving(self):
        """
        IsMoving(BOARD_ITEM_List self) -> bool

        bool EDA_ITEM::IsMoving()
        const
        """
        return _pcbnew.BOARD_ITEM_List_IsMoving(self)

   def IsDragging(self):
        """
        IsDragging(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsDragging() const
        """
        return _pcbnew.BOARD_ITEM_List_IsDragging(self)

   def IsWireImage(self):
        """
        IsWireImage(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsWireImage() const
        """
        return _pcbnew.BOARD_ITEM_List_IsWireImage(self)

   def IsSelected(self):
        """
        IsSelected(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsSelected() const
        """
        return _pcbnew.BOARD_ITEM_List_IsSelected(self)

   def IsResized(self):
        """
        IsResized(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsResized() const
        """
        return _pcbnew.BOARD_ITEM_List_IsResized(self)

   def IsHighlighted(self):
        """
        IsHighlighted(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsHighlighted() const
        """
        return _pcbnew.BOARD_ITEM_List_IsHighlighted(self)

   def IsBrightened(self):
        """
        IsBrightened(BOARD_ITEM_List self) -> bool

        bool
        EDA_ITEM::IsBrightened() const
        """
        return _pcbnew.BOARD_ITEM_List_IsBrightened(self)

   def SetWireImage(self):
        """
        SetWireImage(BOARD_ITEM_List self)

        void
        EDA_ITEM::SetWireImage()
        """
        return _pcbnew.BOARD_ITEM_List_SetWireImage(self)

   def SetSelected(self):
        """
        SetSelected(BOARD_ITEM_List self)

        void
        EDA_ITEM::SetSelected()
        """
        return _pcbnew.BOARD_ITEM_List_SetSelected(self)

   def SetHighlighted(self):
        """
        SetHighlighted(BOARD_ITEM_List self)

        void
        EDA_ITEM::SetHighlighted()
        """
        return _pcbnew.BOARD_ITEM_List_SetHighlighted(self)

   def SetBrightened(self):
        """
        SetBrightened(BOARD_ITEM_List self)

        void
        EDA_ITEM::SetBrightened()
        """
        return _pcbnew.BOARD_ITEM_List_SetBrightened(self)

   def ClearSelected(self):
        """
        ClearSelected(BOARD_ITEM_List self)

        void
        EDA_ITEM::ClearSelected()
        """
        return _pcbnew.BOARD_ITEM_List_ClearSelected(self)

   def ClearHighlighted(self):
        """
        ClearHighlighted(BOARD_ITEM_List self)

        void
        EDA_ITEM::ClearHighlighted()
        """
        return _pcbnew.BOARD_ITEM_List_ClearHighlighted(self)

   def ClearBrightened(self):
        """
        ClearBrightened(BOARD_ITEM_List self)

        void
        EDA_ITEM::ClearBrightened()
        """
        return _pcbnew.BOARD_ITEM_List_ClearBrightened(self)

   def SetModified(self):
        """
        SetModified(BOARD_ITEM_List self)

        void
        EDA_ITEM::SetModified()
        """
        return _pcbnew.BOARD_ITEM_List_SetModified(self)

   def GetState(self, *args):
        """
        GetState(BOARD_ITEM_List self, int type) -> int

        int EDA_ITEM::GetState(int
        type) const
        """
        return _pcbnew.BOARD_ITEM_List_GetState(self, *args)

   def SetState(self, *args):
        """
        SetState(BOARD_ITEM_List self, int type, int state)

        void
        EDA_ITEM::SetState(int type, int state)
        """
        return _pcbnew.BOARD_ITEM_List_SetState(self, *args)

   def GetStatus(self):
        """
        GetStatus(BOARD_ITEM_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetStatus() const
        """
        return _pcbnew.BOARD_ITEM_List_GetStatus(self)

   def SetStatus(self, *args):
        """
        SetStatus(BOARD_ITEM_List self, STATUS_FLAGS aStatus)

        void
        EDA_ITEM::SetStatus(STATUS_FLAGS aStatus)
        """
        return _pcbnew.BOARD_ITEM_List_SetStatus(self, *args)

   def SetFlags(self, *args):
        """
        SetFlags(BOARD_ITEM_List self, STATUS_FLAGS aMask)

        void
        EDA_ITEM::SetFlags(STATUS_FLAGS aMask)
        """
        return _pcbnew.BOARD_ITEM_List_SetFlags(self, *args)

   def ClearFlags(self, *args):
        """
        ClearFlags(BOARD_ITEM_List self, STATUS_FLAGS aMask=-1)
        ClearFlags(BOARD_ITEM_List self)

        void
        EDA_ITEM::ClearFlags(STATUS_FLAGS aMask=EDA_ITEM_ALL_FLAGS)
        """
        return _pcbnew.BOARD_ITEM_List_ClearFlags(self, *args)

   def GetFlags(self):
        """
        GetFlags(BOARD_ITEM_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetFlags() const
        """
        return _pcbnew.BOARD_ITEM_List_GetFlags(self)

   def SetImage(self, *args):
        """
        SetImage(BOARD_ITEM_List self, EDA_ITEM aItem)

        void
        EDA_ITEM::SetImage(EDA_ITEM *aItem)
        """
        return _pcbnew.BOARD_ITEM_List_SetImage(self, *args)

   def SetForceVisible(self, *args):
        """
        SetForceVisible(BOARD_ITEM_List self, bool aEnable)

        void
        EDA_ITEM::SetForceVisible(bool aEnable)

        Function SetForceVisible is used to set and cleag force visible flag
        used to force the item to be drawn even if it's draw attribute is set
        to not visible.

        Parameters:
        -----------

        aEnable:  True forces the item to be drawn. False uses the item's
        visibility setting to determine if the item is to be drawn.
        """
        return _pcbnew.BOARD_ITEM_List_SetForceVisible(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(BOARD_ITEM_List self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        virtual void
        EDA_ITEM::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.BOARD_ITEM_List_GetMsgPanelInfo(self, *args)

   def GetBoundingBox(self):
        """
        GetBoundingBox(BOARD_ITEM_List self) -> EDA_RECT

        virtual const
        EDA_RECT EDA_ITEM::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.BOARD_ITEM_List_GetBoundingBox(self)

   def Clone(self):
        """
        Clone(BOARD_ITEM_List self) -> EDA_ITEM

        EDA_ITEM * EDA_ITEM::Clone()
        const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.BOARD_ITEM_List_Clone(self)

   def IterateForward(self, *args):
        """IterateForward(BOARD_ITEM_List self, EDA_ITEM listStart, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT"""
        return _pcbnew.BOARD_ITEM_List_IterateForward(self, *args)

   def Visit(self, *args):
        """
        Visit(BOARD_ITEM_List self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        EDA_ITEM::Visit(INSPECTOR *inspector, const void *testData, const
        KICAD_T scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.BOARD_ITEM_List_Visit(self, *args)

   def GetClass(self):
        """
        GetClass(BOARD_ITEM_List self) -> wxString

        virtual wxString
        EDA_ITEM::GetClass() const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.BOARD_ITEM_List_GetClass(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(BOARD_ITEM_List self) -> wxString

        wxString
        EDA_ITEM::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.BOARD_ITEM_List_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(BOARD_ITEM_List self) -> BITMAP_DEF

        virtual BITMAP_DEF
        EDA_ITEM::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.BOARD_ITEM_List_GetMenuImage(self)

   def Matches(self, *args):
        """
        Matches(BOARD_ITEM_List self, wxFindReplaceData & aSearchData, void * aAuxData, wxPoint aFindLocation) -> bool
        Matches(BOARD_ITEM_List self, wxString const & aText, wxFindReplaceData & aSearchData) -> bool

        bool
        EDA_ITEM::Matches(const wxString &aText, wxFindReplaceData
        &aSearchData)

        Function Matches compares aText against search criteria in
        aSearchData.

        Parameters:
        -----------

        aText:  A reference to a wxString object containing the string to
        test.

        aSearchData:  The criteria to search against.

        True if aText matches the search criteria in aSearchData.
        """
        return _pcbnew.BOARD_ITEM_List_Matches(self, *args)

   def Replace(self, *args):
        """
        Replace(BOARD_ITEM_List self, wxFindReplaceData & aSearchData, wxString & aText) -> bool
        Replace(BOARD_ITEM_List self, wxFindReplaceData & aSearchData, void * aAuxData=None) -> bool
        Replace(BOARD_ITEM_List self, wxFindReplaceData & aSearchData) -> bool

        virtual bool
        EDA_ITEM::Replace(wxFindReplaceData &aSearchData, void *aAuxData=NULL)

        Function Replace performs a text replace using the find and replace
        criteria in aSearchData on items that support text find and replace.

        This function must be overridden for items that support text replace.

        Parameters:
        -----------

        aSearchData:  A reference to a wxFindReplaceData object containing the
        search and replace criteria.

        aAuxData:  A pointer to optional data required for the search or NULL
        if not used.

        True if the item text was modified, otherwise false.
        """
        return _pcbnew.BOARD_ITEM_List_Replace(self, *args)

   def IsReplaceable(self):
        """
        IsReplaceable(BOARD_ITEM_List self) -> bool

        virtual bool
        EDA_ITEM::IsReplaceable() const

        Function IsReplaceable.

        Override this method in any derived object that supports test find and
        replace.

        True if the item has replaceable text that can be modified using the
        find and replace dialog.
        """
        return _pcbnew.BOARD_ITEM_List_IsReplaceable(self)

   def __lt__(self, *args):
        """__lt__(BOARD_ITEM_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.BOARD_ITEM_List___lt__(self, *args)

   def Sort(self, *args):
        """Sort(BOARD_ITEM_List self, EDA_ITEM aLeft, EDA_ITEM aRight) -> bool"""
        return _pcbnew.BOARD_ITEM_List_Sort(self, *args)

   def ViewBBox(self):
        """
        ViewBBox(BOARD_ITEM_List self) -> BOX2I const

        const BOX2I
        EDA_ITEM::ViewBBox() const
        """
        return _pcbnew.BOARD_ITEM_List_ViewBBox(self)

BOARD_ITEM_List_swigregister = _pcbnew.BOARD_ITEM_List_swigregister
BOARD_ITEM_List_swigregister(BOARD_ITEM_List)

class MODULE_List(DHEAD):
    """Proxy of C++ DLIST<(MODULE)> class"""
    __swig_setmethods__ = {}
    for _s in [DHEAD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MODULE_List, name, value)
    __swig_getmethods__ = {}
    for _s in [DHEAD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, MODULE_List, name)
    __repr__ = _swig_repr
   def Get(self):
        """Get(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_Get(self)

   def __deref__(self):
        """__deref__(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List___deref__(self)

   def GetFirst(self):
        """GetFirst(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_GetFirst(self)

   def GetLast(self):
        """GetLast(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_GetLast(self)

   def Append(self, *args):
        """
        Append(MODULE_List self, MODULE aNewElement)
        Append(MODULE_List self, MODULE_List aList)
        """
        return _pcbnew.MODULE_List_Append(self, *args)

   def Insert(self, *args):
        """Insert(MODULE_List self, MODULE aNewElement, MODULE aElementAfterMe)"""
        return _pcbnew.MODULE_List_Insert(self, *args)

   def Remove(self, *args):
        """Remove(MODULE_List self, MODULE aElement) -> MODULE"""
        return _pcbnew.MODULE_List_Remove(self, *args)

   def begin(self):
        """begin(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_begin(self)

   def end(self):
        """end(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_end(self)

   def PopFront(self):
        """PopFront(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_PopFront(self)

   def PopBack(self):
        """PopBack(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_PopBack(self)

   def PushFront(self, *args):
        """PushFront(MODULE_List self, MODULE aNewElement)"""
        return _pcbnew.MODULE_List_PushFront(self, *args)

   def PushBack(self, *args):
        """PushBack(MODULE_List self, MODULE aNewElement)"""
        return _pcbnew.MODULE_List_PushBack(self, *args)

    class DLISTIter:
       def __init__(self,aList):
            self.last = aList   # last item is the start of list

       def next(self):         # get the next item

            item = self.last
            try:
              item = item.Get()
            except:
              pass

            if item is None:    # if the item is None, then finish the iteration
                raise StopIteration
            else:
                ret = None


                try:
                    ret = self.last.Get()
                except:
                    ret = self.last # next items do not..

                self.last = self.last.Next()



                if 'Cast' in dir(ret):
                    ret = ret.Cast()

                return ret

   def __iter__(self):
        return self.DLISTIter(self)


   def __init__(self):
        """__init__(DLIST<(MODULE)> self) -> MODULE_List"""
        this = _pcbnew.new_MODULE_List()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_MODULE_List
    __del__ = lambda self : None;
   def ClassOf(self, *args):
        """ClassOf(MODULE_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.MODULE_List_ClassOf(self, *args)

   def Next(self):
        """
        Next(MODULE_List self) -> MODULE

        MODULE* MODULE::Next() const
        """
        return _pcbnew.MODULE_List_Next(self)

   def Back(self):
        """
        Back(MODULE_List self) -> MODULE

        MODULE* MODULE::Back() const
        """
        return _pcbnew.MODULE_List_Back(self)

   def Copy(self, *args):
        """
        Copy(MODULE_List self, MODULE Module)

        void MODULE::Copy(MODULE
        *Module)
        """
        return _pcbnew.MODULE_List_Copy(self, *args)

   def AddChild(self, *args):
        """
        AddChild(MODULE_List self, BOARD_ITEM aBoardItem, bool doAppend=True)
        AddChild(MODULE_List self, BOARD_ITEM aBoardItem)

        void MODULE::Add(BOARD_ITEM
        *aBoardItem, bool doAppend=true)
        """
        return _pcbnew.MODULE_List_AddChild(self, *args)

   def DeleteChild(self, *args):
        """
        DeleteChild(MODULE_List self, BOARD_ITEM aBoardItem)

        void MODULE::Delete(BOARD_ITEM
        *aBoardItem)

        Function Delete removes the given single item from this MODULE and
        deletes its memory.

        Parameters:
        -----------

        aBoardItem:  The item to remove from this module and delete
        """
        return _pcbnew.MODULE_List_DeleteChild(self, *args)

   def RemoveChild(self, *args):
        """
        RemoveChild(MODULE_List self, BOARD_ITEM aBoardItem) -> BOARD_ITEM

        BOARD_ITEM *
        MODULE::Remove(BOARD_ITEM *aBoardItem)

        Function Remove removes aBoardItem from this MODULE and returns it to
        caller without deleting it.

        Parameters:
        -----------

        aBoardItem:  The item to remove from this module.

        BOARD_ITEM* aBoardItem which was passed in.
        """
        return _pcbnew.MODULE_List_RemoveChild(self, *args)

   def CalculateBoundingBox(self):
        """
        CalculateBoundingBox(MODULE_List self)

        void
        MODULE::CalculateBoundingBox()

        Function CalculateBoundingBox calculates the bounding box in board
        coordinates.
        """
        return _pcbnew.MODULE_List_CalculateBoundingBox(self)

   def GetFootprintRect(self):
        """
        GetFootprintRect(MODULE_List self) -> EDA_RECT

        EDA_RECT
        MODULE::GetFootprintRect() const

        Function GetFootprintRect() Returns the area of the module footprint
        excluding any text.

        EDA_RECT - The rectangle containing the footprint.
        """
        return _pcbnew.MODULE_List_GetFootprintRect(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(MODULE_List self) -> EDA_RECT

        const EDA_RECT
        MODULE::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.MODULE_List_GetBoundingBox(self)

   def Pads(self, *args):
        """
        Pads(MODULE_List self) -> PAD_List
        Pads(MODULE_List self) -> PAD_List

        const DLIST<D_PAD>&
        MODULE::Pads() const
        """
        return _pcbnew.MODULE_List_Pads(self, *args)

   def GraphicalItems(self, *args):
        """
        GraphicalItems(MODULE_List self) -> BOARD_ITEM_List
        GraphicalItems(MODULE_List self) -> BOARD_ITEM_List

        const
        DLIST<BOARD_ITEM>& MODULE::GraphicalItems() const
        """
        return _pcbnew.MODULE_List_GraphicalItems(self, *args)

   def Models(self, *args):
        """
        Models(MODULE_List self) -> DLIST< S3D_MASTER >
        Models(MODULE_List self) -> DLIST< S3D_MASTER > const &

        const DLIST<S3D_MASTER>&
        MODULE::Models() const
        """
        return _pcbnew.MODULE_List_Models(self, *args)

   def SetPosition(self, *args):
        """
        SetPosition(MODULE_List self, wxPoint aPos)

        void
        MODULE::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.MODULE_List_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(MODULE_List self) -> wxPoint

        const wxPoint&
        MODULE::GetPosition() const
        """
        return _pcbnew.MODULE_List_GetPosition(self)

   def SetOrientation(self, *args):
        """
        SetOrientation(MODULE_List self, double newangle)

        void
        MODULE::SetOrientation(double newangle)
        """
        return _pcbnew.MODULE_List_SetOrientation(self, *args)

   def GetOrientation(self):
        """
        GetOrientation(MODULE_List self) -> double

        double
        MODULE::GetOrientation() const
        """
        return _pcbnew.MODULE_List_GetOrientation(self)

   def GetFPID(self):
        """
        GetFPID(MODULE_List self) -> FPID

        const FPID& MODULE::GetFPID()
        const
        """
        return _pcbnew.MODULE_List_GetFPID(self)

   def SetFPID(self, *args):
        """
        SetFPID(MODULE_List self, FPID aFPID)

        void MODULE::SetFPID(const
        FPID &aFPID)
        """
        return _pcbnew.MODULE_List_SetFPID(self, *args)

   def GetDescription(self):
        """
        GetDescription(MODULE_List self) -> wxString const &

        const wxString&
        MODULE::GetDescription() const
        """
        return _pcbnew.MODULE_List_GetDescription(self)

   def SetDescription(self, *args):
        """
        SetDescription(MODULE_List self, wxString const & aDoc)

        void
        MODULE::SetDescription(const wxString &aDoc)
        """
        return _pcbnew.MODULE_List_SetDescription(self, *args)

   def GetKeywords(self):
        """
        GetKeywords(MODULE_List self) -> wxString const &

        const wxString&
        MODULE::GetKeywords() const
        """
        return _pcbnew.MODULE_List_GetKeywords(self)

   def SetKeywords(self, *args):
        """
        SetKeywords(MODULE_List self, wxString const & aKeywords)

        void
        MODULE::SetKeywords(const wxString &aKeywords)
        """
        return _pcbnew.MODULE_List_SetKeywords(self, *args)

   def GetPath(self):
        """
        GetPath(MODULE_List self) -> wxString const &

        const wxString&
        MODULE::GetPath() const
        """
        return _pcbnew.MODULE_List_GetPath(self)

   def SetPath(self, *args):
        """
        SetPath(MODULE_List self, wxString const & aPath)

        void MODULE::SetPath(const
        wxString &aPath)
        """
        return _pcbnew.MODULE_List_SetPath(self, *args)

   def GetLocalSolderMaskMargin(self):
        """
        GetLocalSolderMaskMargin(MODULE_List self) -> int

        int
        MODULE::GetLocalSolderMaskMargin() const
        """
        return _pcbnew.MODULE_List_GetLocalSolderMaskMargin(self)

   def SetLocalSolderMaskMargin(self, *args):
        """
        SetLocalSolderMaskMargin(MODULE_List self, int aMargin)

        void
        MODULE::SetLocalSolderMaskMargin(int aMargin)
        """
        return _pcbnew.MODULE_List_SetLocalSolderMaskMargin(self, *args)

   def GetLocalClearance(self):
        """
        GetLocalClearance(MODULE_List self) -> int

        int
        MODULE::GetLocalClearance() const
        """
        return _pcbnew.MODULE_List_GetLocalClearance(self)

   def SetLocalClearance(self, *args):
        """
        SetLocalClearance(MODULE_List self, int aClearance)

        void
        MODULE::SetLocalClearance(int aClearance)
        """
        return _pcbnew.MODULE_List_SetLocalClearance(self, *args)

   def GetLocalSolderPasteMargin(self):
        """
        GetLocalSolderPasteMargin(MODULE_List self) -> int

        int
        MODULE::GetLocalSolderPasteMargin() const
        """
        return _pcbnew.MODULE_List_GetLocalSolderPasteMargin(self)

   def SetLocalSolderPasteMargin(self, *args):
        """
        SetLocalSolderPasteMargin(MODULE_List self, int aMargin)

        void
        MODULE::SetLocalSolderPasteMargin(int aMargin)
        """
        return _pcbnew.MODULE_List_SetLocalSolderPasteMargin(self, *args)

   def GetLocalSolderPasteMarginRatio(self):
        """
        GetLocalSolderPasteMarginRatio(MODULE_List self) -> double

        double
        MODULE::GetLocalSolderPasteMarginRatio() const
        """
        return _pcbnew.MODULE_List_GetLocalSolderPasteMarginRatio(self)

   def SetLocalSolderPasteMarginRatio(self, *args):
        """
        SetLocalSolderPasteMarginRatio(MODULE_List self, double aRatio)

        void
        MODULE::SetLocalSolderPasteMarginRatio(double aRatio)
        """
        return _pcbnew.MODULE_List_SetLocalSolderPasteMarginRatio(self, *args)

   def SetZoneConnection(self, *args):
        """
        SetZoneConnection(MODULE_List self, ZoneConnection aType)

        void
        MODULE::SetZoneConnection(ZoneConnection aType)
        """
        return _pcbnew.MODULE_List_SetZoneConnection(self, *args)

   def GetZoneConnection(self):
        """
        GetZoneConnection(MODULE_List self) -> ZoneConnection

        ZoneConnection
        MODULE::GetZoneConnection() const
        """
        return _pcbnew.MODULE_List_GetZoneConnection(self)

   def SetThermalWidth(self, *args):
        """
        SetThermalWidth(MODULE_List self, int aWidth)

        void
        MODULE::SetThermalWidth(int aWidth)
        """
        return _pcbnew.MODULE_List_SetThermalWidth(self, *args)

   def GetThermalWidth(self):
        """
        GetThermalWidth(MODULE_List self) -> int

        int
        MODULE::GetThermalWidth() const
        """
        return _pcbnew.MODULE_List_GetThermalWidth(self)

   def SetThermalGap(self, *args):
        """
        SetThermalGap(MODULE_List self, int aGap)

        void
        MODULE::SetThermalGap(int aGap)
        """
        return _pcbnew.MODULE_List_SetThermalGap(self, *args)

   def GetThermalGap(self):
        """
        GetThermalGap(MODULE_List self) -> int

        int
        MODULE::GetThermalGap() const
        """
        return _pcbnew.MODULE_List_GetThermalGap(self)

   def GetAttributes(self):
        """
        GetAttributes(MODULE_List self) -> int

        int
        MODULE::GetAttributes() const
        """
        return _pcbnew.MODULE_List_GetAttributes(self)

   def SetAttributes(self, *args):
        """
        SetAttributes(MODULE_List self, int aAttributes)

        void
        MODULE::SetAttributes(int aAttributes)
        """
        return _pcbnew.MODULE_List_SetAttributes(self, *args)

   def SetFlag(self, *args):
        """
        SetFlag(MODULE_List self, int aFlag)

        void MODULE::SetFlag(int
        aFlag)
        """
        return _pcbnew.MODULE_List_SetFlag(self, *args)

   def IncrementFlag(self):
        """
        IncrementFlag(MODULE_List self)

        void
        MODULE::IncrementFlag()
        """
        return _pcbnew.MODULE_List_IncrementFlag(self)

   def GetFlag(self):
        """
        GetFlag(MODULE_List self) -> int

        int MODULE::GetFlag() const

        """
        return _pcbnew.MODULE_List_GetFlag(self)

   def Move(self, *args):
        """
        Move(MODULE_List self, wxPoint aMoveVector)

        void MODULE::Move(const wxPoint
        &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.MODULE_List_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(MODULE_List self, wxPoint aRotCentre, double aAngle)

        void MODULE::Rotate(const
        wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.MODULE_List_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(MODULE_List self, wxPoint aCentre)

        void MODULE::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.

        Mirror the Y position
        """
        return _pcbnew.MODULE_List_Flip(self, *args)

   def MoveAnchorPosition(self, *args):
        """
        MoveAnchorPosition(MODULE_List self, wxPoint aMoveVector)

        void
        MODULE::MoveAnchorPosition(const wxPoint &aMoveVector)

        Function MoveAnchorPosition Move the reference point of the footprint
        It looks like a move footprint: the footprints elements (pads,
        outlines, edges .

        . ) are moved However: the footprint position is not modified.

        the relative (local) coordinates of these items are modified (a move
        footprint does not change these local coordinates, but changes the
        footprint position)
        """
        return _pcbnew.MODULE_List_MoveAnchorPosition(self, *args)

   def IsFlipped(self):
        """
        IsFlipped(MODULE_List self) -> bool

        bool MODULE::IsFlipped()
        const

        function IsFlipped

        true if the module is flipped, i.e. on the back side of the board
        """
        return _pcbnew.MODULE_List_IsFlipped(self)

   def IsLocked(self):
        """
        IsLocked(MODULE_List self) -> bool

        bool MODULE::IsLocked()
        const

        Function IsLocked.

        bool - true if the object is locked, else false
        """
        return _pcbnew.MODULE_List_IsLocked(self)

   def SetLocked(self, *args):
        """
        SetLocked(MODULE_List self, bool isLocked)

        void MODULE::SetLocked(bool
        isLocked)

        Function SetLocked sets the MODULE_is_LOCKED bit in the
        m_ModuleStatus.

        Parameters:
        -----------

        isLocked:  When true means turn on locked status, else unlock
        """
        return _pcbnew.MODULE_List_SetLocked(self, *args)

   def IsPlaced(self):
        """
        IsPlaced(MODULE_List self) -> bool

        bool MODULE::IsPlaced()
        const
        """
        return _pcbnew.MODULE_List_IsPlaced(self)

   def SetIsPlaced(self, *args):
        """
        SetIsPlaced(MODULE_List self, bool isPlaced)

        void
        MODULE::SetIsPlaced(bool isPlaced)
        """
        return _pcbnew.MODULE_List_SetIsPlaced(self, *args)

   def NeedsPlaced(self):
        """
        NeedsPlaced(MODULE_List self) -> bool

        bool
        MODULE::NeedsPlaced() const
        """
        return _pcbnew.MODULE_List_NeedsPlaced(self)

   def SetNeedsPlaced(self, *args):
        """
        SetNeedsPlaced(MODULE_List self, bool needsPlaced)

        void
        MODULE::SetNeedsPlaced(bool needsPlaced)
        """
        return _pcbnew.MODULE_List_SetNeedsPlaced(self, *args)

   def SetLastEditTime(self, *args):
        """
        SetLastEditTime(MODULE_List self, time_t aTime)
        SetLastEditTime(MODULE_List self)

        void
        MODULE::SetLastEditTime()
        """
        return _pcbnew.MODULE_List_SetLastEditTime(self, *args)

   def GetLastEditTime(self):
        """
        GetLastEditTime(MODULE_List self) -> time_t

        time_t
        MODULE::GetLastEditTime() const
        """
        return _pcbnew.MODULE_List_GetLastEditTime(self)

   def Draw(self, *args):
        """
        Draw(MODULE_List self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(MODULE_List self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void MODULE::Draw(EDA_DRAW_PANEL
        *aPanel, wxDC *aDC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw draws the footprint to the aDC.

        Parameters:
        -----------

        aPanel:  = draw panel, Used to know the clip box

        aDC:  = Current Device Context

        aDrawMode:  = GR_OR, GR_XOR..

        aOffset:  = draw offset (usually wxPoint(0,0)
        """
        return _pcbnew.MODULE_List_Draw(self, *args)

   def ReadAndInsert3DComponentShape(self, *args):
        """
        ReadAndInsert3DComponentShape(MODULE_List self, EDA_3D_CANVAS * glcanvas, bool aAllowNonTransparentObjects, bool aAllowTransparentObjects,
            bool aSideToLoad)

        void
        MODULE::ReadAndInsert3DComponentShape(EDA_3D_CANVAS *glcanvas, bool
        aAllowNonTransparentObjects, bool aAllowTransparentObjects, bool
        aSideToLoad)

        function ReadandInsert3DComponentShape read the 3D component shape(s)
        of the footprint (physical shape) and insert mesh in gl list

        Parameters:
        -----------

        glcanvas:  = the openGL canvas

        aAllowNonTransparentObjects:  = true to load non transparent objects

        aAllowTransparentObjects:  = true to load non transparent objects

        aSideToLoad:  = false will load not fliped, true will load fliped
        objects in openGL, transparent objects should be drawn after non
        transparent objects
        """
        return _pcbnew.MODULE_List_ReadAndInsert3DComponentShape(self, *args)

   def TransformPadsShapesWithClearanceToPolygon(self, *args):
        """
        TransformPadsShapesWithClearanceToPolygon(MODULE_List self, LAYER_ID aLayer, CPOLYGONS_LIST aCornerBuffer, int aInflateValue, int aCircleToSegmentsCount,
            double aCorrectionFactor)

        void
        MODULE::TransformPadsShapesWithClearanceToPolygon(LAYER_ID aLayer,
        CPOLYGONS_LIST &aCornerBuffer, int aInflateValue, int
        aCircleToSegmentsCount, double aCorrectionFactor)

        function TransformPadsShapesWithClearanceToPolygon generate pads
        shapes on layer aLayer as polygons, and adds these polygons to
        aCornerBuffer Useful to generate a polygonal representation of a
        footprint in 3D view and plot functions, when a full polygonal
        approach is needed

        Parameters:
        -----------

        aLayer:  = the current layer: pads on this layer are considered

        aCornerBuffer:  = the buffer to store polygons

        aInflateValue:  = an additionnal size to add to pad shapes
        aInflateValue = 0 to have the exact pad size

        aCircleToSegmentsCount:  = number of segments to generate a circle

        aCorrectionFactor:  = the correction to apply to a circle radius to
        approximate a circle by the polygon. if aCorrectionFactor = 1.0, the
        polygon is inside the circle the radius of circle approximated by
        segments is initial radius * aCorrectionFactor
        """
        return _pcbnew.MODULE_List_TransformPadsShapesWithClearanceToPolygon(self, *args)

   def TransformGraphicShapesWithClearanceToPolygonSet(self, *args):
        """
        TransformGraphicShapesWithClearanceToPolygonSet(MODULE_List self, LAYER_ID aLayer, CPOLYGONS_LIST aCornerBuffer, int aInflateValue, int aCircleToSegmentsCount,
            double aCorrectionFactor)

        void
        MODULE::TransformGraphicShapesWithClearanceToPolygonSet(LAYER_ID
        aLayer, CPOLYGONS_LIST &aCornerBuffer, int aInflateValue, int
        aCircleToSegmentsCount, double aCorrectionFactor)

        function TransformGraphicShapesWithClearanceToPolygonSet generate
        shapes of graphic items (outlines) on layer aLayer as polygons, and
        adds these polygons to aCornerBuffer Useful to generate a polygonal
        representation of a footprint in 3D view and plot functions, when a
        full polygonal approach is needed

        Parameters:
        -----------

        aLayer:  = the current layer: items on this layer are considered

        aCornerBuffer:  = the buffer to store polygons

        aInflateValue:  = a value to inflate shapes aInflateValue = 0 to have
        the exact shape size

        aCircleToSegmentsCount:  = number of segments to generate a circle

        aCorrectionFactor:  = the correction to apply to a circle radius to
        approximate a circle by the polygon. if aCorrectionFactor = 1.0, the
        polygon is inside the circle the radius of circle approximated by
        segments is initial radius * aCorrectionFactor
        """
        return _pcbnew.MODULE_List_TransformGraphicShapesWithClearanceToPolygonSet(self, *args)

   def DrawEdgesOnly(self, *args):
        """
        DrawEdgesOnly(MODULE_List self, EDA_DRAW_PANEL * panel, wxDC * DC, wxPoint offset, GR_DRAWMODE draw_mode)

        void
        MODULE::DrawEdgesOnly(EDA_DRAW_PANEL *panel, wxDC *DC, const wxPoint
        &offset, GR_DRAWMODE draw_mode)

        Function DrawEdgesOnly Draws the footprint edges only to the current
        Device Context.

        Parameters:
        -----------

        panel:  = The active Draw Panel (used to know the clip box)

        DC:  = current Device Context

        offset:  = draw offset (usually wxPoint(0,0)

        draw_mode:  = GR_OR, GR_XOR, GR_AND
        """
        return _pcbnew.MODULE_List_DrawEdgesOnly(self, *args)

   def DrawAncre(self, *args):
        """
        DrawAncre(MODULE_List self, EDA_DRAW_PANEL * panel, wxDC * DC, wxPoint offset, int dim_ancre, GR_DRAWMODE draw_mode)

        void
        MODULE::DrawAncre(EDA_DRAW_PANEL *panel, wxDC *DC, const wxPoint
        &offset, int dim_ancre, GR_DRAWMODE draw_mode)
        """
        return _pcbnew.MODULE_List_DrawAncre(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(MODULE_List self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        MODULE::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.MODULE_List_GetMsgPanelInfo(self, *args)

   def HitTest(self, *args):
        """
        HitTest(MODULE_List self, wxPoint aPosition) -> bool
        HitTest(MODULE_List self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(MODULE_List self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(MODULE_List self, EDA_RECT aRect) -> bool

        bool MODULE::HitTest(const
        EDA_RECT &aRect, bool aContained=true, int aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.MODULE_List_HitTest(self, *args)

   def GetReference(self):
        """
        GetReference(MODULE_List self) -> wxString const &

        const wxString&
        MODULE::GetReference() const

        Function GetReference.

        const wxString& - the reference designator text.
        """
        return _pcbnew.MODULE_List_GetReference(self)

   def SetReference(self, *args):
        """
        SetReference(MODULE_List self, wxString const & aReference)

        void
        MODULE::SetReference(const wxString &aReference)

        Function SetReference.

        Parameters:
        -----------

        aReference:  A reference to a wxString object containing the reference
        designator text.
        """
        return _pcbnew.MODULE_List_SetReference(self, *args)

   def GetValue(self):
        """
        GetValue(MODULE_List self) -> wxString const &

        const wxString&
        MODULE::GetValue() const

        Function GetValue.

        const wxString& - the value text.
        """
        return _pcbnew.MODULE_List_GetValue(self)

   def SetValue(self, *args):
        """
        SetValue(MODULE_List self, wxString const & aValue)

        void MODULE::SetValue(const
        wxString &aValue)

        Function SetValue.

        Parameters:
        -----------

        aValue:  A reference to a wxString object containing the value text.

        """
        return _pcbnew.MODULE_List_SetValue(self, *args)

   def Value(self, *args):
        """
        Value(MODULE_List self) -> TEXTE_MODULE
        Value(MODULE_List self) -> TEXTE_MODULE

        TEXTE_MODULE& MODULE::Value()
        const

        The const versions to keep the compiler happy.
        """
        return _pcbnew.MODULE_List_Value(self, *args)

   def Reference(self, *args):
        """
        Reference(MODULE_List self) -> TEXTE_MODULE
        Reference(MODULE_List self) -> TEXTE_MODULE

        TEXTE_MODULE&
        MODULE::Reference() const
        """
        return _pcbnew.MODULE_List_Reference(self, *args)

   def FindPadByName(self, *args):
        """
        FindPadByName(MODULE_List self, wxString const & aPadName) -> D_PAD

        D_PAD *
        MODULE::FindPadByName(const wxString &aPadName) const

        Function FindPadByName returns a D_PAD* with a matching name.

        Note that names may not be unique, depending on how the foot print was
        created.

        Parameters:
        -----------

        aPadName:  the pad name to find

        D_PAD* - The first matching name is returned, or NULL if not found.
        """
        return _pcbnew.MODULE_List_FindPadByName(self, *args)

   def GetPad(self, *args):
        """
        GetPad(MODULE_List self, wxPoint aPosition, LSET aLayerMask=LSET::AllLayersMask()) -> D_PAD
        GetPad(MODULE_List self, wxPoint aPosition) -> D_PAD

        D_PAD * MODULE::GetPad(const
        wxPoint &aPosition, LSET aLayerMask=LSET::AllLayersMask())

        Function GetPad get a pad at aPosition on aLayerMask in the footprint.

        Parameters:
        -----------

        aPosition:  A wxPoint object containing the position to hit test.

        aLayerMask:  A layer or layers to mask the hit test.

        A pointer to a D_PAD object if found otherwise NULL.
        """
        return _pcbnew.MODULE_List_GetPad(self, *args)

   def GetPadCount(self, *args):
        """
        GetPadCount(MODULE_List self, MODULE::INCLUDE_NPTH_T aIncludeNPTH=INCLUDE_NPTH) -> unsigned int
        GetPadCount(MODULE_List self) -> unsigned int

        unsigned
        MODULE::GetPadCount(INCLUDE_NPTH_T aIncludeNPTH=INCLUDE_NPTH) const

        GetPadCount returns the number of pads.

        Parameters:
        -----------

        aIncludeNPTH:  includes non-plated through holes when true. Does not
        include non- plated through holes when false.

        the number of pads according to aIncludeNPTH.
        """
        return _pcbnew.MODULE_List_GetPadCount(self, *args)

   def GetArea(self):
        """
        GetArea(MODULE_List self) -> double

        double MODULE::GetArea()
        const
        """
        return _pcbnew.MODULE_List_GetArea(self)

   def GetLink(self):
        """
        GetLink(MODULE_List self) -> time_t

        time_t MODULE::GetLink()
        const
        """
        return _pcbnew.MODULE_List_GetLink(self)

   def SetLink(self, *args):
        """
        SetLink(MODULE_List self, time_t aLink)

        void MODULE::SetLink(time_t
        aLink)
        """
        return _pcbnew.MODULE_List_SetLink(self, *args)

   def GetPlacementCost180(self):
        """
        GetPlacementCost180(MODULE_List self) -> int

        int
        MODULE::GetPlacementCost180() const
        """
        return _pcbnew.MODULE_List_GetPlacementCost180(self)

   def SetPlacementCost180(self, *args):
        """
        SetPlacementCost180(MODULE_List self, int aCost)

        void
        MODULE::SetPlacementCost180(int aCost)
        """
        return _pcbnew.MODULE_List_SetPlacementCost180(self, *args)

   def GetPlacementCost90(self):
        """
        GetPlacementCost90(MODULE_List self) -> int

        int
        MODULE::GetPlacementCost90() const
        """
        return _pcbnew.MODULE_List_GetPlacementCost90(self)

   def SetPlacementCost90(self, *args):
        """
        SetPlacementCost90(MODULE_List self, int aCost)

        void
        MODULE::SetPlacementCost90(int aCost)
        """
        return _pcbnew.MODULE_List_SetPlacementCost90(self, *args)

   def Add3DModel(self, *args):
        """
        Add3DModel(MODULE_List self, S3D_MASTER * a3DModel)

        void
        MODULE::Add3DModel(S3D_MASTER *a3DModel)

       Function Add3DModel adds a3DModel definition to the end of the 3D
        model list.

        Parameters:
        -----------

        a3DModel:  A pointer to a S3D_MASTER to add to the list.
        """
        return _pcbnew.MODULE_List_Add3DModel(self, *args)

   def Visit(self, *args):
        """
        Visit(MODULE_List self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        MODULE::Visit(INSPECTOR *inspector, const void *testData, const
        KICAD_T scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.MODULE_List_Visit(self, *args)

   def GetClass(self):
        """
        GetClass(MODULE_List self) -> wxString

        wxString MODULE::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.MODULE_List_GetClass(self)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(MODULE_List self) -> wxString

        wxString
        MODULE::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.MODULE_List_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(MODULE_List self) -> BITMAP_DEF

        BITMAP_DEF
        MODULE::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.MODULE_List_GetMenuImage(self)

   def Clone(self):
        """
        Clone(MODULE_List self) -> EDA_ITEM

        EDA_ITEM * MODULE::Clone()
        const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.MODULE_List_Clone(self)

   def RunOnChildren(self, *args):
        """
        RunOnChildren(MODULE_List self, boost::function< void (BOARD_ITEM *) > aFunction)

        void
        MODULE::RunOnChildren(boost::function< void(BOARD_ITEM *)> aFunction)

        Function RunOnChildren.

        Invokes a function on all BOARD_ITEMs that belong to the module (pads,
        drawings, texts).

        Parameters:
        -----------

        aFunction:  is the function to be invoked.
        """
        return _pcbnew.MODULE_List_RunOnChildren(self, *args)

   def ViewUpdate(self, *args):
        """
        ViewUpdate(MODULE_List self, int aUpdateFlags=KIGFX::VIEW_ITEM::ALL)
        ViewUpdate(MODULE_List self)

        void
        MODULE::ViewUpdate(int aUpdateFlags=KIGFX::VIEW_ITEM::ALL)
        """
        return _pcbnew.MODULE_List_ViewUpdate(self, *args)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(MODULE_List self, int [] aLayers, int & aCount)

        void
        MODULE::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.MODULE_List_ViewGetLayers(self, *args)

   def ViewGetLOD(self, *args):
        """
        ViewGetLOD(MODULE_List self, int aLayer) -> unsigned int

        unsigned int
        MODULE::ViewGetLOD(int aLayer) const
        """
        return _pcbnew.MODULE_List_ViewGetLOD(self, *args)

   def ViewBBox(self):
        """
        ViewBBox(MODULE_List self) -> BOX2I const

        const BOX2I
        MODULE::ViewBBox() const
        """
        return _pcbnew.MODULE_List_ViewBBox(self)

   def CopyNetlistSettings(self, *args):
        """
        CopyNetlistSettings(MODULE_List self, MODULE aModule)

        void
        MODULE::CopyNetlistSettings(MODULE *aModule)

        Function CopyNetlistSettings copies the netlist settings to aModule.

       The netlist settings are all of the MODULE settings not define by a
        MODULE in a netlist. These setting include position, orientation,
        local clearances, ets. The reference designator, value, path, and
        physical geometry settings are not copied.

        Parameters:
        -----------

        aModule:  is the MODULE to copy the settings to.
        """
        return _pcbnew.MODULE_List_CopyNetlistSettings(self, *args)

   def IsLibNameValid(self, *args):
        """IsLibNameValid(MODULE_List self, wxString const & aName) -> bool"""
        return _pcbnew.MODULE_List_IsLibNameValid(self, *args)

   def StringLibNameInvalidChars(self, *args):
        """StringLibNameInvalidChars(MODULE_List self, bool aUserReadable) -> wxChar const *"""
        return _pcbnew.MODULE_List_StringLibNameInvalidChars(self, *args)

   def SetInitialComments(self, *args):
        """
        SetInitialComments(MODULE_List self, wxArrayString * aInitialComments)

        void
        MODULE::SetInitialComments(wxArrayString *aInitialComments)

        Function SetInitialComments takes ownership of caller's heap allocated
        aInitialComments block.

        The comments are single line strings already containing the
        s-expression comments with optional leading whitespace and then a '#'
        character followed by optional single line text (text with no line
        endings, not even one). This block of single line comments will be
        output upfront of any generated s-expression text in the
        PCBIO::Format() function.

        Note that a block of single line comments constitutes a multiline
        block of single line comments. That is, the block is made of
        consecutive single line comments.

        Parameters:
        -----------

        aInitialComments:  is a heap allocated wxArrayString or NULL, which
        the caller gives up ownership of over to this MODULE.
        """
        return _pcbnew.MODULE_List_SetInitialComments(self, *args)

   def GetInitialComments(self):
        """
        GetInitialComments(MODULE_List self) -> wxArrayString const *

        const
        wxArrayString* MODULE::GetInitialComments() const

        Return the initial comments block or NULL if none, without transfer of
        ownership.
        """
        return _pcbnew.MODULE_List_GetInitialComments(self)

   def IsConnected(self):
        """
        IsConnected(MODULE_List self) -> bool

        virtual bool
        BOARD_ITEM::IsConnected() const

        Function IsConnected() Returns information if the object is derived
        from BOARD_CONNECTED_ITEM.

        True if the object is of BOARD_CONNECTED_ITEM type, false otherwise.

        """
        return _pcbnew.MODULE_List_IsConnected(self)

   def GetParent(self):
        """
        GetParent(MODULE_List self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::GetParent() const
        """
        return _pcbnew.MODULE_List_GetParent(self)

   def GetLayer(self):
        """
        GetLayer(MODULE_List self) -> LAYER_ID

        LAYER_ID
        BOARD_ITEM::GetLayer() const

        Function GetLayer returns the layer this item is on.
        """
        return _pcbnew.MODULE_List_GetLayer(self)

   def SetLayer(self, *args):
        """
        SetLayer(MODULE_List self, LAYER_ID aLayer)

        virtual void
        BOARD_ITEM::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.MODULE_List_SetLayer(self, *args)

   def SwapData(self, *args):
        """
        SwapData(MODULE_List self, BOARD_ITEM aImage)

        void
        BOARD_ITEM::SwapData(BOARD_ITEM *aImage)

        Swap data between aItem and aImage.

        aItem and aImage should have the same type Used in undo redo command
        to swap values between an item and its copy Only values like layer,
        size .. which are modified by edition are swapped, not the pointers
        like Pnext and Pback because aItem is not changed in the linked list

        Parameters:
        -----------

        aImage:  = the item image which contains data to swap
        """
        return _pcbnew.MODULE_List_SwapData(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(MODULE_List self, LAYER_ID aLayer) -> bool

        virtual bool
        BOARD_ITEM::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.MODULE_List_IsOnLayer(self, *args)

   def IsTrack(self):
        """
        IsTrack(MODULE_List self) -> bool

        bool
        BOARD_ITEM::IsTrack() const

        Function IsTrack tests to see if this object is a track or via (or
        microvia).

        form of testing. bool - true if a track or via, else false.
        """
        return _pcbnew.MODULE_List_IsTrack(self)

   def UnLink(self):
        """
        UnLink(MODULE_List self)

        void BOARD_ITEM::UnLink()

        Function UnLink detaches this object from its owner.

        This base class implementation should work for all derived classes
        which are held in a DLIST<>.
        """
        return _pcbnew.MODULE_List_UnLink(self)

   def DeleteStructure(self):
        """
        DeleteStructure(MODULE_List self)

        void
        BOARD_ITEM::DeleteStructure()

        Function DeleteStructure deletes this object after UnLink()ing it from
        its owner if it has one.
        """
        return _pcbnew.MODULE_List_DeleteStructure(self)

   def ShowShape(self, *args):
        """ShowShape(MODULE_List self, STROKE_T aShape) -> wxString"""
        return _pcbnew.MODULE_List_ShowShape(self, *args)

   def GetBoard(self):
        """
        GetBoard(MODULE_List self) -> BOARD

        BOARD *
        BOARD_ITEM::GetBoard() const

        Function GetBoard returns the BOARD in which this BOARD_ITEM resides,
        or NULL if none.
        """
        return _pcbnew.MODULE_List_GetBoard(self)

   def GetLayerName(self):
        """
        GetLayerName(MODULE_List self) -> wxString

        wxString
        BOARD_ITEM::GetLayerName() const

        Function GetLayerName returns the name of the PCB layer on which the
        item resides.

        wxString containing the layer name associated with this item.
        """
        return _pcbnew.MODULE_List_GetLayerName(self)

   def FormatInternalUnits(self, *args):
        """
        FormatInternalUnits(MODULE_List self, int aValue) -> std::string
        FormatInternalUnits(MODULE_List self, wxPoint aPoint) -> std::string
        FormatInternalUnits(MODULE_List self, wxSize aSize) -> std::string
        """
        return _pcbnew.MODULE_List_FormatInternalUnits(self, *args)

   def FormatAngle(self, *args):
        """FormatAngle(MODULE_List self, double aAngle) -> std::string"""
        return _pcbnew.MODULE_List_FormatAngle(self, *args)

   def Cast_to_TEXTE_PCB(self):
        """Cast_to_TEXTE_PCB(MODULE_List self) -> TEXTE_PCB"""
        return _pcbnew.MODULE_List_Cast_to_TEXTE_PCB(self)

   def Cast_to_DIMENSION(self):
        """Cast_to_DIMENSION(MODULE_List self) -> DIMENSION"""
        return _pcbnew.MODULE_List_Cast_to_DIMENSION(self)

   def Cast_to_MODULE(self):
        """Cast_to_MODULE(MODULE_List self) -> MODULE"""
        return _pcbnew.MODULE_List_Cast_to_MODULE(self)

   def Cast_to_TEXTE_MODULE(self):
        """Cast_to_TEXTE_MODULE(MODULE_List self) -> TEXTE_MODULE"""
        return _pcbnew.MODULE_List_Cast_to_TEXTE_MODULE(self)

   def Cast_to_DRAWSEGMENT(self):
        """Cast_to_DRAWSEGMENT(MODULE_List self) -> DRAWSEGMENT"""
        return _pcbnew.MODULE_List_Cast_to_DRAWSEGMENT(self)

   def Cast_to_MARKER_PCB(self):
        """Cast_to_MARKER_PCB(MODULE_List self) -> MARKER_PCB"""
        return _pcbnew.MODULE_List_Cast_to_MARKER_PCB(self)

   def Cast_to_BOARD(self):
        """Cast_to_BOARD(MODULE_List self) -> BOARD"""
        return _pcbnew.MODULE_List_Cast_to_BOARD(self)

   def Cast_to_EDGE_MODULE(self):
        """Cast_to_EDGE_MODULE(MODULE_List self) -> EDGE_MODULE"""
        return _pcbnew.MODULE_List_Cast_to_EDGE_MODULE(self)

   def Cast_to_D_PAD(self):
        """Cast_to_D_PAD(MODULE_List self) -> D_PAD"""
        return _pcbnew.MODULE_List_Cast_to_D_PAD(self)

   def Cast_to_TRACK(self):
        """Cast_to_TRACK(MODULE_List self) -> TRACK"""
        return _pcbnew.MODULE_List_Cast_to_TRACK(self)

   def Cast_to_VIA(self):
        """Cast_to_VIA(MODULE_List self) -> VIA"""
        return _pcbnew.MODULE_List_Cast_to_VIA(self)

   def Cast_to_ZONE_CONTAINER(self):
        """Cast_to_ZONE_CONTAINER(MODULE_List self) -> ZONE_CONTAINER"""
        return _pcbnew.MODULE_List_Cast_to_ZONE_CONTAINER(self)

   def Cast_to_PCB_TARGET(self):
        """Cast_to_PCB_TARGET(MODULE_List self) -> PCB_TARGET"""
        return _pcbnew.MODULE_List_Cast_to_PCB_TARGET(self)

   def Type(self):
        """
        Type(MODULE_List self) -> KICAD_T

        KICAD_T EDA_ITEM::Type() const

        Function Type()

        returns the type of object. This attribute should never be changed
        after a constructor sets it, so there is no public "setter" method.
        KICAD_T - the type of object.
        """
        return _pcbnew.MODULE_List_Type(self)

   def SetTimeStamp(self, *args):
        """
        SetTimeStamp(MODULE_List self, time_t aNewTimeStamp)

        void
        EDA_ITEM::SetTimeStamp(time_t aNewTimeStamp)
        """
        return _pcbnew.MODULE_List_SetTimeStamp(self, *args)

   def GetTimeStamp(self):
        """
        GetTimeStamp(MODULE_List self) -> time_t

        time_t
        EDA_ITEM::GetTimeStamp() const
        """
        return _pcbnew.MODULE_List_GetTimeStamp(self)

   def GetList(self):
        """
        GetList(MODULE_List self) -> DHEAD

        DHEAD* EDA_ITEM::GetList()
        const
        """
        return _pcbnew.MODULE_List_GetList(self)

   def SetParent(self, *args):
        """
        SetParent(MODULE_List self, EDA_ITEM aParent)

        void
        EDA_ITEM::SetParent(EDA_ITEM *aParent)
        """
        return _pcbnew.MODULE_List_SetParent(self, *args)

   def SetList(self, *args):
        """
        SetList(MODULE_List self, DHEAD aList)

        void
        EDA_ITEM::SetList(DHEAD *aList)
        """
        return _pcbnew.MODULE_List_SetList(self, *args)

   def IsNew(self):
        """
        IsNew(MODULE_List self) -> bool

        bool EDA_ITEM::IsNew() const

        """
        return _pcbnew.MODULE_List_IsNew(self)

   def IsModified(self):
        """
        IsModified(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsModified() const
        """
        return _pcbnew.MODULE_List_IsModified(self)

   def IsMoving(self):
        """
        IsMoving(MODULE_List self) -> bool

        bool EDA_ITEM::IsMoving()
        const
        """
        return _pcbnew.MODULE_List_IsMoving(self)

   def IsDragging(self):
        """
        IsDragging(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsDragging() const
        """
        return _pcbnew.MODULE_List_IsDragging(self)

   def IsWireImage(self):
        """
        IsWireImage(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsWireImage() const
        """
        return _pcbnew.MODULE_List_IsWireImage(self)

   def IsSelected(self):
        """
        IsSelected(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsSelected() const
        """
        return _pcbnew.MODULE_List_IsSelected(self)

   def IsResized(self):
        """
        IsResized(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsResized() const
        """
        return _pcbnew.MODULE_List_IsResized(self)

   def IsHighlighted(self):
        """
        IsHighlighted(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsHighlighted() const
        """
        return _pcbnew.MODULE_List_IsHighlighted(self)

   def IsBrightened(self):
        """
        IsBrightened(MODULE_List self) -> bool

        bool
        EDA_ITEM::IsBrightened() const
        """
        return _pcbnew.MODULE_List_IsBrightened(self)

   def SetWireImage(self):
        """
        SetWireImage(MODULE_List self)

        void
        EDA_ITEM::SetWireImage()
        """
        return _pcbnew.MODULE_List_SetWireImage(self)

   def SetSelected(self):
        """
        SetSelected(MODULE_List self)

        void
        EDA_ITEM::SetSelected()
        """
        return _pcbnew.MODULE_List_SetSelected(self)

   def SetHighlighted(self):
        """
        SetHighlighted(MODULE_List self)

        void
        EDA_ITEM::SetHighlighted()
        """
        return _pcbnew.MODULE_List_SetHighlighted(self)

   def SetBrightened(self):
        """
        SetBrightened(MODULE_List self)

        void
        EDA_ITEM::SetBrightened()
        """
        return _pcbnew.MODULE_List_SetBrightened(self)

   def ClearSelected(self):
        """
        ClearSelected(MODULE_List self)

        void
        EDA_ITEM::ClearSelected()
        """
        return _pcbnew.MODULE_List_ClearSelected(self)

   def ClearHighlighted(self):
        """
        ClearHighlighted(MODULE_List self)

        void
        EDA_ITEM::ClearHighlighted()
        """
        return _pcbnew.MODULE_List_ClearHighlighted(self)

   def ClearBrightened(self):
        """
        ClearBrightened(MODULE_List self)

        void
        EDA_ITEM::ClearBrightened()
        """
        return _pcbnew.MODULE_List_ClearBrightened(self)

   def SetModified(self):
        """
        SetModified(MODULE_List self)

        void
        EDA_ITEM::SetModified()
        """
        return _pcbnew.MODULE_List_SetModified(self)

   def GetState(self, *args):
        """
        GetState(MODULE_List self, int type) -> int

        int EDA_ITEM::GetState(int
        type) const
        """
        return _pcbnew.MODULE_List_GetState(self, *args)

   def SetState(self, *args):
        """
        SetState(MODULE_List self, int type, int state)

        void
        EDA_ITEM::SetState(int type, int state)
        """
        return _pcbnew.MODULE_List_SetState(self, *args)

   def GetStatus(self):
        """
        GetStatus(MODULE_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetStatus() const
        """
        return _pcbnew.MODULE_List_GetStatus(self)

   def SetStatus(self, *args):
        """
        SetStatus(MODULE_List self, STATUS_FLAGS aStatus)

        void
        EDA_ITEM::SetStatus(STATUS_FLAGS aStatus)
        """
        return _pcbnew.MODULE_List_SetStatus(self, *args)

   def SetFlags(self, *args):
        """
        SetFlags(MODULE_List self, STATUS_FLAGS aMask)

        void
        EDA_ITEM::SetFlags(STATUS_FLAGS aMask)
        """
        return _pcbnew.MODULE_List_SetFlags(self, *args)

   def ClearFlags(self, *args):
        """
        ClearFlags(MODULE_List self, STATUS_FLAGS aMask=-1)
        ClearFlags(MODULE_List self)

        void
        EDA_ITEM::ClearFlags(STATUS_FLAGS aMask=EDA_ITEM_ALL_FLAGS)
        """
        return _pcbnew.MODULE_List_ClearFlags(self, *args)

   def GetFlags(self):
        """
        GetFlags(MODULE_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetFlags() const
        """
        return _pcbnew.MODULE_List_GetFlags(self)

   def SetImage(self, *args):
        """
        SetImage(MODULE_List self, EDA_ITEM aItem)

        void
        EDA_ITEM::SetImage(EDA_ITEM *aItem)
        """
        return _pcbnew.MODULE_List_SetImage(self, *args)

   def SetForceVisible(self, *args):
        """
        SetForceVisible(MODULE_List self, bool aEnable)

        void
        EDA_ITEM::SetForceVisible(bool aEnable)

        Function SetForceVisible is used to set and cleag force visible flag
        used to force the item to be drawn even if it's draw attribute is set
        to not visible.

        Parameters:
        -----------

        aEnable:  True forces the item to be drawn. False uses the item's
        visibility setting to determine if the item is to be drawn.
        """
        return _pcbnew.MODULE_List_SetForceVisible(self, *args)

   def IterateForward(self, *args):
        """IterateForward(MODULE_List self, EDA_ITEM listStart, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT"""
        return _pcbnew.MODULE_List_IterateForward(self, *args)

   def Matches(self, *args):
        """
        Matches(MODULE_List self, wxFindReplaceData & aSearchData, void * aAuxData, wxPoint aFindLocation) -> bool
        Matches(MODULE_List self, wxString const & aText, wxFindReplaceData & aSearchData) -> bool

        bool
        EDA_ITEM::Matches(const wxString &aText, wxFindReplaceData
        &aSearchData)

        Function Matches compares aText against search criteria in
        aSearchData.

        Parameters:
        -----------

        aText:  A reference to a wxString object containing the string to
        test.

        aSearchData:  The criteria to search against.

        True if aText matches the search criteria in aSearchData.
        """
        return _pcbnew.MODULE_List_Matches(self, *args)

   def Replace(self, *args):
        """
        Replace(MODULE_List self, wxFindReplaceData & aSearchData, wxString & aText) -> bool
        Replace(MODULE_List self, wxFindReplaceData & aSearchData, void * aAuxData=None) -> bool
        Replace(MODULE_List self, wxFindReplaceData & aSearchData) -> bool

        virtual bool
        EDA_ITEM::Replace(wxFindReplaceData &aSearchData, void *aAuxData=NULL)

        Function Replace performs a text replace using the find and replace
        criteria in aSearchData on items that support text find and replace.

        This function must be overridden for items that support text replace.

        Parameters:
        -----------

        aSearchData:  A reference to a wxFindReplaceData object containing the
        search and replace criteria.

        aAuxData:  A pointer to optional data required for the search or NULL
        if not used.

        True if the item text was modified, otherwise false.
        """
        return _pcbnew.MODULE_List_Replace(self, *args)

   def IsReplaceable(self):
        """
        IsReplaceable(MODULE_List self) -> bool

        virtual bool
        EDA_ITEM::IsReplaceable() const

        Function IsReplaceable.

        Override this method in any derived object that supports test find and
        replace.

        True if the item has replaceable text that can be modified using the
        find and replace dialog.
        """
        return _pcbnew.MODULE_List_IsReplaceable(self)

   def __lt__(self, *args):
        """__lt__(MODULE_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.MODULE_List___lt__(self, *args)

   def Sort(self, *args):
        """Sort(MODULE_List self, EDA_ITEM aLeft, EDA_ITEM aRight) -> bool"""
        return _pcbnew.MODULE_List_Sort(self, *args)

MODULE_List_swigregister = _pcbnew.MODULE_List_swigregister
MODULE_List_swigregister(MODULE_List)

class TRACK_List(DHEAD):
    """Proxy of C++ DLIST<(TRACK)> class"""
    __swig_setmethods__ = {}
    for _s in [DHEAD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TRACK_List, name, value)
    __swig_getmethods__ = {}
    for _s in [DHEAD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, TRACK_List, name)
    __repr__ = _swig_repr
   def Get(self):
        """Get(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_Get(self)

   def __deref__(self):
        """__deref__(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List___deref__(self)

   def GetFirst(self):
        """GetFirst(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_GetFirst(self)

   def GetLast(self):
        """GetLast(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_GetLast(self)

   def Append(self, *args):
        """
        Append(TRACK_List self, TRACK aNewElement)
        Append(TRACK_List self, TRACK_List aList)
        """
        return _pcbnew.TRACK_List_Append(self, *args)

   def Insert(self, *args):
        """Insert(TRACK_List self, TRACK aNewElement, TRACK aElementAfterMe)"""
        return _pcbnew.TRACK_List_Insert(self, *args)

   def Remove(self, *args):
        """Remove(TRACK_List self, TRACK aElement) -> TRACK"""
        return _pcbnew.TRACK_List_Remove(self, *args)

   def begin(self):
        """begin(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_begin(self)

   def end(self):
        """end(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_end(self)

   def PopFront(self):
        """PopFront(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_PopFront(self)

   def PopBack(self):
        """PopBack(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_PopBack(self)

   def PushFront(self, *args):
        """PushFront(TRACK_List self, TRACK aNewElement)"""
        return _pcbnew.TRACK_List_PushFront(self, *args)

   def PushBack(self, *args):
        """PushBack(TRACK_List self, TRACK aNewElement)"""
        return _pcbnew.TRACK_List_PushBack(self, *args)

    class DLISTIter:
       def __init__(self,aList):
            self.last = aList   # last item is the start of list

       def next(self):         # get the next item

            item = self.last
            try:
              item = item.Get()
            except:
              pass

            if item is None:    # if the item is None, then finish the iteration
                raise StopIteration
            else:
                ret = None


                try:
                    ret = self.last.Get()
                except:
                    ret = self.last # next items do not..

                self.last = self.last.Next()



                if 'Cast' in dir(ret):
                    ret = ret.Cast()

                return ret

   def __iter__(self):
        return self.DLISTIter(self)


   def __init__(self):
        """__init__(DLIST<(TRACK)> self) -> TRACK_List"""
        this = _pcbnew.new_TRACK_List()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_TRACK_List
    __del__ = lambda self : None;
   def ClassOf(self, *args):
        """ClassOf(TRACK_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.TRACK_List_ClassOf(self, *args)

    __swig_setmethods__["start"] = _pcbnew.TRACK_List_start_set
    __swig_getmethods__["start"] = _pcbnew.TRACK_List_start_get
    if _newclass:start = _swig_property(_pcbnew.TRACK_List_start_get, _pcbnew.TRACK_List_start_set)
    __swig_setmethods__["end"] = _pcbnew.TRACK_List_end_set
    __swig_getmethods__["end"] = _pcbnew.TRACK_List_end_get
    if _newclass:end = _swig_property(_pcbnew.TRACK_List_end_get, _pcbnew.TRACK_List_end_set)
    __swig_setmethods__["m_Param"] = _pcbnew.TRACK_List_m_Param_set
    __swig_getmethods__["m_Param"] = _pcbnew.TRACK_List_m_Param_get
    if _newclass:m_Param = _swig_property(_pcbnew.TRACK_List_m_Param_get, _pcbnew.TRACK_List_m_Param_set)
   def Next(self):
        """
        Next(TRACK_List self) -> TRACK

        TRACK* TRACK::Next() const
        """
        return _pcbnew.TRACK_List_Next(self)

   def Back(self):
        """
        Back(TRACK_List self) -> TRACK

        TRACK* TRACK::Back() const
        """
        return _pcbnew.TRACK_List_Back(self)

   def Move(self, *args):
        """
        Move(TRACK_List self, wxPoint aMoveVector)

        virtual void TRACK::Move(const
        wxPoint &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.TRACK_List_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(TRACK_List self, wxPoint aRotCentre, double aAngle)

        void TRACK::Rotate(const
        wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.TRACK_List_Rotate(self, *args)

   def Flip(self, *args):
        """
        Flip(TRACK_List self, wxPoint aCentre)

        void TRACK::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.TRACK_List_Flip(self, *args)

   def SetPosition(self, *args):
        """
        SetPosition(TRACK_List self, wxPoint aPos)

        void
        TRACK::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.TRACK_List_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(TRACK_List self) -> wxPoint

        const wxPoint&
        TRACK::GetPosition() const
        """
        return _pcbnew.TRACK_List_GetPosition(self)

   def SetWidth(self, *args):
        """
        SetWidth(TRACK_List self, int aWidth)

        void TRACK::SetWidth(int
        aWidth)
        """
        return _pcbnew.TRACK_List_SetWidth(self, *args)

   def GetWidth(self):
        """
        GetWidth(TRACK_List self) -> int

        int TRACK::GetWidth() const

        """
        return _pcbnew.TRACK_List_GetWidth(self)

   def SetEnd(self, *args):
        """
        SetEnd(TRACK_List self, wxPoint aEnd)

        void TRACK::SetEnd(const
        wxPoint &aEnd)
        """
        return _pcbnew.TRACK_List_SetEnd(self, *args)

   def GetEnd(self):
        """
        GetEnd(TRACK_List self) -> wxPoint

        const wxPoint& TRACK::GetEnd()
        const
        """
        return _pcbnew.TRACK_List_GetEnd(self)

   def SetStart(self, *args):
        """
        SetStart(TRACK_List self, wxPoint aStart)

        void TRACK::SetStart(const
        wxPoint &aStart)
        """
        return _pcbnew.TRACK_List_SetStart(self, *args)

   def GetStart(self):
        """
        GetStart(TRACK_List self) -> wxPoint

        const wxPoint&
        TRACK::GetStart() const
        """
        return _pcbnew.TRACK_List_GetStart(self)

   def GetEndPoint(self, *args):
        """
        GetEndPoint(TRACK_List self, ENDPOINT_T aEndPoint) -> wxPoint

        const wxPoint&
        TRACK::GetEndPoint(ENDPOINT_T aEndPoint) const

        Return the selected endpoint (start or end)
        """
        return _pcbnew.TRACK_List_GetEndPoint(self, *args)

   def GetBoundingBox(self):
        """
        GetBoundingBox(TRACK_List self) -> EDA_RECT

        const EDA_RECT
        TRACK::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.TRACK_List_GetBoundingBox(self)

   def GetBestInsertPoint(self, *args):
        """
        GetBestInsertPoint(TRACK_List self, BOARD aPcb) -> TRACK

        TRACK *
        TRACK::GetBestInsertPoint(BOARD *aPcb)

        Function GetBestInsertPoint searches the "best" insertion point
        within the track linked list.

        The best point is the begging of the corresponding net code section.
        (The BOARD::m_Track and BOARD::m_Zone lists are sorted by netcode.)

        Parameters:
        -----------

        aPcb:  The BOARD to search for the insertion point.

        TRACK* - the item found in the linked list (or NULL if no track)
        """
        return _pcbnew.TRACK_List_GetBestInsertPoint(self, *args)

   def GetStartNetCode(self, *args):
        """
        GetStartNetCode(TRACK_List self, int NetCode) -> TRACK

        TRACK *
        TRACK::GetStartNetCode(int NetCode)
        """
        return _pcbnew.TRACK_List_GetStartNetCode(self, *args)

   def GetEndNetCode(self, *args):
        """
        GetEndNetCode(TRACK_List self, int NetCode) -> TRACK

        TRACK *
        TRACK::GetEndNetCode(int NetCode)
        """
        return _pcbnew.TRACK_List_GetEndNetCode(self, *args)

   def GetLength(self):
        """
        GetLength(TRACK_List self) -> double

        double TRACK::GetLength()
        const

        Function GetLength returns the length of the track using the
        hypotenuse calculation.

        double - the length of the track
        """
        return _pcbnew.TRACK_List_GetLength(self)

   def Draw(self, *args):
        """
        Draw(TRACK_List self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(TRACK_List self, EDA_DRAW_PANEL * panel, wxDC * DC, GR_DRAWMODE aDrawMode)

        void TRACK::Draw(EDA_DRAW_PANEL
        *panel, wxDC *DC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.TRACK_List_Draw(self, *args)

   def TransformShapeWithClearanceToPolygon(self, *args):
        """
        TransformShapeWithClearanceToPolygon(TRACK_List self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount, double aCorrectionFactor)

        void TRACK::TransformShapeWithClearanceToPolygon(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount,
        double aCorrectionFactor) const

        Function TransformShapeWithClearanceToPolygon Convert the track shape
        to a closed polygon Used in filling zones calculations Circles (vias)
        and arcs (ends of tracks) are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the pad

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approximated by segment bigger or
        equal to the real clearance value (usually near from 1.0)
        """
        return _pcbnew.TRACK_List_TransformShapeWithClearanceToPolygon(self, *args)

   def GetLayerSet(self):
        """
        GetLayerSet(TRACK_List self) -> LSET

        LSET TRACK::GetLayerSet()
        const

        Function GetLayerMask returns a "layer mask", which is a bitmap of
        all layers on which the TRACK segment or VIA physically resides.

        int - a layer mask, see pcbstruct.h's LAYER_BACK, etc.
        """
        return _pcbnew.TRACK_List_GetLayerSet(self)

   def IsPointOnEnds(self, *args):
        """
        IsPointOnEnds(TRACK_List self, wxPoint point, int min_dist=0) -> STATUS_FLAGS
        IsPointOnEnds(TRACK_List self, wxPoint point) -> STATUS_FLAGS

        STATUS_FLAGS
        TRACK::IsPointOnEnds(const wxPoint &point, int min_dist=0)

        Function IsPointOnEnds returns STARTPOINT if point if near (dist =
        min_dist) start point, ENDPOINT if point if near (dist = min_dist) end
        point,STARTPOINT|ENDPOINT if point if near (dist = min_dist) both
        ends, or 0 if none of the above.

        if min_dist < 0: min_dist = track_width/2
        """
        return _pcbnew.TRACK_List_IsPointOnEnds(self, *args)

   def IsNull(self):
        """
        IsNull(TRACK_List self) -> bool

        bool TRACK::IsNull()

        Function IsNull returns true if segment length is zero.
        """
        return _pcbnew.TRACK_List_IsNull(self)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(TRACK_List self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        TRACK::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.TRACK_List_GetMsgPanelInfo(self, *args)

   def ShowWidth(self):
        """
        ShowWidth(TRACK_List self) -> wxString

        wxString TRACK::ShowWidth()
        const

        Function ShowWidth returns the width of the track in displayable user
        units.
        """
        return _pcbnew.TRACK_List_ShowWidth(self)

   def Visit(self, *args):
        """
        Visit(TRACK_List self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        TRACK::Visit(INSPECTOR *inspector, const void *testData, const KICAD_T
        scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.TRACK_List_Visit(self, *args)

   def HitTest(self, *args):
        """
        HitTest(TRACK_List self, wxPoint aPosition) -> bool
        HitTest(TRACK_List self, EDA_RECT aRect, bool aContained=True, int aAccuracy=0) -> bool
        HitTest(TRACK_List self, EDA_RECT aRect, bool aContained=True) -> bool
        HitTest(TRACK_List self, EDA_RECT aRect) -> bool

        bool TRACK::HitTest(const
        EDA_RECT &aRect, bool aContained=true, int aAccuracy=0) const

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.TRACK_List_HitTest(self, *args)

   def GetVia(self, *args):
        """
        GetVia(TRACK_List self, wxPoint aPosition, LAYER_ID aLayer=UNDEFINED_LAYER) -> VIA
        GetVia(TRACK_List self, wxPoint aPosition) -> VIA
        GetVia(TRACK_List self, TRACK aEndTrace, wxPoint aPosition, LSET aLayerMask) -> VIA

        VIA * TRACK::GetVia(TRACK
        *aEndTrace, const wxPoint &aPosition, LSET aLayerMask)

        Function GetVia finds the first VIA object at aPosition on aLayer
        starting at the trace and ending at aEndTrace.

        Parameters:
        -----------

        aEndTrace:  Pointer to the last TRACK object to end search.

        aPosition:  The wxPoint to HitTest() against.

        aLayerMask:  The layers to match, pass -1 for a don't care.

        A pointer to a VIA object if found, else NULL.
        """
        return _pcbnew.TRACK_List_GetVia(self, *args)

   def GetTrack(self, *args):
        """
        GetTrack(TRACK_List self, TRACK aStartTrace, TRACK aEndTrace, ENDPOINT_T aEndPoint, bool aSameNetOnly, bool aSequential) -> TRACK

        TRACK * TRACK::GetTrack(TRACK
        *aStartTrace, TRACK *aEndTrace, ENDPOINT_T aEndPoint, bool
        aSameNetOnly, bool aSequential)

        Function GetTrack return the trace segment connected to the segment at
        aEndPoint from aStartTrace to aEndTrace.

        Parameters:
        -----------

        aStartTrace:  A pointer to the TRACK object to begin searching.

        aEndTrace:  A pointer to the TRACK object to stop the search. A NULL
        value searches to the end of the list.

        aEndPoint:  The start or end point of the segment to test against.

        aSameNetOnly:  if true stop searching when the netcode changes

        aSequential:  If true, forces a forward sequential search, which is
       restartable; the default search can be faster but the position of the
        returned track in the list is unpredictable

        A TRACK object pointer if found otherwise NULL.
        """
        return _pcbnew.TRACK_List_GetTrack(self, *args)

   def GetEndSegments(self, *args):
        """
        GetEndSegments(TRACK_List self, int NbSegm, TRACK ** StartTrack, TRACK ** EndTrack) -> int

        int
        TRACK::GetEndSegments(int NbSegm, TRACK **StartTrack, TRACK
        **EndTrack)

        Function GetEndSegments get the segments connected to the end point of
        the track.

        return 1 if OK, 0 when a track is a closed loop and the beginning and
        the end of the track in *StartTrack and *EndTrack Modify *StartTrack
        en *EndTrack : (*StartTrack)->m_Start coordinate is the beginning of
        the track (*EndTrack)->m_End coordinate is the end of the track
        Segments connected must be consecutive in list
        """
        return _pcbnew.TRACK_List_GetEndSegments(self, *args)

   def GetClass(self):
        """
        GetClass(TRACK_List self) -> wxString

        wxString TRACK::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.TRACK_List_GetClass(self)

   def GetClearance(self, aItem=None):
        """
        GetClearance(TRACK_List self, BOARD_CONNECTED_ITEM aItem=None) -> int
        GetClearance(TRACK_List self) -> int

        int
        TRACK::GetClearance(BOARD_CONNECTED_ITEM *aItem=NULL) const

        Function GetClearance returns the clearance in internal units.

        If aItem is not NULL then the returned clearance is the greater of
        this object's clearance and aItem's clearance. If aItem is NULL, then
        this objects clearance is returned.

        Parameters:
        -----------

        aItem:  is another BOARD_CONNECTED_ITEM or NULL

        int - the clearance in internal units.
        """
        return _pcbnew.TRACK_List_GetClearance(self, aItem)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(TRACK_List self) -> wxString

        wxString
        TRACK::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.TRACK_List_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(TRACK_List self) -> BITMAP_DEF

        virtual BITMAP_DEF
        TRACK::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.TRACK_List_GetMenuImage(self)

   def Clone(self):
        """
        Clone(TRACK_List self) -> EDA_ITEM

        EDA_ITEM * TRACK::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.TRACK_List_Clone(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(TRACK_List self, int [] aLayers, int & aCount)

        void
        TRACK::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.TRACK_List_ViewGetLayers(self, *args)

   def ViewGetLOD(self, *args):
        """
        ViewGetLOD(TRACK_List self, int aLayer) -> unsigned int

        unsigned int
        TRACK::ViewGetLOD(int aLayer) const
        """
        return _pcbnew.TRACK_List_ViewGetLOD(self, *args)

    __swig_setmethods__["m_TracksConnected"] = _pcbnew.TRACK_List_m_TracksConnected_set
    __swig_getmethods__["m_TracksConnected"] = _pcbnew.TRACK_List_m_TracksConnected_get
    if _newclass:m_TracksConnected = _swig_property(_pcbnew.TRACK_List_m_TracksConnected_get, _pcbnew.TRACK_List_m_TracksConnected_set)
    __swig_setmethods__["m_PadsConnected"] = _pcbnew.TRACK_List_m_PadsConnected_set
    __swig_getmethods__["m_PadsConnected"] = _pcbnew.TRACK_List_m_PadsConnected_get
    if _newclass:m_PadsConnected = _swig_property(_pcbnew.TRACK_List_m_PadsConnected_get, _pcbnew.TRACK_List_m_PadsConnected_set)
   def IsConnected(self):
        """
        IsConnected(TRACK_List self) -> bool

        bool
        BOARD_CONNECTED_ITEM::IsConnected() const

        >

        Function IsConnected() Returns information if the object is derived
        from BOARD_CONNECTED_ITEM. True if the object is of
        BOARD_CONNECTED_ITEM type, false otherwise.
        """
        return _pcbnew.TRACK_List_IsConnected(self)

   def GetNet(self):
        """
        GetNet(TRACK_List self) -> NETINFO_ITEM

        NETINFO_ITEM*
        BOARD_CONNECTED_ITEM::GetNet() const

        Function GetNet Returns NET_INFO object for a given item.
        """
        return _pcbnew.TRACK_List_GetNet(self)

   def GetNetCode(self):
        """
        GetNetCode(TRACK_List self) -> int

        int
        BOARD_CONNECTED_ITEM::GetNetCode() const

        Function GetNetCode.

        int - the net code.
        """
        return _pcbnew.TRACK_List_GetNetCode(self)

   def SetNetCode(self, *args):
        """
        SetNetCode(TRACK_List self, int aNetCode)

        void
        BOARD_CONNECTED_ITEM::SetNetCode(int aNetCode)

        Function SetNetCode sets net using a net code.

        Parameters:
        -----------

        aNetCode:  is a net code for the new net. It has to exist in
        NETINFO_LIST held by BOARD. Otherwise, item is assigned to the
        unconnected net.
        """
        return _pcbnew.TRACK_List_SetNetCode(self, *args)

   def GetSubNet(self):
        """
        GetSubNet(TRACK_List self) -> int

        int
        BOARD_CONNECTED_ITEM::GetSubNet() const

        Function GetSubNet.

        int - the sub net code.
        """
        return _pcbnew.TRACK_List_GetSubNet(self)

   def SetSubNet(self, *args):
        """
        SetSubNet(TRACK_List self, int aSubNetCode)

        void
        BOARD_CONNECTED_ITEM::SetSubNet(int aSubNetCode)
        """
        return _pcbnew.TRACK_List_SetSubNet(self, *args)

   def GetZoneSubNet(self):
        """
        GetZoneSubNet(TRACK_List self) -> int

        int
        BOARD_CONNECTED_ITEM::GetZoneSubNet() const

        Function GetZoneSubNet.

        int - the sub net code in zone connections.
        """
        return _pcbnew.TRACK_List_GetZoneSubNet(self)

   def SetZoneSubNet(self, *args):
        """
        SetZoneSubNet(TRACK_List self, int aSubNetCode)

        void
        BOARD_CONNECTED_ITEM::SetZoneSubNet(int aSubNetCode)
        """
        return _pcbnew.TRACK_List_SetZoneSubNet(self, *args)

   def GetNetname(self):
        """
        GetNetname(TRACK_List self) -> wxString const &

        const
        wxString& BOARD_CONNECTED_ITEM::GetNetname() const

        Function GetNetname.

        wxString - the full netname
        """
        return _pcbnew.TRACK_List_GetNetname(self)

   def GetShortNetname(self):
        """
        GetShortNetname(TRACK_List self) -> wxString const &

        const
        wxString& BOARD_CONNECTED_ITEM::GetShortNetname() const

        Function GetShortNetname.

        wxString - the short netname
        """
        return _pcbnew.TRACK_List_GetShortNetname(self)

   def GetNetClass(self):
        """
        GetNetClass(TRACK_List self) -> boost::shared_ptr< NETCLASS >

        NETCLASSPTR
        BOARD_CONNECTED_ITEM::GetNetClass() const

        Function GetNetClass returns the NETCLASS for this item.
        """
        return _pcbnew.TRACK_List_GetNetClass(self)

   def GetNetClassName(self):
        """
        GetNetClassName(TRACK_List self) -> wxString

        wxString BOARD_CONNECTED_ITEM::GetNetClassName() const

        Function GetNetClassName returns a pointer to the netclass of the
        zone.

        If the net is not found (can happen when a netlist is reread, and the
       net name does not exist, return the default net class (should not
        return a null pointer). the Net Class name of this item
        """
        return _pcbnew.TRACK_List_GetNetClassName(self)

   def GetParent(self):
        """
        GetParent(TRACK_List self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::GetParent() const
        """
        return _pcbnew.TRACK_List_GetParent(self)

   def GetLayer(self):
        """
        GetLayer(TRACK_List self) -> LAYER_ID

        LAYER_ID
        BOARD_ITEM::GetLayer() const

        Function GetLayer returns the layer this item is on.
        """
        return _pcbnew.TRACK_List_GetLayer(self)

   def SetLayer(self, *args):
        """
        SetLayer(TRACK_List self, LAYER_ID aLayer)

        virtual void
        BOARD_ITEM::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.TRACK_List_SetLayer(self, *args)

   def SwapData(self, *args):
        """
        SwapData(TRACK_List self, BOARD_ITEM aImage)

        void
        BOARD_ITEM::SwapData(BOARD_ITEM *aImage)

        Swap data between aItem and aImage.

        aItem and aImage should have the same type Used in undo redo command
        to swap values between an item and its copy Only values like layer,
        size .. which are modified by edition are swapped, not the pointers
        like Pnext and Pback because aItem is not changed in the linked list

        Parameters:
        -----------

        aImage:  = the item image which contains data to swap
        """
        return _pcbnew.TRACK_List_SwapData(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(TRACK_List self, LAYER_ID aLayer) -> bool

        virtual bool
        BOARD_ITEM::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.TRACK_List_IsOnLayer(self, *args)

   def IsTrack(self):
        """
        IsTrack(TRACK_List self) -> bool

        bool
        BOARD_ITEM::IsTrack() const

        Function IsTrack tests to see if this object is a track or via (or
        microvia).

        form of testing. bool - true if a track or via, else false.
        """
        return _pcbnew.TRACK_List_IsTrack(self)

   def IsLocked(self):
        """
        IsLocked(TRACK_List self) -> bool

        virtual bool
        BOARD_ITEM::IsLocked() const

        Function IsLocked.

        bool - true if the object is locked, else false
        """
        return _pcbnew.TRACK_List_IsLocked(self)

   def UnLink(self):
        """
        UnLink(TRACK_List self)

        void BOARD_ITEM::UnLink()

        Function UnLink detaches this object from its owner.

        This base class implementation should work for all derived classes
        which are held in a DLIST<>.
        """
        return _pcbnew.TRACK_List_UnLink(self)

   def DeleteStructure(self):
        """
        DeleteStructure(TRACK_List self)

        void
        BOARD_ITEM::DeleteStructure()

        Function DeleteStructure deletes this object after UnLink()ing it from
        its owner if it has one.
        """
        return _pcbnew.TRACK_List_DeleteStructure(self)

   def ShowShape(self, *args):
        """ShowShape(TRACK_List self, STROKE_T aShape) -> wxString"""
        return _pcbnew.TRACK_List_ShowShape(self, *args)

   def GetBoard(self):
        """
        GetBoard(TRACK_List self) -> BOARD

        BOARD *
        BOARD_ITEM::GetBoard() const

        Function GetBoard returns the BOARD in which this BOARD_ITEM resides,
        or NULL if none.
        """
        return _pcbnew.TRACK_List_GetBoard(self)

   def GetLayerName(self):
        """
        GetLayerName(TRACK_List self) -> wxString

        wxString
        BOARD_ITEM::GetLayerName() const

        Function GetLayerName returns the name of the PCB layer on which the
        item resides.

        wxString containing the layer name associated with this item.
        """
        return _pcbnew.TRACK_List_GetLayerName(self)

   def FormatInternalUnits(self, *args):
        """
        FormatInternalUnits(TRACK_List self, int aValue) -> std::string
        FormatInternalUnits(TRACK_List self, wxPoint aPoint) -> std::string
        FormatInternalUnits(TRACK_List self, wxSize aSize) -> std::string
        """
        return _pcbnew.TRACK_List_FormatInternalUnits(self, *args)

   def FormatAngle(self, *args):
        """FormatAngle(TRACK_List self, double aAngle) -> std::string"""
        return _pcbnew.TRACK_List_FormatAngle(self, *args)

   def Cast_to_TEXTE_PCB(self):
        """Cast_to_TEXTE_PCB(TRACK_List self) -> TEXTE_PCB"""
        return _pcbnew.TRACK_List_Cast_to_TEXTE_PCB(self)

   def Cast_to_DIMENSION(self):
        """Cast_to_DIMENSION(TRACK_List self) -> DIMENSION"""
        return _pcbnew.TRACK_List_Cast_to_DIMENSION(self)

   def Cast_to_MODULE(self):
        """Cast_to_MODULE(TRACK_List self) -> MODULE"""
        return _pcbnew.TRACK_List_Cast_to_MODULE(self)

   def Cast_to_TEXTE_MODULE(self):
        """Cast_to_TEXTE_MODULE(TRACK_List self) -> TEXTE_MODULE"""
        return _pcbnew.TRACK_List_Cast_to_TEXTE_MODULE(self)

   def Cast_to_DRAWSEGMENT(self):
        """Cast_to_DRAWSEGMENT(TRACK_List self) -> DRAWSEGMENT"""
        return _pcbnew.TRACK_List_Cast_to_DRAWSEGMENT(self)

   def Cast_to_MARKER_PCB(self):
        """Cast_to_MARKER_PCB(TRACK_List self) -> MARKER_PCB"""
        return _pcbnew.TRACK_List_Cast_to_MARKER_PCB(self)

   def Cast_to_BOARD(self):
        """Cast_to_BOARD(TRACK_List self) -> BOARD"""
        return _pcbnew.TRACK_List_Cast_to_BOARD(self)

   def Cast_to_EDGE_MODULE(self):
        """Cast_to_EDGE_MODULE(TRACK_List self) -> EDGE_MODULE"""
        return _pcbnew.TRACK_List_Cast_to_EDGE_MODULE(self)

   def Cast_to_D_PAD(self):
        """Cast_to_D_PAD(TRACK_List self) -> D_PAD"""
        return _pcbnew.TRACK_List_Cast_to_D_PAD(self)

   def Cast_to_TRACK(self):
        """Cast_to_TRACK(TRACK_List self) -> TRACK"""
        return _pcbnew.TRACK_List_Cast_to_TRACK(self)

   def Cast_to_VIA(self):
        """Cast_to_VIA(TRACK_List self) -> VIA"""
        return _pcbnew.TRACK_List_Cast_to_VIA(self)

   def Cast_to_ZONE_CONTAINER(self):
        """Cast_to_ZONE_CONTAINER(TRACK_List self) -> ZONE_CONTAINER"""
        return _pcbnew.TRACK_List_Cast_to_ZONE_CONTAINER(self)

   def Cast_to_PCB_TARGET(self):
        """Cast_to_PCB_TARGET(TRACK_List self) -> PCB_TARGET"""
        return _pcbnew.TRACK_List_Cast_to_PCB_TARGET(self)

   def Type(self):
        """
        Type(TRACK_List self) -> KICAD_T

        KICAD_T EDA_ITEM::Type() const

        Function Type()

        returns the type of object. This attribute should never be changed
        after a constructor sets it, so there is no public "setter" method.
        KICAD_T - the type of object.
        """
        return _pcbnew.TRACK_List_Type(self)

   def SetTimeStamp(self, *args):
        """
        SetTimeStamp(TRACK_List self, time_t aNewTimeStamp)

        void
        EDA_ITEM::SetTimeStamp(time_t aNewTimeStamp)
        """
        return _pcbnew.TRACK_List_SetTimeStamp(self, *args)

   def GetTimeStamp(self):
        """
        GetTimeStamp(TRACK_List self) -> time_t

        time_t
        EDA_ITEM::GetTimeStamp() const
        """
        return _pcbnew.TRACK_List_GetTimeStamp(self)

   def GetList(self):
        """
        GetList(TRACK_List self) -> DHEAD

        DHEAD* EDA_ITEM::GetList()
        const
        """
        return _pcbnew.TRACK_List_GetList(self)

   def SetParent(self, *args):
        """
        SetParent(TRACK_List self, EDA_ITEM aParent)

        void
        EDA_ITEM::SetParent(EDA_ITEM *aParent)
        """
        return _pcbnew.TRACK_List_SetParent(self, *args)

   def SetList(self, *args):
        """
        SetList(TRACK_List self, DHEAD aList)

        void
        EDA_ITEM::SetList(DHEAD *aList)
        """
        return _pcbnew.TRACK_List_SetList(self, *args)

   def IsNew(self):
        """
        IsNew(TRACK_List self) -> bool

        bool EDA_ITEM::IsNew() const

        """
        return _pcbnew.TRACK_List_IsNew(self)

   def IsModified(self):
        """
        IsModified(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsModified() const
        """
        return _pcbnew.TRACK_List_IsModified(self)

   def IsMoving(self):
        """
        IsMoving(TRACK_List self) -> bool

        bool EDA_ITEM::IsMoving()
        const
        """
        return _pcbnew.TRACK_List_IsMoving(self)

   def IsDragging(self):
        """
        IsDragging(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsDragging() const
        """
        return _pcbnew.TRACK_List_IsDragging(self)

   def IsWireImage(self):
        """
        IsWireImage(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsWireImage() const
        """
        return _pcbnew.TRACK_List_IsWireImage(self)

   def IsSelected(self):
        """
        IsSelected(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsSelected() const
        """
        return _pcbnew.TRACK_List_IsSelected(self)

   def IsResized(self):
        """
        IsResized(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsResized() const
        """
        return _pcbnew.TRACK_List_IsResized(self)

   def IsHighlighted(self):
        """
        IsHighlighted(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsHighlighted() const
        """
        return _pcbnew.TRACK_List_IsHighlighted(self)

   def IsBrightened(self):
        """
        IsBrightened(TRACK_List self) -> bool

        bool
        EDA_ITEM::IsBrightened() const
        """
        return _pcbnew.TRACK_List_IsBrightened(self)

   def SetWireImage(self):
        """
        SetWireImage(TRACK_List self)

        void
        EDA_ITEM::SetWireImage()
        """
        return _pcbnew.TRACK_List_SetWireImage(self)

   def SetSelected(self):
        """
        SetSelected(TRACK_List self)

        void
        EDA_ITEM::SetSelected()
        """
        return _pcbnew.TRACK_List_SetSelected(self)

   def SetHighlighted(self):
        """
        SetHighlighted(TRACK_List self)

        void
        EDA_ITEM::SetHighlighted()
        """
        return _pcbnew.TRACK_List_SetHighlighted(self)

   def SetBrightened(self):
        """
        SetBrightened(TRACK_List self)

        void
        EDA_ITEM::SetBrightened()
        """
        return _pcbnew.TRACK_List_SetBrightened(self)

   def ClearSelected(self):
        """
        ClearSelected(TRACK_List self)

        void
        EDA_ITEM::ClearSelected()
        """
        return _pcbnew.TRACK_List_ClearSelected(self)

   def ClearHighlighted(self):
        """
        ClearHighlighted(TRACK_List self)

        void
        EDA_ITEM::ClearHighlighted()
        """
        return _pcbnew.TRACK_List_ClearHighlighted(self)

   def ClearBrightened(self):
        """
        ClearBrightened(TRACK_List self)

        void
        EDA_ITEM::ClearBrightened()
        """
        return _pcbnew.TRACK_List_ClearBrightened(self)

   def SetModified(self):
        """
        SetModified(TRACK_List self)

        void
        EDA_ITEM::SetModified()
        """
        return _pcbnew.TRACK_List_SetModified(self)

   def GetState(self, *args):
        """
        GetState(TRACK_List self, int type) -> int

        int EDA_ITEM::GetState(int
        type) const
        """
        return _pcbnew.TRACK_List_GetState(self, *args)

   def SetState(self, *args):
        """
        SetState(TRACK_List self, int type, int state)

        void
        EDA_ITEM::SetState(int type, int state)
        """
        return _pcbnew.TRACK_List_SetState(self, *args)

   def GetStatus(self):
        """
        GetStatus(TRACK_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetStatus() const
        """
        return _pcbnew.TRACK_List_GetStatus(self)

   def SetStatus(self, *args):
        """
        SetStatus(TRACK_List self, STATUS_FLAGS aStatus)

        void
        EDA_ITEM::SetStatus(STATUS_FLAGS aStatus)
        """
        return _pcbnew.TRACK_List_SetStatus(self, *args)

   def SetFlags(self, *args):
        """
        SetFlags(TRACK_List self, STATUS_FLAGS aMask)

        void
        EDA_ITEM::SetFlags(STATUS_FLAGS aMask)
        """
        return _pcbnew.TRACK_List_SetFlags(self, *args)

   def ClearFlags(self, *args):
        """
        ClearFlags(TRACK_List self, STATUS_FLAGS aMask=-1)
        ClearFlags(TRACK_List self)

        void
        EDA_ITEM::ClearFlags(STATUS_FLAGS aMask=EDA_ITEM_ALL_FLAGS)
        """
        return _pcbnew.TRACK_List_ClearFlags(self, *args)

   def GetFlags(self):
        """
        GetFlags(TRACK_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetFlags() const
        """
        return _pcbnew.TRACK_List_GetFlags(self)

   def SetImage(self, *args):
        """
        SetImage(TRACK_List self, EDA_ITEM aItem)

        void
        EDA_ITEM::SetImage(EDA_ITEM *aItem)
        """
        return _pcbnew.TRACK_List_SetImage(self, *args)

   def SetForceVisible(self, *args):
        """
        SetForceVisible(TRACK_List self, bool aEnable)

        void
        EDA_ITEM::SetForceVisible(bool aEnable)

        Function SetForceVisible is used to set and cleag force visible flag
        used to force the item to be drawn even if it's draw attribute is set
        to not visible.

        Parameters:
        -----------

        aEnable:  True forces the item to be drawn. False uses the item's
        visibility setting to determine if the item is to be drawn.
        """
        return _pcbnew.TRACK_List_SetForceVisible(self, *args)

   def IterateForward(self, *args):
        """IterateForward(TRACK_List self, EDA_ITEM listStart, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT"""
        return _pcbnew.TRACK_List_IterateForward(self, *args)

   def Matches(self, *args):
        """
        Matches(TRACK_List self, wxFindReplaceData & aSearchData, void * aAuxData, wxPoint aFindLocation) -> bool
        Matches(TRACK_List self, wxString const & aText, wxFindReplaceData & aSearchData) -> bool

        bool
        EDA_ITEM::Matches(const wxString &aText, wxFindReplaceData
        &aSearchData)

        Function Matches compares aText against search criteria in
        aSearchData.

        Parameters:
        -----------

        aText:  A reference to a wxString object containing the string to
        test.

        aSearchData:  The criteria to search against.

        True if aText matches the search criteria in aSearchData.
        """
        return _pcbnew.TRACK_List_Matches(self, *args)

   def Replace(self, *args):
        """
        Replace(TRACK_List self, wxFindReplaceData & aSearchData, wxString & aText) -> bool
        Replace(TRACK_List self, wxFindReplaceData & aSearchData, void * aAuxData=None) -> bool
        Replace(TRACK_List self, wxFindReplaceData & aSearchData) -> bool

        virtual bool
        EDA_ITEM::Replace(wxFindReplaceData &aSearchData, void *aAuxData=NULL)

        Function Replace performs a text replace using the find and replace
        criteria in aSearchData on items that support text find and replace.

        This function must be overridden for items that support text replace.

        Parameters:
        -----------

        aSearchData:  A reference to a wxFindReplaceData object containing the
        search and replace criteria.

        aAuxData:  A pointer to optional data required for the search or NULL
        if not used.

        True if the item text was modified, otherwise false.
        """
        return _pcbnew.TRACK_List_Replace(self, *args)

   def IsReplaceable(self):
        """
        IsReplaceable(TRACK_List self) -> bool

        virtual bool
        EDA_ITEM::IsReplaceable() const

        Function IsReplaceable.

        Override this method in any derived object that supports test find and
        replace.

        True if the item has replaceable text that can be modified using the
        find and replace dialog.
        """
        return _pcbnew.TRACK_List_IsReplaceable(self)

   def __lt__(self, *args):
        """__lt__(TRACK_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.TRACK_List___lt__(self, *args)

   def Sort(self, *args):
        """Sort(TRACK_List self, EDA_ITEM aLeft, EDA_ITEM aRight) -> bool"""
        return _pcbnew.TRACK_List_Sort(self, *args)

   def ViewBBox(self):
        """
        ViewBBox(TRACK_List self) -> BOX2I const

        const BOX2I
        EDA_ITEM::ViewBBox() const
        """
        return _pcbnew.TRACK_List_ViewBBox(self)

TRACK_List_swigregister = _pcbnew.TRACK_List_swigregister
TRACK_List_swigregister(TRACK_List)

class PAD_List(DHEAD):
    """Proxy of C++ DLIST<(D_PAD)> class"""
    __swig_setmethods__ = {}
    for _s in [DHEAD]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PAD_List, name, value)
    __swig_getmethods__ = {}
    for _s in [DHEAD]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PAD_List, name)
    __repr__ = _swig_repr
   def Get(self):
        """Get(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_Get(self)

   def __deref__(self):
        """__deref__(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List___deref__(self)

   def GetFirst(self):
        """GetFirst(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_GetFirst(self)

   def GetLast(self):
        """GetLast(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_GetLast(self)

   def Append(self, *args):
        """
        Append(PAD_List self, D_PAD aNewElement)
        Append(PAD_List self, PAD_List aList)
        """
        return _pcbnew.PAD_List_Append(self, *args)

   def Insert(self, *args):
        """Insert(PAD_List self, D_PAD aNewElement, D_PAD aElementAfterMe)"""
        return _pcbnew.PAD_List_Insert(self, *args)

   def Remove(self, *args):
        """Remove(PAD_List self, D_PAD aElement) -> D_PAD"""
        return _pcbnew.PAD_List_Remove(self, *args)

   def begin(self):
        """begin(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_begin(self)

   def end(self):
        """end(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_end(self)

   def PopFront(self):
        """PopFront(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_PopFront(self)

   def PopBack(self):
        """PopBack(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_PopBack(self)

   def PushFront(self, *args):
        """PushFront(PAD_List self, D_PAD aNewElement)"""
        return _pcbnew.PAD_List_PushFront(self, *args)

   def PushBack(self, *args):
        """PushBack(PAD_List self, D_PAD aNewElement)"""
        return _pcbnew.PAD_List_PushBack(self, *args)

    class DLISTIter:
       def __init__(self,aList):
            self.last = aList   # last item is the start of list

       def next(self):         # get the next item

            item = self.last
            try:
              item = item.Get()
            except:
              pass

            if item is None:    # if the item is None, then finish the iteration
                raise StopIteration
            else:
                ret = None


                try:
                    ret = self.last.Get()
                except:
                    ret = self.last # next items do not..

                self.last = self.last.Next()



                if 'Cast' in dir(ret):
                    ret = ret.Cast()

                return ret

   def __iter__(self):
        return self.DLISTIter(self)


   def __init__(self):
        """__init__(DLIST<(D_PAD)> self) -> PAD_List"""
        this = _pcbnew.new_PAD_List()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PAD_List
    __del__ = lambda self : None;
   def StandardMask(self):
        """StandardMask(PAD_List self) -> LSET"""
        return _pcbnew.PAD_List_StandardMask(self)

   def SMDMask(self):
        """SMDMask(PAD_List self) -> LSET"""
        return _pcbnew.PAD_List_SMDMask(self)

   def ConnSMDMask(self):
        """ConnSMDMask(PAD_List self) -> LSET"""
        return _pcbnew.PAD_List_ConnSMDMask(self)

   def UnplatedHoleMask(self):
        """UnplatedHoleMask(PAD_List self) -> LSET"""
        return _pcbnew.PAD_List_UnplatedHoleMask(self)

   def Copy(self, *args):
        """
        Copy(PAD_List self, D_PAD source)

        void D_PAD::Copy(D_PAD *source)

        """
        return _pcbnew.PAD_List_Copy(self, *args)

   def Next(self):
        """
        Next(PAD_List self) -> D_PAD

        D_PAD* D_PAD::Next() const
        """
        return _pcbnew.PAD_List_Next(self)

   def GetParent(self):
        """
        GetParent(PAD_List self) -> MODULE

        MODULE* D_PAD::GetParent()
        const
        """
        return _pcbnew.PAD_List_GetParent(self)

   def SetPadName(self, *args):
        """
        SetPadName(PAD_List self, wxString const & name)

        void
        D_PAD::SetPadName(const wxString &name)
        """
        return _pcbnew.PAD_List_SetPadName(self, *args)

   def GetPadName(self):
        """
        GetPadName(PAD_List self) -> wxString const

        const wxString
        D_PAD::GetPadName() const
        """
        return _pcbnew.PAD_List_GetPadName(self)

   def PadNameEqual(self, *args):
        """
        PadNameEqual(PAD_List self, D_PAD other) -> bool

        bool
        D_PAD::PadNameEqual(const D_PAD *other) const
        """
        return _pcbnew.PAD_List_PadNameEqual(self, *args)

   def GetShape(self):
        """
        GetShape(PAD_List self) -> PAD_SHAPE_T

        PAD_SHAPE_T D_PAD::GetShape()
        const

        Function GetShape.

        the shape of this pad.
        """
        return _pcbnew.PAD_List_GetShape(self)

   def SetShape(self, *args):
        """
        SetShape(PAD_List self, PAD_SHAPE_T aShape)

        void
        D_PAD::SetShape(PAD_SHAPE_T aShape)
        """
        return _pcbnew.PAD_List_SetShape(self, *args)

   def SetPosition(self, *args):
        """
        SetPosition(PAD_List self, wxPoint aPos)

        void
        D_PAD::SetPosition(const wxPoint &aPos)
        """
        return _pcbnew.PAD_List_SetPosition(self, *args)

   def GetPosition(self):
        """
        GetPosition(PAD_List self) -> wxPoint

        const wxPoint&
        D_PAD::GetPosition() const
        """
        return _pcbnew.PAD_List_GetPosition(self)

   def SetY(self, *args):
        """
        SetY(PAD_List self, int y)

        void D_PAD::SetY(int y)
        """
        return _pcbnew.PAD_List_SetY(self, *args)

   def SetX(self, *args):
        """
        SetX(PAD_List self, int x)

        void D_PAD::SetX(int x)
        """
        return _pcbnew.PAD_List_SetX(self, *args)

   def SetPos0(self, *args):
        """
        SetPos0(PAD_List self, wxPoint aPos)

        void D_PAD::SetPos0(const
        wxPoint &aPos)
        """
        return _pcbnew.PAD_List_SetPos0(self, *args)

   def GetPos0(self):
        """
        GetPos0(PAD_List self) -> wxPoint

        const wxPoint&
        D_PAD::GetPos0() const
        """
        return _pcbnew.PAD_List_GetPos0(self)

   def SetY0(self, *args):
        """
        SetY0(PAD_List self, int y)

        void D_PAD::SetY0(int y)
        """
        return _pcbnew.PAD_List_SetY0(self, *args)

   def SetX0(self, *args):
        """
        SetX0(PAD_List self, int x)

        void D_PAD::SetX0(int x)
        """
        return _pcbnew.PAD_List_SetX0(self, *args)

   def SetSize(self, *args):
        """
        SetSize(PAD_List self, wxSize aSize)

        void D_PAD::SetSize(const
        wxSize &aSize)
        """
        return _pcbnew.PAD_List_SetSize(self, *args)

   def GetSize(self):
        """
        GetSize(PAD_List self) -> wxSize

        const wxSize& D_PAD::GetSize()
        const
        """
        return _pcbnew.PAD_List_GetSize(self)

   def SetDelta(self, *args):
        """
        SetDelta(PAD_List self, wxSize aSize)

        void D_PAD::SetDelta(const
        wxSize &aSize)
        """
        return _pcbnew.PAD_List_SetDelta(self, *args)

   def GetDelta(self):
        """
        GetDelta(PAD_List self) -> wxSize

        const wxSize&
        D_PAD::GetDelta() const
        """
        return _pcbnew.PAD_List_GetDelta(self)

   def SetDrillSize(self, *args):
        """
        SetDrillSize(PAD_List self, wxSize aSize)

        void
        D_PAD::SetDrillSize(const wxSize &aSize)
        """
        return _pcbnew.PAD_List_SetDrillSize(self, *args)

   def GetDrillSize(self):
        """
        GetDrillSize(PAD_List self) -> wxSize

        const wxSize&
        D_PAD::GetDrillSize() const
        """
        return _pcbnew.PAD_List_GetDrillSize(self)

   def SetOffset(self, *args):
        """
        SetOffset(PAD_List self, wxPoint aOffset)

        void D_PAD::SetOffset(const
        wxPoint &aOffset)
        """
        return _pcbnew.PAD_List_SetOffset(self, *args)

   def GetOffset(self):
        """
        GetOffset(PAD_List self) -> wxPoint

        const wxPoint&
        D_PAD::GetOffset() const
        """
        return _pcbnew.PAD_List_GetOffset(self)

   def Flip(self, *args):
        """
        Flip(PAD_List self, wxPoint aCentre)

        void D_PAD::Flip(const wxPoint
        &aCentre)

        Function Flip Flip this object, i.e.

        change the board side for this object

        Parameters:
        -----------

        aCentre:  - the rotation point.
        """
        return _pcbnew.PAD_List_Flip(self, *args)

   def SetOrientation(self, *args):
        """
        SetOrientation(PAD_List self, double aAngle)

        void
        D_PAD::SetOrientation(double aAngle)

        Function SetOrientation sets the rotation angle of the pad.

        Parameters:
        -----------

        aAngle:  is tenths of degrees, but will soon be degrees. If it is
        outside of 0 - 3600, then it will be normalized before being saved.
        """
        return _pcbnew.PAD_List_SetOrientation(self, *args)

   def GetOrientation(self):
        """
        GetOrientation(PAD_List self) -> double

        double
        D_PAD::GetOrientation() const

        Function GetOrientation returns the rotation angle of the pad in
        tenths of degrees, but soon degrees.
        """
        return _pcbnew.PAD_List_GetOrientation(self)

   def SetDrillShape(self, *args):
        """
        SetDrillShape(PAD_List self, PAD_DRILL_SHAPE_T aDrillShape)

        void
        D_PAD::SetDrillShape(PAD_DRILL_SHAPE_T aDrillShape)
        """
        return _pcbnew.PAD_List_SetDrillShape(self, *args)

   def GetDrillShape(self):
        """
        GetDrillShape(PAD_List self) -> PAD_DRILL_SHAPE_T

        PAD_DRILL_SHAPE_T
        D_PAD::GetDrillShape() const
        """
        return _pcbnew.PAD_List_GetDrillShape(self)

   def GetOblongDrillGeometry(self, *args):
        """
        GetOblongDrillGeometry(PAD_List self, wxPoint aStartPoint, wxPoint aEndPoint, int & aWidth)

        void
        D_PAD::GetOblongDrillGeometry(wxPoint &aStartPoint, wxPoint
        &aEndPoint, int &aWidth) const

        Function GetOblongDrillGeometry calculates the start point, end point
        and width of an equivalent segment which have the same position and
        width as the hole Usefull to plot/draw oblong holes like segments with
        rounded ends used in draw and plot functions.

        Parameters:
        -----------

        aStartPoint:  = first point of the equivalent segment, relative to the
        pad position.

        aEndPoint:  = second point of the equivalent segment, relative to the
        pad position.

        aWidth:  = width equivalent segment.
        """
        return _pcbnew.PAD_List_GetOblongDrillGeometry(self, *args)

   def SetLayerSet(self, *args):
        """
        SetLayerSet(PAD_List self, LSET aLayerMask)

        void
        D_PAD::SetLayerSet(LSET aLayerMask)
        """
        return _pcbnew.PAD_List_SetLayerSet(self, *args)

   def GetLayerSet(self):
        """
        GetLayerSet(PAD_List self) -> LSET

        LSET D_PAD::GetLayerSet()
        const
        """
        return _pcbnew.PAD_List_GetLayerSet(self)

   def SetAttribute(self, *args):
        """
        SetAttribute(PAD_List self, PAD_ATTR_T aAttribute)

        void
        D_PAD::SetAttribute(PAD_ATTR_T aAttribute)
        """
        return _pcbnew.PAD_List_SetAttribute(self, *args)

   def GetAttribute(self):
        """
        GetAttribute(PAD_List self) -> PAD_ATTR_T

        PAD_ATTR_T
        D_PAD::GetAttribute() const
        """
        return _pcbnew.PAD_List_GetAttribute(self)

   def SetPadToDieLength(self, *args):
        """
        SetPadToDieLength(PAD_List self, int aLength)

        void
        D_PAD::SetPadToDieLength(int aLength)
        """
        return _pcbnew.PAD_List_SetPadToDieLength(self, *args)

   def GetPadToDieLength(self):
        """
        GetPadToDieLength(PAD_List self) -> int

        int
        D_PAD::GetPadToDieLength() const
        """
        return _pcbnew.PAD_List_GetPadToDieLength(self)

   def GetLocalSolderMaskMargin(self):
        """
        GetLocalSolderMaskMargin(PAD_List self) -> int

        int
        D_PAD::GetLocalSolderMaskMargin() const
        """
        return _pcbnew.PAD_List_GetLocalSolderMaskMargin(self)

   def SetLocalSolderMaskMargin(self, *args):
        """
        SetLocalSolderMaskMargin(PAD_List self, int aMargin)

        void
        D_PAD::SetLocalSolderMaskMargin(int aMargin)
        """
        return _pcbnew.PAD_List_SetLocalSolderMaskMargin(self, *args)

   def GetLocalClearance(self):
        """
        GetLocalClearance(PAD_List self) -> int

        int
        D_PAD::GetLocalClearance() const
        """
        return _pcbnew.PAD_List_GetLocalClearance(self)

   def SetLocalClearance(self, *args):
        """
        SetLocalClearance(PAD_List self, int aClearance)

        void
        D_PAD::SetLocalClearance(int aClearance)
        """
        return _pcbnew.PAD_List_SetLocalClearance(self, *args)

   def GetLocalSolderPasteMargin(self):
        """
        GetLocalSolderPasteMargin(PAD_List self) -> int

        int
        D_PAD::GetLocalSolderPasteMargin() const
        """
        return _pcbnew.PAD_List_GetLocalSolderPasteMargin(self)

   def SetLocalSolderPasteMargin(self, *args):
        """
        SetLocalSolderPasteMargin(PAD_List self, int aMargin)

        void
        D_PAD::SetLocalSolderPasteMargin(int aMargin)
        """
        return _pcbnew.PAD_List_SetLocalSolderPasteMargin(self, *args)

   def GetLocalSolderPasteMarginRatio(self):
        """
        GetLocalSolderPasteMarginRatio(PAD_List self) -> double

        double
        D_PAD::GetLocalSolderPasteMarginRatio() const
        """
        return _pcbnew.PAD_List_GetLocalSolderPasteMarginRatio(self)

   def SetLocalSolderPasteMarginRatio(self, *args):
        """
        SetLocalSolderPasteMarginRatio(PAD_List self, double aRatio)

        void
        D_PAD::SetLocalSolderPasteMarginRatio(double aRatio)
        """
        return _pcbnew.PAD_List_SetLocalSolderPasteMarginRatio(self, *args)

   def TransformShapeWithClearanceToPolygon(self, *args):
        """
        TransformShapeWithClearanceToPolygon(PAD_List self, CPOLYGONS_LIST aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount, double aCorrectionFactor)

        void D_PAD::TransformShapeWithClearanceToPolygon(CPOLYGONS_LIST
        &aCornerBuffer, int aClearanceValue, int aCircleToSegmentsCount,
        double aCorrectionFactor) const

        Function TransformShapeWithClearanceToPolygon Convert the pad shape to
        a closed polygon Used in filling zones calculations Circles and arcs
        are approximated by segments.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to store the polygon

        aClearanceValue:  = the clearance around the pad

        aCircleToSegmentsCount:  = the number of segments to approximate a
        circle

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep clearance when the circle is approximated by segment bigger or
        equal to the real clearance value (usually near from 1.0)
        """
        return _pcbnew.PAD_List_TransformShapeWithClearanceToPolygon(self, *args)

   def GetClearance(self, aItem=None):
        """
        GetClearance(PAD_List self, BOARD_CONNECTED_ITEM aItem=None) -> int
        GetClearance(PAD_List self) -> int

        int
        D_PAD::GetClearance(BOARD_CONNECTED_ITEM *aItem=NULL) const

        Function GetClearance returns the clearance in internal units.

        If aItem is not NULL then the returned clearance is the greater of
        this object's clearance and aItem's clearance. If aItem is NULL, then
        this objects clearance is returned.

        Parameters:
        -----------

        aItem:  is another BOARD_CONNECTED_ITEM or NULL

        int - the clearance in internal units.
        """
        return _pcbnew.PAD_List_GetClearance(self, aItem)

   def GetSolderMaskMargin(self):
        """
        GetSolderMaskMargin(PAD_List self) -> int

        int
        D_PAD::GetSolderMaskMargin() const

        Function GetSolderMaskMargin.

        the margin for the solder mask layer usually > 0 (mask shape bigger
        than pad value is 1 - the local value 2 - if null, the parent
        footprint value 1 - if null, the global value
        """
        return _pcbnew.PAD_List_GetSolderMaskMargin(self)

   def GetSolderPasteMargin(self):
        """
        GetSolderPasteMargin(PAD_List self) -> wxSize

        wxSize
        D_PAD::GetSolderPasteMargin() const

        Function GetSolderPasteMargin.

        the margin for the solder mask layer usually < 0 (mask shape smaller
        than pad because the margin can be dependent on the pad size, the
        margin has a x and a y value value is 1 - the local value 2 - if null,
        the parent footprint value 1 - if null, the global value
        """
        return _pcbnew.PAD_List_GetSolderPasteMargin(self)

   def SetZoneConnection(self, *args):
        """
        SetZoneConnection(PAD_List self, ZoneConnection aType)

        void
        D_PAD::SetZoneConnection(ZoneConnection aType)
        """
        return _pcbnew.PAD_List_SetZoneConnection(self, *args)

   def GetZoneConnection(self):
        """
        GetZoneConnection(PAD_List self) -> ZoneConnection

        ZoneConnection
        D_PAD::GetZoneConnection() const
        """
        return _pcbnew.PAD_List_GetZoneConnection(self)

   def SetThermalWidth(self, *args):
        """
        SetThermalWidth(PAD_List self, int aWidth)

        void
        D_PAD::SetThermalWidth(int aWidth)
        """
        return _pcbnew.PAD_List_SetThermalWidth(self, *args)

   def GetThermalWidth(self):
        """
        GetThermalWidth(PAD_List self) -> int

        int
        D_PAD::GetThermalWidth() const
        """
        return _pcbnew.PAD_List_GetThermalWidth(self)

   def SetThermalGap(self, *args):
        """
        SetThermalGap(PAD_List self, int aGap)

        void
        D_PAD::SetThermalGap(int aGap)
        """
        return _pcbnew.PAD_List_SetThermalGap(self, *args)

   def GetThermalGap(self):
        """
        GetThermalGap(PAD_List self) -> int

        int
        D_PAD::GetThermalGap() const
        """
        return _pcbnew.PAD_List_GetThermalGap(self)

   def Draw(self, *args):
        """
        Draw(PAD_List self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode, wxPoint aOffset=)
        Draw(PAD_List self, EDA_DRAW_PANEL * aPanel, wxDC * aDC, GR_DRAWMODE aDrawMode)

        void D_PAD::Draw(EDA_DRAW_PANEL
        *aPanel, wxDC *aDC, GR_DRAWMODE aDrawMode, const wxPoint
        &aOffset=ZeroOffset)

        Function Draw BOARD_ITEMs have their own color information.
        """
        return _pcbnew.PAD_List_Draw(self, *args)

   def DrawShape(self, *args):
        """
        DrawShape(PAD_List self, EDA_RECT aClipBox, wxDC * aDC, PAD_DRAWINFO aDrawInfo)

        void
        D_PAD::DrawShape(EDA_RECT *aClipBox, wxDC *aDC, PAD_DRAWINFO
        &aDrawInfo)

        Function DrawShape basic function to draw a pad.

        This function is used by Draw after calculation of parameters (color,
        ) final orientation transforms are set. It can also be called to draw
        a pad on any panel even if this panel is not a EDA_DRAW_PANEL for
        instance on a wxPanel inside the pad editor.
        """
        return _pcbnew.PAD_List_DrawShape(self, *args)

   def BuildPadPolygon(self, *args):
        """
        BuildPadPolygon(PAD_List self, wxPoint aCoord, wxSize aInflateValue, double aRotation)

        void
        D_PAD::BuildPadPolygon(wxPoint aCoord[4], wxSize aInflateValue, double
        aRotation) const

        Function BuildPadPolygon Has meaning only for polygonal pads
        (trapezoid and rectangular) Build the Corner list of the polygonal
        shape, depending on shape, extra size (clearance ...) and orientation.

        Parameters:
        -----------

        aCoord:  = a buffer to fill (4 corners).

        aInflateValue:  = wxSize: the clearance or margin value. value > 0:
       inflate, < 0 deflate

        aRotation:  = full rotation of the polygon
        """
        return _pcbnew.PAD_List_BuildPadPolygon(self, *args)

   def BuildPadShapePolygon(self, *args):
        """
        BuildPadShapePolygon(PAD_List self, CPOLYGONS_LIST aCornerBuffer, wxSize aInflateValue, int aSegmentsPerCircle, double aCorrectionFactor)

        void
        D_PAD::BuildPadShapePolygon(CPOLYGONS_LIST &aCornerBuffer, wxSize
        aInflateValue, int aSegmentsPerCircle, double aCorrectionFactor) const

        Function BuildPadShapePolygon Build the Corner list of the polygonal
        shape, depending on shape, extra size (clearance ...) pad and
        orientation This function is similar to
        TransformShapeWithClearanceToPolygon, but the difference is
        BuildPadShapePolygon creates a polygon shape exactly similar to pad
        shape, which a size inflated by aInflateValue and
        TransformShapeWithClearanceToPolygon creates a more complex shape (for
        instance a rectangular pad is converted in a rectangulr shape with
        ronded corners)

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to fill.

        aInflateValue:  = the clearance or margin value. value > 0: inflate, <
       0 deflate, = 0 : no change the clearance can have different values for
        x and y directions (relative to the pad)

        aSegmentsPerCircle:  = number of segments to approximate a circle
        (used for round and oblong shapes only (16 to 32 is a good value)

        aCorrectionFactor:  = the correction to apply to circles radius to
        keep the pad size when the circle is approximated by segments
        """
        return _pcbnew.PAD_List_BuildPadShapePolygon(self, *args)

   def BuildPadDrillShapePolygon(self, *args):
        """
        BuildPadDrillShapePolygon(PAD_List self, CPOLYGONS_LIST aCornerBuffer, int aInflateValue, int aSegmentsPerCircle) -> bool

        bool
        D_PAD::BuildPadDrillShapePolygon(CPOLYGONS_LIST &aCornerBuffer, int
        aInflateValue, int aSegmentsPerCircle) const

        Function BuildPadDrillShapePolygon Build the Corner list of the
        polygonal drill shape, depending on shape pad hole and orientation.

        Parameters:
        -----------

        aCornerBuffer:  = a buffer to fill.

        aInflateValue:  = the clearance or margin value. value > 0: inflate, <
       0 deflate, = 0 : no change

        aSegmentsPerCircle:  = number of segments to approximate a circle
        (used for round and oblong shapes only(16 to 32 is a good value)

        false if the pad has no hole, true otherwise
        """
        return _pcbnew.PAD_List_BuildPadDrillShapePolygon(self, *args)

   def BuildSegmentFromOvalShape(self, *args):
        """
        BuildSegmentFromOvalShape(PAD_List self, wxPoint aSegStart, wxPoint aSegEnd, double aRotation, wxSize aMargin) -> int

        int
        D_PAD::BuildSegmentFromOvalShape(wxPoint &aSegStart, wxPoint &aSegEnd,
        double aRotation, const wxSize &aMargin) const

        Function BuildSegmentFromOvalShape Has meaning only for OVAL (and
        ROUND) pads Build an equivalent segment having the same shape as the
        OVAL shape, Useful in draw function and in DRC and HitTest functions,
        because segments are already well handled by track tests.

        Function BuildSegmentFromOvalShape Has meaning only for OVAL (and
        ROUND) pads.

        Parameters:
        -----------

        aSegStart:  = the starting point of the equivalent segment relative to
        the shape position.

        aSegEnd:  = the ending point of the equivalent segment, relative to
        the shape position

        aRotation:  = full rotation of the segment

        aRotation:  = full rotation of the segment

        aMargin:  = a margin around the shape (for instance mask margin)

        the width of the segment  Build an equivalent segment having the same
        shape as the OVAL shape, aSegStart and aSegEnd are the ending points
        of the equivalent segment of the shape aRotation is the asked rotation
        of the segment (usually m_Orient)
        """
        return _pcbnew.PAD_List_BuildSegmentFromOvalShape(self, *args)

   def StringPadName(self, *args):
        """
        StringPadName(PAD_List self, wxString & text)

        void
        D_PAD::StringPadName(wxString &text) const
        """
        return _pcbnew.PAD_List_StringPadName(self, *args)

   def GetBoundingRadius(self):
        """
        GetBoundingRadius(PAD_List self) -> int

        int
        D_PAD::GetBoundingRadius() const

        Function GetBoundingRadius returns the radius of a minimum sized
        circle which fully encloses this pad.
        """
        return _pcbnew.PAD_List_GetBoundingRadius(self)

   def ShapePos(self):
        """
        ShapePos(PAD_List self) -> wxPoint

        const wxPoint
        D_PAD::ShapePos() const
        """
        return _pcbnew.PAD_List_ShapePos(self)

   def GetSubRatsnest(self):
        """
        GetSubRatsnest(PAD_List self) -> int

        int
        D_PAD::GetSubRatsnest() const

        Function GetSubRatsnest.

        int - the netcode
        """
        return _pcbnew.PAD_List_GetSubRatsnest(self)

   def SetSubRatsnest(self, *args):
        """
        SetSubRatsnest(PAD_List self, int aSubRatsnest)

        void
        D_PAD::SetSubRatsnest(int aSubRatsnest)
        """
        return _pcbnew.PAD_List_SetSubRatsnest(self, *args)

   def GetMsgPanelInfo(self, *args):
        """
        GetMsgPanelInfo(PAD_List self, std::vector< MSG_PANEL_ITEM,std::allocator< MSG_PANEL_ITEM > > & aList)

        void
        D_PAD::GetMsgPanelInfo(std::vector< MSG_PANEL_ITEM > &aList)

        Function GetMsgPanelInfo populates aList of MSG_PANEL_ITEM objects
        with it's internal state for display purposes.

        This method replaces DisplayInfo() so that KiCad objects no longer
        have any knowledge of wxWidgets UI objects.

        Parameters:
        -----------

        aList:  is the list to populate.
        """
        return _pcbnew.PAD_List_GetMsgPanelInfo(self, *args)

   def IsOnLayer(self, *args):
        """
        IsOnLayer(PAD_List self, LAYER_ID aLayer) -> bool

        bool
        D_PAD::IsOnLayer(LAYER_ID aLayer) const

        Function IsOnLayer tests to see if this object is on the given layer.

        Is virtual so objects like D_PAD, which reside on multiple layers can
        do their own form of testing.

        Parameters:
        -----------

        aLayer:  The layer to test for.

        bool - true if on given layer, else false.
        """
        return _pcbnew.PAD_List_IsOnLayer(self, *args)

   def HitTest(self, *args):
        """
        HitTest(PAD_List self, wxPoint aPosition) -> bool

        virtual bool
        BOARD_ITEM::HitTest(const EDA_RECT &aRect, bool aContained=true, int
        aAccuracy=0) const

        Function HitTest tests if the aRect intersects or contains this object
        (depending on aContained).

        Parameters:
        -----------

        aRect:  A reference to an EDA_RECT object containg the area to test.

        aContained:  Test if aRect contains this object completly.

        aAccuracy:  Increase the item bounding box by this amount.

        bool - True if aRect contains this object completly or if aRect
        intersects the object and aContained is False, otherwise false.
        """
        return _pcbnew.PAD_List_HitTest(self, *args)

   def GetClass(self):
        """
        GetClass(PAD_List self) -> wxString

        wxString D_PAD::GetClass()
        const

        Function GetClass returns the class name.

        wxString
        """
        return _pcbnew.PAD_List_GetClass(self)

   def GetBoundingBox(self):
        """
        GetBoundingBox(PAD_List self) -> EDA_RECT

        const EDA_RECT
        D_PAD::GetBoundingBox() const

        Function GetBoundingBox returns the orthogonal, bounding box of this
        object for display purposes.

        This box should be an enclosing perimeter for visible components of
        this object, and the units should be in the pcb or schematic
        coordinate system. It is OK to overestimate the size by a few counts.

        """
        return _pcbnew.PAD_List_GetBoundingBox(self)

   def SetDrawCoord(self):
        """
        SetDrawCoord(PAD_List self)

        void
        D_PAD::SetDrawCoord()

        Set absolute coordinates.
        """
        return _pcbnew.PAD_List_SetDrawCoord(self)

   def SetLocalCoord(self):
        """
        SetLocalCoord(PAD_List self)

        void
        D_PAD::SetLocalCoord()

        Set relative coordinates.
        """
        return _pcbnew.PAD_List_SetLocalCoord(self)

   def Compare(self, *args):
        """Compare(PAD_List self, D_PAD padref, D_PAD padcmp) -> int"""
        return _pcbnew.PAD_List_Compare(self, *args)

   def Move(self, *args):
        """
        Move(PAD_List self, wxPoint aMoveVector)

        void D_PAD::Move(const wxPoint
        &aMoveVector)

        Function Move move this object.

        Parameters:
        -----------

        aMoveVector:  - the move vector for this object.
        """
        return _pcbnew.PAD_List_Move(self, *args)

   def Rotate(self, *args):
        """
        Rotate(PAD_List self, wxPoint aRotCentre, double aAngle)

        void D_PAD::Rotate(const
        wxPoint &aRotCentre, double aAngle)

        Function Rotate Rotate this object.

        Parameters:
        -----------

        aRotCentre:  - the rotation point.

        aAngle:  - the rotation angle in 0.1 degree.
        """
        return _pcbnew.PAD_List_Rotate(self, *args)

   def GetSelectMenuText(self):
        """
        GetSelectMenuText(PAD_List self) -> wxString

        wxString
        D_PAD::GetSelectMenuText() const

        Function GetSelectMenuText returns the text to display to be used in
        the selection clarification context menu when multiple items are found
        at the current cursor position.

       The default version of this function raises an assertion in the debug
        mode and returns a string to indicate that it was not overridden to
        provide the object specific text.

        The menu text string.
        """
        return _pcbnew.PAD_List_GetSelectMenuText(self)

   def GetMenuImage(self):
        """
        GetMenuImage(PAD_List self) -> BITMAP_DEF

        BITMAP_DEF
        D_PAD::GetMenuImage() const

        Function GetMenuImage returns a pointer to an image to be used in
        menus.

       The default version returns the right arrow image. Override this
        function to provide object specific menu images. The menu image
        associated with the item.
        """
        return _pcbnew.PAD_List_GetMenuImage(self)

   def ShowPadShape(self):
        """
        ShowPadShape(PAD_List self) -> wxString

        wxString
        D_PAD::ShowPadShape() const

        Function ShowPadShape.

        the name of the shape
        """
        return _pcbnew.PAD_List_ShowPadShape(self)

   def ShowPadAttr(self):
        """
        ShowPadAttr(PAD_List self) -> wxString

        wxString
        D_PAD::ShowPadAttr() const

        Function ShowPadAttr.

        the name of the pad type (attribute) : STD, SMD ...
        """
        return _pcbnew.PAD_List_ShowPadAttr(self)

   def AppendConfigs(self, *args):
        """
        AppendConfigs(PAD_List self, PARAM_CFG_ARRAY * aResult)

        void
        D_PAD::AppendConfigs(PARAM_CFG_ARRAY *aResult)

        Function AppendConfigs appends to aResult the configuration setting
        accessors which will later allow reading or writing of configuration
        file information directly into this object.
        """
        return _pcbnew.PAD_List_AppendConfigs(self, *args)

   def Clone(self):
        """
        Clone(PAD_List self) -> EDA_ITEM

        EDA_ITEM * D_PAD::Clone() const

        Function Clone creates a duplicate of this item with linked list
        members set to NULL.

       The default version will return NULL in release builds and likely
        crash the program. In debug builds, a warning message indicating the
        derived class has not implemented cloning. This really should be a
        pure virtual function. Due to the fact that there are so many objects
        derived from EDA_ITEM, the decision was made to return NULL until all
        the objects derived from EDA_ITEM implement cloning. Once that
        happens, this function should be made pure.

        A clone of the item.
        """
        return _pcbnew.PAD_List_Clone(self)

   def Duplicate(self):
        """
        Duplicate(PAD_List self) -> D_PAD

        D_PAD* D_PAD::Duplicate()
        const

        same as Clone, but returns a D_PAD item.

        Useful mainly for pythons scripts, because Clone (virtual function)
        returns an EDA_ITEM.
        """
        return _pcbnew.PAD_List_Duplicate(self)

   def ViewGetLayers(self, *args):
        """
        ViewGetLayers(PAD_List self, int [] aLayers, int & aCount)

        void
        D_PAD::ViewGetLayers(int aLayers[], int &aCount) const
        """
        return _pcbnew.PAD_List_ViewGetLayers(self, *args)

   def ViewGetLOD(self, *args):
        """
        ViewGetLOD(PAD_List self, int aLayer) -> unsigned int

        unsigned int
        D_PAD::ViewGetLOD(int aLayer) const
        """
        return _pcbnew.PAD_List_ViewGetLOD(self, *args)

   def ViewBBox(self):
        """
        ViewBBox(PAD_List self) -> BOX2I const

        const BOX2I D_PAD::ViewBBox()
        const
        """
        return _pcbnew.PAD_List_ViewBBox(self)

   def CopyNetlistSettings(self, *args):
        """
        CopyNetlistSettings(PAD_List self, D_PAD aPad)

        void
        D_PAD::CopyNetlistSettings(D_PAD *aPad)

        Function CopyNetlistSettings copies the netlist settings to aPad.

       The netlist settings are all of the D_PAD settings not define by a
        D_PAD in a netlist. These setting include local clearances, net names,
        etc. The pad physical geometry settings are not copied.

        Parameters:
        -----------

        aPad:  is the D_PAD to copy the settings to.
        """
        return _pcbnew.PAD_List_CopyNetlistSettings(self, *args)

    __swig_setmethods__["m_TracksConnected"] = _pcbnew.PAD_List_m_TracksConnected_set
    __swig_getmethods__["m_TracksConnected"] = _pcbnew.PAD_List_m_TracksConnected_get
    if _newclass:m_TracksConnected = _swig_property(_pcbnew.PAD_List_m_TracksConnected_get, _pcbnew.PAD_List_m_TracksConnected_set)
    __swig_setmethods__["m_PadsConnected"] = _pcbnew.PAD_List_m_PadsConnected_set
    __swig_getmethods__["m_PadsConnected"] = _pcbnew.PAD_List_m_PadsConnected_get
    if _newclass:m_PadsConnected = _swig_property(_pcbnew.PAD_List_m_PadsConnected_get, _pcbnew.PAD_List_m_PadsConnected_set)
   def ClassOf(self, *args):
        """ClassOf(PAD_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.PAD_List_ClassOf(self, *args)

   def IsConnected(self):
        """
        IsConnected(PAD_List self) -> bool

        bool
        BOARD_CONNECTED_ITEM::IsConnected() const

        >

        Function IsConnected() Returns information if the object is derived
        from BOARD_CONNECTED_ITEM. True if the object is of
        BOARD_CONNECTED_ITEM type, false otherwise.
        """
        return _pcbnew.PAD_List_IsConnected(self)

   def GetNet(self):
        """
        GetNet(PAD_List self) -> NETINFO_ITEM

        NETINFO_ITEM*
        BOARD_CONNECTED_ITEM::GetNet() const

        Function GetNet Returns NET_INFO object for a given item.
        """
        return _pcbnew.PAD_List_GetNet(self)

   def GetNetCode(self):
        """
        GetNetCode(PAD_List self) -> int

        int
        BOARD_CONNECTED_ITEM::GetNetCode() const

        Function GetNetCode.

        int - the net code.
        """
        return _pcbnew.PAD_List_GetNetCode(self)

   def SetNetCode(self, *args):
        """
        SetNetCode(PAD_List self, int aNetCode)

        void
        BOARD_CONNECTED_ITEM::SetNetCode(int aNetCode)

        Function SetNetCode sets net using a net code.

        Parameters:
        -----------

        aNetCode:  is a net code for the new net. It has to exist in
        NETINFO_LIST held by BOARD. Otherwise, item is assigned to the
        unconnected net.
        """
        return _pcbnew.PAD_List_SetNetCode(self, *args)

   def GetSubNet(self):
        """
        GetSubNet(PAD_List self) -> int

        int
        BOARD_CONNECTED_ITEM::GetSubNet() const

        Function GetSubNet.

        int - the sub net code.
        """
        return _pcbnew.PAD_List_GetSubNet(self)

   def SetSubNet(self, *args):
        """
        SetSubNet(PAD_List self, int aSubNetCode)

        void
        BOARD_CONNECTED_ITEM::SetSubNet(int aSubNetCode)
        """
        return _pcbnew.PAD_List_SetSubNet(self, *args)

   def GetZoneSubNet(self):
        """
        GetZoneSubNet(PAD_List self) -> int

        int
        BOARD_CONNECTED_ITEM::GetZoneSubNet() const

        Function GetZoneSubNet.

        int - the sub net code in zone connections.
        """
        return _pcbnew.PAD_List_GetZoneSubNet(self)

   def SetZoneSubNet(self, *args):
        """
        SetZoneSubNet(PAD_List self, int aSubNetCode)

        void
        BOARD_CONNECTED_ITEM::SetZoneSubNet(int aSubNetCode)
        """
        return _pcbnew.PAD_List_SetZoneSubNet(self, *args)

   def GetNetname(self):
        """
        GetNetname(PAD_List self) -> wxString const &

        const
        wxString& BOARD_CONNECTED_ITEM::GetNetname() const

        Function GetNetname.

        wxString - the full netname
        """
        return _pcbnew.PAD_List_GetNetname(self)

   def GetShortNetname(self):
        """
        GetShortNetname(PAD_List self) -> wxString const &

        const
        wxString& BOARD_CONNECTED_ITEM::GetShortNetname() const

        Function GetShortNetname.

        wxString - the short netname
        """
        return _pcbnew.PAD_List_GetShortNetname(self)

   def GetNetClass(self):
        """
        GetNetClass(PAD_List self) -> boost::shared_ptr< NETCLASS >

        NETCLASSPTR
        BOARD_CONNECTED_ITEM::GetNetClass() const

        Function GetNetClass returns the NETCLASS for this item.
        """
        return _pcbnew.PAD_List_GetNetClass(self)

   def GetNetClassName(self):
        """
        GetNetClassName(PAD_List self) -> wxString

        wxString BOARD_CONNECTED_ITEM::GetNetClassName() const

        Function GetNetClassName returns a pointer to the netclass of the
        zone.

        If the net is not found (can happen when a netlist is reread, and the
       net name does not exist, return the default net class (should not
        return a null pointer). the Net Class name of this item
        """
        return _pcbnew.PAD_List_GetNetClassName(self)

   def Back(self):
        """
        Back(PAD_List self) -> BOARD_ITEM

        BOARD_ITEM*
        BOARD_ITEM::Back() const
        """
        return _pcbnew.PAD_List_Back(self)

   def GetLayer(self):
        """
        GetLayer(PAD_List self) -> LAYER_ID

        LAYER_ID
        BOARD_ITEM::GetLayer() const

        Function GetLayer returns the layer this item is on.
        """
        return _pcbnew.PAD_List_GetLayer(self)

   def SetLayer(self, *args):
        """
        SetLayer(PAD_List self, LAYER_ID aLayer)

        virtual void
        BOARD_ITEM::SetLayer(LAYER_ID aLayer)

        Function SetLayer sets the layer this item is on.

        Parameters:
        -----------

        aLayer:  The layer number. is virtual because some items (in fact:
        class DIMENSION) have a slightly different initialization
        """
        return _pcbnew.PAD_List_SetLayer(self, *args)

   def SwapData(self, *args):
        """
        SwapData(PAD_List self, BOARD_ITEM aImage)

        void
        BOARD_ITEM::SwapData(BOARD_ITEM *aImage)

        Swap data between aItem and aImage.

        aItem and aImage should have the same type Used in undo redo command
        to swap values between an item and its copy Only values like layer,
        size .. which are modified by edition are swapped, not the pointers
        like Pnext and Pback because aItem is not changed in the linked list

        Parameters:
        -----------

        aImage:  = the item image which contains data to swap
        """
        return _pcbnew.PAD_List_SwapData(self, *args)

   def IsTrack(self):
        """
        IsTrack(PAD_List self) -> bool

        bool
        BOARD_ITEM::IsTrack() const

        Function IsTrack tests to see if this object is a track or via (or
        microvia).

        form of testing. bool - true if a track or via, else false.
        """
        return _pcbnew.PAD_List_IsTrack(self)

   def IsLocked(self):
        """
        IsLocked(PAD_List self) -> bool

        virtual bool
        BOARD_ITEM::IsLocked() const

        Function IsLocked.

        bool - true if the object is locked, else false
        """
        return _pcbnew.PAD_List_IsLocked(self)

   def UnLink(self):
        """
        UnLink(PAD_List self)

        void BOARD_ITEM::UnLink()

        Function UnLink detaches this object from its owner.

        This base class implementation should work for all derived classes
        which are held in a DLIST<>.
        """
        return _pcbnew.PAD_List_UnLink(self)

   def DeleteStructure(self):
        """
        DeleteStructure(PAD_List self)

        void
        BOARD_ITEM::DeleteStructure()

        Function DeleteStructure deletes this object after UnLink()ing it from
        its owner if it has one.
        """
        return _pcbnew.PAD_List_DeleteStructure(self)

   def ShowShape(self, *args):
        """ShowShape(PAD_List self, STROKE_T aShape) -> wxString"""
        return _pcbnew.PAD_List_ShowShape(self, *args)

   def GetBoard(self):
        """
        GetBoard(PAD_List self) -> BOARD

        BOARD *
        BOARD_ITEM::GetBoard() const

        Function GetBoard returns the BOARD in which this BOARD_ITEM resides,
        or NULL if none.
        """
        return _pcbnew.PAD_List_GetBoard(self)

   def GetLayerName(self):
        """
        GetLayerName(PAD_List self) -> wxString

        wxString
        BOARD_ITEM::GetLayerName() const

        Function GetLayerName returns the name of the PCB layer on which the
        item resides.

        wxString containing the layer name associated with this item.
        """
        return _pcbnew.PAD_List_GetLayerName(self)

   def FormatInternalUnits(self, *args):
        """
        FormatInternalUnits(PAD_List self, int aValue) -> std::string
        FormatInternalUnits(PAD_List self, wxPoint aPoint) -> std::string
        FormatInternalUnits(PAD_List self, wxSize aSize) -> std::string
        """
        return _pcbnew.PAD_List_FormatInternalUnits(self, *args)

   def FormatAngle(self, *args):
        """FormatAngle(PAD_List self, double aAngle) -> std::string"""
        return _pcbnew.PAD_List_FormatAngle(self, *args)

   def Cast_to_TEXTE_PCB(self):
        """Cast_to_TEXTE_PCB(PAD_List self) -> TEXTE_PCB"""
        return _pcbnew.PAD_List_Cast_to_TEXTE_PCB(self)

   def Cast_to_DIMENSION(self):
        """Cast_to_DIMENSION(PAD_List self) -> DIMENSION"""
        return _pcbnew.PAD_List_Cast_to_DIMENSION(self)

   def Cast_to_MODULE(self):
        """Cast_to_MODULE(PAD_List self) -> MODULE"""
        return _pcbnew.PAD_List_Cast_to_MODULE(self)

   def Cast_to_TEXTE_MODULE(self):
        """Cast_to_TEXTE_MODULE(PAD_List self) -> TEXTE_MODULE"""
        return _pcbnew.PAD_List_Cast_to_TEXTE_MODULE(self)

   def Cast_to_DRAWSEGMENT(self):
        """Cast_to_DRAWSEGMENT(PAD_List self) -> DRAWSEGMENT"""
        return _pcbnew.PAD_List_Cast_to_DRAWSEGMENT(self)

   def Cast_to_MARKER_PCB(self):
        """Cast_to_MARKER_PCB(PAD_List self) -> MARKER_PCB"""
        return _pcbnew.PAD_List_Cast_to_MARKER_PCB(self)

   def Cast_to_BOARD(self):
        """Cast_to_BOARD(PAD_List self) -> BOARD"""
        return _pcbnew.PAD_List_Cast_to_BOARD(self)

   def Cast_to_EDGE_MODULE(self):
        """Cast_to_EDGE_MODULE(PAD_List self) -> EDGE_MODULE"""
        return _pcbnew.PAD_List_Cast_to_EDGE_MODULE(self)

   def Cast_to_D_PAD(self):
        """Cast_to_D_PAD(PAD_List self) -> D_PAD"""
        return _pcbnew.PAD_List_Cast_to_D_PAD(self)

   def Cast_to_TRACK(self):
        """Cast_to_TRACK(PAD_List self) -> TRACK"""
        return _pcbnew.PAD_List_Cast_to_TRACK(self)

   def Cast_to_VIA(self):
        """Cast_to_VIA(PAD_List self) -> VIA"""
        return _pcbnew.PAD_List_Cast_to_VIA(self)

   def Cast_to_ZONE_CONTAINER(self):
        """Cast_to_ZONE_CONTAINER(PAD_List self) -> ZONE_CONTAINER"""
        return _pcbnew.PAD_List_Cast_to_ZONE_CONTAINER(self)

   def Cast_to_PCB_TARGET(self):
        """Cast_to_PCB_TARGET(PAD_List self) -> PCB_TARGET"""
        return _pcbnew.PAD_List_Cast_to_PCB_TARGET(self)

   def Type(self):
        """
        Type(PAD_List self) -> KICAD_T

        KICAD_T EDA_ITEM::Type() const

        Function Type()

        returns the type of object. This attribute should never be changed
        after a constructor sets it, so there is no public "setter" method.
        KICAD_T - the type of object.
        """
        return _pcbnew.PAD_List_Type(self)

   def SetTimeStamp(self, *args):
        """
        SetTimeStamp(PAD_List self, time_t aNewTimeStamp)

        void
        EDA_ITEM::SetTimeStamp(time_t aNewTimeStamp)
        """
        return _pcbnew.PAD_List_SetTimeStamp(self, *args)

   def GetTimeStamp(self):
        """
        GetTimeStamp(PAD_List self) -> time_t

        time_t
        EDA_ITEM::GetTimeStamp() const
        """
        return _pcbnew.PAD_List_GetTimeStamp(self)

   def GetList(self):
        """
        GetList(PAD_List self) -> DHEAD

        DHEAD* EDA_ITEM::GetList()
        const
        """
        return _pcbnew.PAD_List_GetList(self)

   def SetParent(self, *args):
        """
        SetParent(PAD_List self, EDA_ITEM aParent)

        void
        EDA_ITEM::SetParent(EDA_ITEM *aParent)
        """
        return _pcbnew.PAD_List_SetParent(self, *args)

   def SetList(self, *args):
        """
        SetList(PAD_List self, DHEAD aList)

        void
        EDA_ITEM::SetList(DHEAD *aList)
        """
        return _pcbnew.PAD_List_SetList(self, *args)

   def IsNew(self):
        """
        IsNew(PAD_List self) -> bool

        bool EDA_ITEM::IsNew() const

        """
        return _pcbnew.PAD_List_IsNew(self)

   def IsModified(self):
        """
        IsModified(PAD_List self) -> bool

        bool
        EDA_ITEM::IsModified() const
        """
        return _pcbnew.PAD_List_IsModified(self)

   def IsMoving(self):
        """
        IsMoving(PAD_List self) -> bool

        bool EDA_ITEM::IsMoving()
        const
        """
        return _pcbnew.PAD_List_IsMoving(self)

   def IsDragging(self):
        """
        IsDragging(PAD_List self) -> bool

        bool
        EDA_ITEM::IsDragging() const
        """
        return _pcbnew.PAD_List_IsDragging(self)

   def IsWireImage(self):
        """
        IsWireImage(PAD_List self) -> bool

        bool
        EDA_ITEM::IsWireImage() const
        """
        return _pcbnew.PAD_List_IsWireImage(self)

   def IsSelected(self):
        """
        IsSelected(PAD_List self) -> bool

        bool
        EDA_ITEM::IsSelected() const
        """
        return _pcbnew.PAD_List_IsSelected(self)

   def IsResized(self):
        """
        IsResized(PAD_List self) -> bool

        bool
        EDA_ITEM::IsResized() const
        """
        return _pcbnew.PAD_List_IsResized(self)

   def IsHighlighted(self):
        """
        IsHighlighted(PAD_List self) -> bool

        bool
        EDA_ITEM::IsHighlighted() const
        """
        return _pcbnew.PAD_List_IsHighlighted(self)

   def IsBrightened(self):
        """
        IsBrightened(PAD_List self) -> bool

        bool
        EDA_ITEM::IsBrightened() const
        """
        return _pcbnew.PAD_List_IsBrightened(self)

   def SetWireImage(self):
        """
        SetWireImage(PAD_List self)

        void
        EDA_ITEM::SetWireImage()
        """
        return _pcbnew.PAD_List_SetWireImage(self)

   def SetSelected(self):
        """
        SetSelected(PAD_List self)

        void
        EDA_ITEM::SetSelected()
        """
        return _pcbnew.PAD_List_SetSelected(self)

   def SetHighlighted(self):
        """
        SetHighlighted(PAD_List self)

        void
        EDA_ITEM::SetHighlighted()
        """
        return _pcbnew.PAD_List_SetHighlighted(self)

   def SetBrightened(self):
        """
        SetBrightened(PAD_List self)

        void
        EDA_ITEM::SetBrightened()
        """
        return _pcbnew.PAD_List_SetBrightened(self)

   def ClearSelected(self):
        """
        ClearSelected(PAD_List self)

        void
        EDA_ITEM::ClearSelected()
        """
        return _pcbnew.PAD_List_ClearSelected(self)

   def ClearHighlighted(self):
        """
        ClearHighlighted(PAD_List self)

        void
        EDA_ITEM::ClearHighlighted()
        """
        return _pcbnew.PAD_List_ClearHighlighted(self)

   def ClearBrightened(self):
        """
        ClearBrightened(PAD_List self)

        void
        EDA_ITEM::ClearBrightened()
        """
        return _pcbnew.PAD_List_ClearBrightened(self)

   def SetModified(self):
        """
        SetModified(PAD_List self)

        void
        EDA_ITEM::SetModified()
        """
        return _pcbnew.PAD_List_SetModified(self)

   def GetState(self, *args):
        """
        GetState(PAD_List self, int type) -> int

        int EDA_ITEM::GetState(int
        type) const
        """
        return _pcbnew.PAD_List_GetState(self, *args)

   def SetState(self, *args):
        """
        SetState(PAD_List self, int type, int state)

        void
        EDA_ITEM::SetState(int type, int state)
        """
        return _pcbnew.PAD_List_SetState(self, *args)

   def GetStatus(self):
        """
        GetStatus(PAD_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetStatus() const
        """
        return _pcbnew.PAD_List_GetStatus(self)

   def SetStatus(self, *args):
        """
        SetStatus(PAD_List self, STATUS_FLAGS aStatus)

        void
        EDA_ITEM::SetStatus(STATUS_FLAGS aStatus)
        """
        return _pcbnew.PAD_List_SetStatus(self, *args)

   def SetFlags(self, *args):
        """
        SetFlags(PAD_List self, STATUS_FLAGS aMask)

        void
        EDA_ITEM::SetFlags(STATUS_FLAGS aMask)
        """
        return _pcbnew.PAD_List_SetFlags(self, *args)

   def ClearFlags(self, *args):
        """
        ClearFlags(PAD_List self, STATUS_FLAGS aMask=-1)
        ClearFlags(PAD_List self)

        void
        EDA_ITEM::ClearFlags(STATUS_FLAGS aMask=EDA_ITEM_ALL_FLAGS)
        """
        return _pcbnew.PAD_List_ClearFlags(self, *args)

   def GetFlags(self):
        """
        GetFlags(PAD_List self) -> STATUS_FLAGS

        STATUS_FLAGS
        EDA_ITEM::GetFlags() const
        """
        return _pcbnew.PAD_List_GetFlags(self)

   def SetImage(self, *args):
        """
        SetImage(PAD_List self, EDA_ITEM aItem)

        void
        EDA_ITEM::SetImage(EDA_ITEM *aItem)
        """
        return _pcbnew.PAD_List_SetImage(self, *args)

   def SetForceVisible(self, *args):
        """
        SetForceVisible(PAD_List self, bool aEnable)

        void
        EDA_ITEM::SetForceVisible(bool aEnable)

        Function SetForceVisible is used to set and cleag force visible flag
        used to force the item to be drawn even if it's draw attribute is set
        to not visible.

        Parameters:
        -----------

        aEnable:  True forces the item to be drawn. False uses the item's
        visibility setting to determine if the item is to be drawn.
        """
        return _pcbnew.PAD_List_SetForceVisible(self, *args)

   def IterateForward(self, *args):
        """IterateForward(PAD_List self, EDA_ITEM listStart, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT"""
        return _pcbnew.PAD_List_IterateForward(self, *args)

   def Visit(self, *args):
        """
        Visit(PAD_List self, INSPECTOR inspector, void const * testData, KICAD_T const [] scanTypes) -> SEARCH_RESULT

        SEARCH_RESULT
        EDA_ITEM::Visit(INSPECTOR *inspector, const void *testData, const
        KICAD_T scanTypes[])

        Function Visit may be re-implemented for each derived class in order
        to handle all the types given by its member data.

        Implementations should call inspector->Inspect() on types in
        scanTypes[], and may use IterateForward() to do so on lists of such
        data.

        Parameters:
        -----------

        inspector:  An INSPECTOR instance to use in the inspection.

        testData:  Arbitrary data used by the inspector.

        scanTypes:  Which KICAD_T types are of interest and the order is
        significant too, terminated by EOT.

        SEARCH_RESULT SEARCH_QUIT if the Iterator is to stop the scan, else
        SCAN_CONTINUE, and determined by the inspector.
        """
        return _pcbnew.PAD_List_Visit(self, *args)

   def Matches(self, *args):
        """
        Matches(PAD_List self, wxFindReplaceData & aSearchData, void * aAuxData, wxPoint aFindLocation) -> bool
        Matches(PAD_List self, wxString const & aText, wxFindReplaceData & aSearchData) -> bool

        bool
        EDA_ITEM::Matches(const wxString &aText, wxFindReplaceData
        &aSearchData)

        Function Matches compares aText against search criteria in
        aSearchData.

        Parameters:
        -----------

        aText:  A reference to a wxString object containing the string to
        test.

        aSearchData:  The criteria to search against.

        True if aText matches the search criteria in aSearchData.
        """
        return _pcbnew.PAD_List_Matches(self, *args)

   def Replace(self, *args):
        """
        Replace(PAD_List self, wxFindReplaceData & aSearchData, wxString & aText) -> bool
        Replace(PAD_List self, wxFindReplaceData & aSearchData, void * aAuxData=None) -> bool
        Replace(PAD_List self, wxFindReplaceData & aSearchData) -> bool

        virtual bool
        EDA_ITEM::Replace(wxFindReplaceData &aSearchData, void *aAuxData=NULL)

        Function Replace performs a text replace using the find and replace
        criteria in aSearchData on items that support text find and replace.

        This function must be overridden for items that support text replace.

        Parameters:
        -----------

        aSearchData:  A reference to a wxFindReplaceData object containing the
        search and replace criteria.

        aAuxData:  A pointer to optional data required for the search or NULL
        if not used.

        True if the item text was modified, otherwise false.
        """
        return _pcbnew.PAD_List_Replace(self, *args)

   def IsReplaceable(self):
        """
        IsReplaceable(PAD_List self) -> bool

        virtual bool
        EDA_ITEM::IsReplaceable() const

        Function IsReplaceable.

        Override this method in any derived object that supports test find and
        replace.

        True if the item has replaceable text that can be modified using the
        find and replace dialog.
        """
        return _pcbnew.PAD_List_IsReplaceable(self)

   def __lt__(self, *args):
        """__lt__(PAD_List self, EDA_ITEM aItem) -> bool"""
        return _pcbnew.PAD_List___lt__(self, *args)

   def Sort(self, *args):
        """Sort(PAD_List self, EDA_ITEM aLeft, EDA_ITEM aRight) -> bool"""
        return _pcbnew.PAD_List_Sort(self, *args)

PAD_List_swigregister = _pcbnew.PAD_List_swigregister
PAD_List_swigregister(PAD_List)

class VIA_DIMENSION_Vector(_object):
    """Proxy of C++ std::vector<(VIA_DIMENSION)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VIA_DIMENSION_Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VIA_DIMENSION_Vector, name)
    __repr__ = _swig_repr
   def iterator(self):
        """iterator(VIA_DIMENSION_Vector self) -> SwigPyIterator"""
        return _pcbnew.VIA_DIMENSION_Vector_iterator(self)

   def __iter__(self): return self.iterator()
   def __nonzero__(self):
        """__nonzero__(VIA_DIMENSION_Vector self) -> bool"""
        return _pcbnew.VIA_DIMENSION_Vector___nonzero__(self)

   def __bool__(self):
        """__bool__(VIA_DIMENSION_Vector self) -> bool"""
        return _pcbnew.VIA_DIMENSION_Vector___bool__(self)

   def __len__(self):
        """__len__(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::size_type"""
        return _pcbnew.VIA_DIMENSION_Vector___len__(self)

   def pop(self):
        """pop(VIA_DIMENSION_Vector self) -> VIA_DIMENSION"""
        return _pcbnew.VIA_DIMENSION_Vector_pop(self)

   def __getslice__(self, *args):
        """__getslice__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i, std::vector< VIA_DIMENSION >::difference_type j) -> VIA_DIMENSION_Vector"""
        return _pcbnew.VIA_DIMENSION_Vector___getslice__(self, *args)

   def __setslice__(self, *args):
        """
        __setslice__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i, std::vector< VIA_DIMENSION >::difference_type j,
            VIA_DIMENSION_Vector v=std::vector< VIA_DIMENSION,std::allocator< VIA_DIMENSION > >())
        __setslice__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i, std::vector< VIA_DIMENSION >::difference_type j)
        """
        return _pcbnew.VIA_DIMENSION_Vector___setslice__(self, *args)

   def __delslice__(self, *args):
        """__delslice__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i, std::vector< VIA_DIMENSION >::difference_type j)"""
        return _pcbnew.VIA_DIMENSION_Vector___delslice__(self, *args)

   def __delitem__(self, *args):
        """
        __delitem__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i)
        __delitem__(VIA_DIMENSION_Vector self, PySliceObject * slice)
        """
        return _pcbnew.VIA_DIMENSION_Vector___delitem__(self, *args)

   def __getitem__(self, *args):
        """
        __getitem__(VIA_DIMENSION_Vector self, PySliceObject * slice) -> VIA_DIMENSION_Vector
        __getitem__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i) -> VIA_DIMENSION
        """
        return _pcbnew.VIA_DIMENSION_Vector___getitem__(self, *args)

   def __setitem__(self, *args):
        """
        __setitem__(VIA_DIMENSION_Vector self, PySliceObject * slice, VIA_DIMENSION_Vector v)
        __setitem__(VIA_DIMENSION_Vector self, PySliceObject * slice)
        __setitem__(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::difference_type i, VIA_DIMENSION x)
        """
        return _pcbnew.VIA_DIMENSION_Vector___setitem__(self, *args)

   def append(self, *args):
        """append(VIA_DIMENSION_Vector self, VIA_DIMENSION x)"""
        return _pcbnew.VIA_DIMENSION_Vector_append(self, *args)

   def empty(self):
        """empty(VIA_DIMENSION_Vector self) -> bool"""
        return _pcbnew.VIA_DIMENSION_Vector_empty(self)

   def size(self):
        """size(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::size_type"""
        return _pcbnew.VIA_DIMENSION_Vector_size(self)

   def clear(self):
        """clear(VIA_DIMENSION_Vector self)"""
        return _pcbnew.VIA_DIMENSION_Vector_clear(self)

   def swap(self, *args):
        """swap(VIA_DIMENSION_Vector self, VIA_DIMENSION_Vector v)"""
        return _pcbnew.VIA_DIMENSION_Vector_swap(self, *args)

   def get_allocator(self):
        """get_allocator(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::allocator_type"""
        return _pcbnew.VIA_DIMENSION_Vector_get_allocator(self)

   def begin(self):
        """begin(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::iterator"""
        return _pcbnew.VIA_DIMENSION_Vector_begin(self)

   def end(self):
        """end(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::iterator"""
        return _pcbnew.VIA_DIMENSION_Vector_end(self)

   def rbegin(self):
        """rbegin(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::reverse_iterator"""
        return _pcbnew.VIA_DIMENSION_Vector_rbegin(self)

   def rend(self):
        """rend(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::reverse_iterator"""
        return _pcbnew.VIA_DIMENSION_Vector_rend(self)

   def pop_back(self):
        """pop_back(VIA_DIMENSION_Vector self)"""
        return _pcbnew.VIA_DIMENSION_Vector_pop_back(self)

   def erase(self, *args):
        """
        erase(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::iterator pos) -> std::vector< VIA_DIMENSION >::iterator
        erase(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::iterator first, std::vector< VIA_DIMENSION >::iterator last) -> std::vector< VIA_DIMENSION >::iterator
        """
        return _pcbnew.VIA_DIMENSION_Vector_erase(self, *args)

   def __init__(self, *args):
        """
        __init__(std::vector<(VIA_DIMENSION)> self) -> VIA_DIMENSION_Vector
        __init__(std::vector<(VIA_DIMENSION)> self, VIA_DIMENSION_Vector arg2) -> VIA_DIMENSION_Vector
        __init__(std::vector<(VIA_DIMENSION)> self, std::vector< VIA_DIMENSION >::size_type size) -> VIA_DIMENSION_Vector
        __init__(std::vector<(VIA_DIMENSION)> self, std::vector< VIA_DIMENSION >::size_type size, VIA_DIMENSION value) -> VIA_DIMENSION_Vector
        """
        this = _pcbnew.new_VIA_DIMENSION_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
   def push_back(self, *args):
        """push_back(VIA_DIMENSION_Vector self, VIA_DIMENSION x)"""
        return _pcbnew.VIA_DIMENSION_Vector_push_back(self, *args)

   def front(self):
        """front(VIA_DIMENSION_Vector self) -> VIA_DIMENSION"""
        return _pcbnew.VIA_DIMENSION_Vector_front(self)

   def back(self):
        """back(VIA_DIMENSION_Vector self) -> VIA_DIMENSION"""
        return _pcbnew.VIA_DIMENSION_Vector_back(self)

   def assign(self, *args):
        """assign(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::size_type n, VIA_DIMENSION x)"""
        return _pcbnew.VIA_DIMENSION_Vector_assign(self, *args)

   def resize(self, *args):
        """
        resize(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::size_type new_size)
        resize(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::size_type new_size, VIA_DIMENSION x)
        """
        return _pcbnew.VIA_DIMENSION_Vector_resize(self, *args)

   def insert(self, *args):
        """
        insert(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::iterator pos, VIA_DIMENSION x) -> std::vector< VIA_DIMENSION >::iterator
        insert(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::iterator pos, std::vector< VIA_DIMENSION >::size_type n,
            VIA_DIMENSION x)
        """
        return _pcbnew.VIA_DIMENSION_Vector_insert(self, *args)

   def reserve(self, *args):
        """reserve(VIA_DIMENSION_Vector self, std::vector< VIA_DIMENSION >::size_type n)"""
        return _pcbnew.VIA_DIMENSION_Vector_reserve(self, *args)

   def capacity(self):
        """capacity(VIA_DIMENSION_Vector self) -> std::vector< VIA_DIMENSION >::size_type"""
        return _pcbnew.VIA_DIMENSION_Vector_capacity(self)

    __swig_destroy__ = _pcbnew.delete_VIA_DIMENSION_Vector
    __del__ = lambda self : None;
VIA_DIMENSION_Vector_swigregister = _pcbnew.VIA_DIMENSION_Vector_swigregister
VIA_DIMENSION_Vector_swigregister(VIA_DIMENSION_Vector)

class RASTNET_Vector(_object):
    """Proxy of C++ std::vector<(RATSNEST_ITEM)> class"""
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RASTNET_Vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RASTNET_Vector, name)
    __repr__ = _swig_repr
   def iterator(self):
        """iterator(RASTNET_Vector self) -> SwigPyIterator"""
        return _pcbnew.RASTNET_Vector_iterator(self)

   def __iter__(self): return self.iterator()
   def __nonzero__(self):
        """__nonzero__(RASTNET_Vector self) -> bool"""
        return _pcbnew.RASTNET_Vector___nonzero__(self)

   def __bool__(self):
        """__bool__(RASTNET_Vector self) -> bool"""
        return _pcbnew.RASTNET_Vector___bool__(self)

   def __len__(self):
        """__len__(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::size_type"""
        return _pcbnew.RASTNET_Vector___len__(self)

   def pop(self):
        """pop(RASTNET_Vector self) -> RATSNEST_ITEM"""
        return _pcbnew.RASTNET_Vector_pop(self)

   def __getslice__(self, *args):
        """__getslice__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i, std::vector< RATSNEST_ITEM >::difference_type j) -> RASTNET_Vector"""
        return _pcbnew.RASTNET_Vector___getslice__(self, *args)

   def __setslice__(self, *args):
        """
        __setslice__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i, std::vector< RATSNEST_ITEM >::difference_type j,
            RASTNET_Vector v=std::vector< RATSNEST_ITEM,std::allocator< RATSNEST_ITEM > >())
        __setslice__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i, std::vector< RATSNEST_ITEM >::difference_type j)
        """
        return _pcbnew.RASTNET_Vector___setslice__(self, *args)

   def __delslice__(self, *args):
        """__delslice__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i, std::vector< RATSNEST_ITEM >::difference_type j)"""
        return _pcbnew.RASTNET_Vector___delslice__(self, *args)

   def __delitem__(self, *args):
        """
        __delitem__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i)
        __delitem__(RASTNET_Vector self, PySliceObject * slice)
        """
        return _pcbnew.RASTNET_Vector___delitem__(self, *args)

   def __getitem__(self, *args):
        """
        __getitem__(RASTNET_Vector self, PySliceObject * slice) -> RASTNET_Vector
        __getitem__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i) -> RATSNEST_ITEM
        """
        return _pcbnew.RASTNET_Vector___getitem__(self, *args)

   def __setitem__(self, *args):
        """
        __setitem__(RASTNET_Vector self, PySliceObject * slice, RASTNET_Vector v)
        __setitem__(RASTNET_Vector self, PySliceObject * slice)
        __setitem__(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::difference_type i, RATSNEST_ITEM x)
        """
        return _pcbnew.RASTNET_Vector___setitem__(self, *args)

   def append(self, *args):
        """append(RASTNET_Vector self, RATSNEST_ITEM x)"""
        return _pcbnew.RASTNET_Vector_append(self, *args)

   def empty(self):
        """empty(RASTNET_Vector self) -> bool"""
        return _pcbnew.RASTNET_Vector_empty(self)

   def size(self):
        """size(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::size_type"""
        return _pcbnew.RASTNET_Vector_size(self)

   def clear(self):
        """clear(RASTNET_Vector self)"""
        return _pcbnew.RASTNET_Vector_clear(self)

   def swap(self, *args):
        """swap(RASTNET_Vector self, RASTNET_Vector v)"""
        return _pcbnew.RASTNET_Vector_swap(self, *args)

   def get_allocator(self):
        """get_allocator(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::allocator_type"""
        return _pcbnew.RASTNET_Vector_get_allocator(self)

   def begin(self):
        """begin(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::iterator"""
        return _pcbnew.RASTNET_Vector_begin(self)

   def end(self):
        """end(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::iterator"""
        return _pcbnew.RASTNET_Vector_end(self)

   def rbegin(self):
        """rbegin(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::reverse_iterator"""
        return _pcbnew.RASTNET_Vector_rbegin(self)

   def rend(self):
        """rend(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::reverse_iterator"""
        return _pcbnew.RASTNET_Vector_rend(self)

   def pop_back(self):
        """pop_back(RASTNET_Vector self)"""
        return _pcbnew.RASTNET_Vector_pop_back(self)

   def erase(self, *args):
        """
        erase(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::iterator pos) -> std::vector< RATSNEST_ITEM >::iterator
        erase(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::iterator first, std::vector< RATSNEST_ITEM >::iterator last) -> std::vector< RATSNEST_ITEM >::iterator
        """
        return _pcbnew.RASTNET_Vector_erase(self, *args)

   def __init__(self, *args):
        """
        __init__(std::vector<(RATSNEST_ITEM)> self) -> RASTNET_Vector
        __init__(std::vector<(RATSNEST_ITEM)> self, RASTNET_Vector arg2) -> RASTNET_Vector
        __init__(std::vector<(RATSNEST_ITEM)> self, std::vector< RATSNEST_ITEM >::size_type size) -> RASTNET_Vector
        __init__(std::vector<(RATSNEST_ITEM)> self, std::vector< RATSNEST_ITEM >::size_type size, RATSNEST_ITEM value) -> RASTNET_Vector
        """
        this = _pcbnew.new_RASTNET_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
   def push_back(self, *args):
        """push_back(RASTNET_Vector self, RATSNEST_ITEM x)"""
        return _pcbnew.RASTNET_Vector_push_back(self, *args)

   def front(self):
        """front(RASTNET_Vector self) -> RATSNEST_ITEM"""
        return _pcbnew.RASTNET_Vector_front(self)

   def back(self):
        """back(RASTNET_Vector self) -> RATSNEST_ITEM"""
        return _pcbnew.RASTNET_Vector_back(self)

   def assign(self, *args):
        """assign(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::size_type n, RATSNEST_ITEM x)"""
        return _pcbnew.RASTNET_Vector_assign(self, *args)

   def resize(self, *args):
        """
        resize(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::size_type new_size)
        resize(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::size_type new_size, RATSNEST_ITEM x)
        """
        return _pcbnew.RASTNET_Vector_resize(self, *args)

   def insert(self, *args):
        """
        insert(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::iterator pos, RATSNEST_ITEM x) -> std::vector< RATSNEST_ITEM >::iterator
        insert(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::iterator pos, std::vector< RATSNEST_ITEM >::size_type n,
            RATSNEST_ITEM x)
        """
        return _pcbnew.RASTNET_Vector_insert(self, *args)

   def reserve(self, *args):
        """reserve(RASTNET_Vector self, std::vector< RATSNEST_ITEM >::size_type n)"""
        return _pcbnew.RASTNET_Vector_reserve(self, *args)

   def capacity(self):
        """capacity(RASTNET_Vector self) -> std::vector< RATSNEST_ITEM >::size_type"""
        return _pcbnew.RASTNET_Vector_capacity(self)

    __swig_destroy__ = _pcbnew.delete_RASTNET_Vector
    __del__ = lambda self : None;
RASTNET_Vector_swigregister = _pcbnew.RASTNET_Vector_swigregister
RASTNET_Vector_swigregister(RASTNET_Vector)

def GetPluginForPath(lpath):
    return IO_MGR.PluginFind(IO_MGR.LEGACY)

def FootprintEnumerate(lpath):
    plug = GetPluginForPath(lpath)
    return plug.FootprintEnumerate(lpath)

def FootprintLoad(lpath,name):
    plug = GetPluginForPath(lpath)
    return plug.FootprintLoad(lpath,name)

def FootprintSave(lpath,module):
    plug = GetPluginForPath(lpath)
    return plug.FootprintSave(lpath,module)

def FootprintDelete(lpath,name):
    plug = GetPluginForPath(lpath)
    plug.FootprintDelete(lpath,name)

def FootprintLibCreate(lpath):
    plug = GetPluginForPath(lpath)
    plug.FootprintLibCreate(lpath)

def FootprintLibDelete(lpath):
    plug = GetPluginForPath(lpath)
    plug.FootprintLibDelete(lpath)

def FootprintIsWritable(lpath):
    plug = GetPluginForPath(lpath)
    plug.FootprintLibIsWritable(lpath)

class PYTHON_FOOTPRINT_WIZARDS(_object):
    """
    C++ includes:
    pcbnew_footprint_wizards.h
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PYTHON_FOOTPRINT_WIZARDS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PYTHON_FOOTPRINT_WIZARDS, name)
    __repr__ = _swig_repr
   def register_wizard(*args):
        """register_wizard(PyObject * wizard)"""
        return _pcbnew.PYTHON_FOOTPRINT_WIZARDS_register_wizard(*args)

    if _newclass:register_wizard = staticmethod(register_wizard)
    __swig_getmethods__["register_wizard"] = lambda x: register_wizard
   def deregister_wizard(*args):
        """deregister_wizard(PyObject * wizard)"""
        return _pcbnew.PYTHON_FOOTPRINT_WIZARDS_deregister_wizard(*args)

    if _newclass:deregister_wizard = staticmethod(deregister_wizard)
    __swig_getmethods__["deregister_wizard"] = lambda x: deregister_wizard
   def __init__(self):
        """
        __init__(PYTHON_FOOTPRINT_WIZARDS self) -> PYTHON_FOOTPRINT_WIZARDS

        C++ includes:
        pcbnew_footprint_wizards.h
        """
        this = _pcbnew.new_PYTHON_FOOTPRINT_WIZARDS()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _pcbnew.delete_PYTHON_FOOTPRINT_WIZARDS
    __del__ = lambda self : None;
PYTHON_FOOTPRINT_WIZARDS_swigregister = _pcbnew.PYTHON_FOOTPRINT_WIZARDS_swigregister
PYTHON_FOOTPRINT_WIZARDS_swigregister(PYTHON_FOOTPRINT_WIZARDS)

def PYTHON_FOOTPRINT_WIZARDS_register_wizard(*args):
  """PYTHON_FOOTPRINT_WIZARDS_register_wizard(PyObject * wizard)"""
  return _pcbnew.PYTHON_FOOTPRINT_WIZARDS_register_wizard(*args)

def PYTHON_FOOTPRINT_WIZARDS_deregister_wizard(*args):
  """PYTHON_FOOTPRINT_WIZARDS_deregister_wizard(PyObject * wizard)"""
  return _pcbnew.PYTHON_FOOTPRINT_WIZARDS_deregister_wizard(*args)

def ToMM(iu):
   if type(iu) in [int,float]:
      return float(iu) / float(1e6)
   elif type(iu) in [wxPoint,wxSize]:
      return tuple(map(ToMM,iu))

def FromMM(mm):
   if type(mm) in [int,float]:
      return int(float(mm) * float(1e6))
   elif type(mm) in [wxPoint,wxSize]:
     return tuple(map(FromMM,mm))

def ToMils(iu):
   if type(iu) in [int,float]:
     return float(iu) / float((1e6 * 0.0254))
   elif type(iu) in [wxPoint,wxSize]:
     return tuple(map(ToMils,iu))

def FromMils(mils):
   if type(mils) in [int,float]:
      return int(float(mils)*float((1e6 * 0.0254)))
   elif type(mils) in [wxPoint,wxSize]:
     return tuple(map(FromMils,mils))

def wxSizeMM(mmx,mmy): return wxSize(FromMM(mmx),FromMM(mmy))
def wxSizeMils(mmx,mmy): return wxSize(FromMils(mmx),FromMils(mmy))

def wxPointMM(mmx,mmy): return wxPoint(FromMM(mmx),FromMM(mmy))
def wxPointMils(mmx,mmy): return wxPoint(FromMils(mmx),FromMils(mmy))

def wxRectMM(x,y,wx,wy):
     x = int(FromMM(x))
     y = int(FromMM(y))
     wx = int(FromMM(wx))
     wy = int (FromMM(wy))
     return wxRect(x,y,wx,wy)

def wxRectMils(x,y,wx,wy):
     x = int(FromMils(x))
     y = int(FromMils(y))
     wx = int(FromMils(wx))
     wy = int (FromMils(wy))
     return wxRect(x,y,wx,wy)


# This file is compatible with both classic and new-style classes.

'''
